
Scheduler_RTOS_LED_Blink_AVR323.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000077e8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000ca  00800060  000077e8  0000787c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000069c  0080012a  0080012a  00007946  2**0
                  ALLOC
  3 .stab         00009c60  00000000  00000000  00007948  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00006264  00000000  00000000  000115a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0001780c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  0001794c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  00017abc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  00019705  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  0001a5f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  0001b3a0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  0001b500  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  0001b78d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0001bf5b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 28 00 	jmp	0x50	; 0x50 <__ctors_end>
       4:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
       8:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
       c:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      10:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      14:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      18:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      1c:	0c 94 98 11 	jmp	0x2330	; 0x2330 <__vector_7>
      20:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      24:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      28:	0c 94 d4 05 	jmp	0xba8	; 0xba8 <__vector_10>
      2c:	0c 94 a1 05 	jmp	0xb42	; 0xb42 <__vector_11>
      30:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      34:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      38:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      3c:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      40:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      44:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      48:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      4c:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>

00000050 <__ctors_end>:
      50:	11 24       	eor	r1, r1
      52:	1f be       	out	0x3f, r1	; 63
      54:	cf e5       	ldi	r28, 0x5F	; 95
      56:	d8 e0       	ldi	r29, 0x08	; 8
      58:	de bf       	out	0x3e, r29	; 62
      5a:	cd bf       	out	0x3d, r28	; 61

0000005c <__do_copy_data>:
      5c:	11 e0       	ldi	r17, 0x01	; 1
      5e:	a0 e6       	ldi	r26, 0x60	; 96
      60:	b0 e0       	ldi	r27, 0x00	; 0
      62:	e8 ee       	ldi	r30, 0xE8	; 232
      64:	f7 e7       	ldi	r31, 0x77	; 119
      66:	02 c0       	rjmp	.+4      	; 0x6c <.do_copy_data_start>

00000068 <.do_copy_data_loop>:
      68:	05 90       	lpm	r0, Z+
      6a:	0d 92       	st	X+, r0

0000006c <.do_copy_data_start>:
      6c:	aa 32       	cpi	r26, 0x2A	; 42
      6e:	b1 07       	cpc	r27, r17
      70:	d9 f7       	brne	.-10     	; 0x68 <.do_copy_data_loop>

00000072 <__do_clear_bss>:
      72:	17 e0       	ldi	r17, 0x07	; 7
      74:	aa e2       	ldi	r26, 0x2A	; 42
      76:	b1 e0       	ldi	r27, 0x01	; 1
      78:	01 c0       	rjmp	.+2      	; 0x7c <.do_clear_bss_start>

0000007a <.do_clear_bss_loop>:
      7a:	1d 92       	st	X+, r1

0000007c <.do_clear_bss_start>:
      7c:	a6 3c       	cpi	r26, 0xC6	; 198
      7e:	b1 07       	cpc	r27, r17
      80:	e1 f7       	brne	.-8      	; 0x7a <.do_clear_bss_loop>
      82:	0e 94 40 0e 	call	0x1c80	; 0x1c80 <main>
      86:	0c 94 f2 3b 	jmp	0x77e4	; 0x77e4 <_exit>

0000008a <__bad_interrupt>:
      8a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000008e <__fixunssfsi>:
      8e:	ef 92       	push	r14
      90:	ff 92       	push	r15
      92:	0f 93       	push	r16
      94:	1f 93       	push	r17
      96:	7b 01       	movw	r14, r22
      98:	8c 01       	movw	r16, r24
      9a:	20 e0       	ldi	r18, 0x00	; 0
      9c:	30 e0       	ldi	r19, 0x00	; 0
      9e:	40 e0       	ldi	r20, 0x00	; 0
      a0:	5f e4       	ldi	r21, 0x4F	; 79
      a2:	0e 94 47 03 	call	0x68e	; 0x68e <__gesf2>
      a6:	88 23       	and	r24, r24
      a8:	8c f0       	brlt	.+34     	; 0xcc <__fixunssfsi+0x3e>
      aa:	c8 01       	movw	r24, r16
      ac:	b7 01       	movw	r22, r14
      ae:	20 e0       	ldi	r18, 0x00	; 0
      b0:	30 e0       	ldi	r19, 0x00	; 0
      b2:	40 e0       	ldi	r20, 0x00	; 0
      b4:	5f e4       	ldi	r21, 0x4F	; 79
      b6:	0e 94 bf 01 	call	0x37e	; 0x37e <__subsf3>
      ba:	0e 94 a7 03 	call	0x74e	; 0x74e <__fixsfsi>
      be:	9b 01       	movw	r18, r22
      c0:	ac 01       	movw	r20, r24
      c2:	20 50       	subi	r18, 0x00	; 0
      c4:	30 40       	sbci	r19, 0x00	; 0
      c6:	40 40       	sbci	r20, 0x00	; 0
      c8:	50 48       	sbci	r21, 0x80	; 128
      ca:	06 c0       	rjmp	.+12     	; 0xd8 <__fixunssfsi+0x4a>
      cc:	c8 01       	movw	r24, r16
      ce:	b7 01       	movw	r22, r14
      d0:	0e 94 a7 03 	call	0x74e	; 0x74e <__fixsfsi>
      d4:	9b 01       	movw	r18, r22
      d6:	ac 01       	movw	r20, r24
      d8:	b9 01       	movw	r22, r18
      da:	ca 01       	movw	r24, r20
      dc:	1f 91       	pop	r17
      de:	0f 91       	pop	r16
      e0:	ff 90       	pop	r15
      e2:	ef 90       	pop	r14
      e4:	08 95       	ret

000000e6 <_fpadd_parts>:
      e6:	a0 e0       	ldi	r26, 0x00	; 0
      e8:	b0 e0       	ldi	r27, 0x00	; 0
      ea:	e9 e7       	ldi	r30, 0x79	; 121
      ec:	f0 e0       	ldi	r31, 0x00	; 0
      ee:	0c 94 ab 3b 	jmp	0x7756	; 0x7756 <__prologue_saves__>
      f2:	dc 01       	movw	r26, r24
      f4:	2b 01       	movw	r4, r22
      f6:	fa 01       	movw	r30, r20
      f8:	9c 91       	ld	r25, X
      fa:	92 30       	cpi	r25, 0x02	; 2
      fc:	08 f4       	brcc	.+2      	; 0x100 <_fpadd_parts+0x1a>
      fe:	39 c1       	rjmp	.+626    	; 0x372 <_fpadd_parts+0x28c>
     100:	eb 01       	movw	r28, r22
     102:	88 81       	ld	r24, Y
     104:	82 30       	cpi	r24, 0x02	; 2
     106:	08 f4       	brcc	.+2      	; 0x10a <_fpadd_parts+0x24>
     108:	33 c1       	rjmp	.+614    	; 0x370 <_fpadd_parts+0x28a>
     10a:	94 30       	cpi	r25, 0x04	; 4
     10c:	69 f4       	brne	.+26     	; 0x128 <_fpadd_parts+0x42>
     10e:	84 30       	cpi	r24, 0x04	; 4
     110:	09 f0       	breq	.+2      	; 0x114 <_fpadd_parts+0x2e>
     112:	2f c1       	rjmp	.+606    	; 0x372 <_fpadd_parts+0x28c>
     114:	11 96       	adiw	r26, 0x01	; 1
     116:	9c 91       	ld	r25, X
     118:	11 97       	sbiw	r26, 0x01	; 1
     11a:	89 81       	ldd	r24, Y+1	; 0x01
     11c:	98 17       	cp	r25, r24
     11e:	09 f4       	brne	.+2      	; 0x122 <_fpadd_parts+0x3c>
     120:	28 c1       	rjmp	.+592    	; 0x372 <_fpadd_parts+0x28c>
     122:	a0 e8       	ldi	r26, 0x80	; 128
     124:	b0 e0       	ldi	r27, 0x00	; 0
     126:	25 c1       	rjmp	.+586    	; 0x372 <_fpadd_parts+0x28c>
     128:	84 30       	cpi	r24, 0x04	; 4
     12a:	09 f4       	brne	.+2      	; 0x12e <_fpadd_parts+0x48>
     12c:	21 c1       	rjmp	.+578    	; 0x370 <_fpadd_parts+0x28a>
     12e:	82 30       	cpi	r24, 0x02	; 2
     130:	a9 f4       	brne	.+42     	; 0x15c <_fpadd_parts+0x76>
     132:	92 30       	cpi	r25, 0x02	; 2
     134:	09 f0       	breq	.+2      	; 0x138 <_fpadd_parts+0x52>
     136:	1d c1       	rjmp	.+570    	; 0x372 <_fpadd_parts+0x28c>
     138:	9a 01       	movw	r18, r20
     13a:	ad 01       	movw	r20, r26
     13c:	88 e0       	ldi	r24, 0x08	; 8
     13e:	ea 01       	movw	r28, r20
     140:	09 90       	ld	r0, Y+
     142:	ae 01       	movw	r20, r28
     144:	e9 01       	movw	r28, r18
     146:	09 92       	st	Y+, r0
     148:	9e 01       	movw	r18, r28
     14a:	81 50       	subi	r24, 0x01	; 1
     14c:	c1 f7       	brne	.-16     	; 0x13e <_fpadd_parts+0x58>
     14e:	e2 01       	movw	r28, r4
     150:	89 81       	ldd	r24, Y+1	; 0x01
     152:	11 96       	adiw	r26, 0x01	; 1
     154:	9c 91       	ld	r25, X
     156:	89 23       	and	r24, r25
     158:	81 83       	std	Z+1, r24	; 0x01
     15a:	08 c1       	rjmp	.+528    	; 0x36c <_fpadd_parts+0x286>
     15c:	92 30       	cpi	r25, 0x02	; 2
     15e:	09 f4       	brne	.+2      	; 0x162 <_fpadd_parts+0x7c>
     160:	07 c1       	rjmp	.+526    	; 0x370 <_fpadd_parts+0x28a>
     162:	12 96       	adiw	r26, 0x02	; 2
     164:	2d 90       	ld	r2, X+
     166:	3c 90       	ld	r3, X
     168:	13 97       	sbiw	r26, 0x03	; 3
     16a:	eb 01       	movw	r28, r22
     16c:	8a 81       	ldd	r24, Y+2	; 0x02
     16e:	9b 81       	ldd	r25, Y+3	; 0x03
     170:	14 96       	adiw	r26, 0x04	; 4
     172:	ad 90       	ld	r10, X+
     174:	bd 90       	ld	r11, X+
     176:	cd 90       	ld	r12, X+
     178:	dc 90       	ld	r13, X
     17a:	17 97       	sbiw	r26, 0x07	; 7
     17c:	ec 80       	ldd	r14, Y+4	; 0x04
     17e:	fd 80       	ldd	r15, Y+5	; 0x05
     180:	0e 81       	ldd	r16, Y+6	; 0x06
     182:	1f 81       	ldd	r17, Y+7	; 0x07
     184:	91 01       	movw	r18, r2
     186:	28 1b       	sub	r18, r24
     188:	39 0b       	sbc	r19, r25
     18a:	b9 01       	movw	r22, r18
     18c:	37 ff       	sbrs	r19, 7
     18e:	04 c0       	rjmp	.+8      	; 0x198 <_fpadd_parts+0xb2>
     190:	66 27       	eor	r22, r22
     192:	77 27       	eor	r23, r23
     194:	62 1b       	sub	r22, r18
     196:	73 0b       	sbc	r23, r19
     198:	60 32       	cpi	r22, 0x20	; 32
     19a:	71 05       	cpc	r23, r1
     19c:	0c f0       	brlt	.+2      	; 0x1a0 <_fpadd_parts+0xba>
     19e:	61 c0       	rjmp	.+194    	; 0x262 <_fpadd_parts+0x17c>
     1a0:	12 16       	cp	r1, r18
     1a2:	13 06       	cpc	r1, r19
     1a4:	6c f5       	brge	.+90     	; 0x200 <_fpadd_parts+0x11a>
     1a6:	37 01       	movw	r6, r14
     1a8:	48 01       	movw	r8, r16
     1aa:	06 2e       	mov	r0, r22
     1ac:	04 c0       	rjmp	.+8      	; 0x1b6 <_fpadd_parts+0xd0>
     1ae:	96 94       	lsr	r9
     1b0:	87 94       	ror	r8
     1b2:	77 94       	ror	r7
     1b4:	67 94       	ror	r6
     1b6:	0a 94       	dec	r0
     1b8:	d2 f7       	brpl	.-12     	; 0x1ae <_fpadd_parts+0xc8>
     1ba:	21 e0       	ldi	r18, 0x01	; 1
     1bc:	30 e0       	ldi	r19, 0x00	; 0
     1be:	40 e0       	ldi	r20, 0x00	; 0
     1c0:	50 e0       	ldi	r21, 0x00	; 0
     1c2:	04 c0       	rjmp	.+8      	; 0x1cc <_fpadd_parts+0xe6>
     1c4:	22 0f       	add	r18, r18
     1c6:	33 1f       	adc	r19, r19
     1c8:	44 1f       	adc	r20, r20
     1ca:	55 1f       	adc	r21, r21
     1cc:	6a 95       	dec	r22
     1ce:	d2 f7       	brpl	.-12     	; 0x1c4 <_fpadd_parts+0xde>
     1d0:	21 50       	subi	r18, 0x01	; 1
     1d2:	30 40       	sbci	r19, 0x00	; 0
     1d4:	40 40       	sbci	r20, 0x00	; 0
     1d6:	50 40       	sbci	r21, 0x00	; 0
     1d8:	2e 21       	and	r18, r14
     1da:	3f 21       	and	r19, r15
     1dc:	40 23       	and	r20, r16
     1de:	51 23       	and	r21, r17
     1e0:	21 15       	cp	r18, r1
     1e2:	31 05       	cpc	r19, r1
     1e4:	41 05       	cpc	r20, r1
     1e6:	51 05       	cpc	r21, r1
     1e8:	21 f0       	breq	.+8      	; 0x1f2 <_fpadd_parts+0x10c>
     1ea:	21 e0       	ldi	r18, 0x01	; 1
     1ec:	30 e0       	ldi	r19, 0x00	; 0
     1ee:	40 e0       	ldi	r20, 0x00	; 0
     1f0:	50 e0       	ldi	r21, 0x00	; 0
     1f2:	79 01       	movw	r14, r18
     1f4:	8a 01       	movw	r16, r20
     1f6:	e6 28       	or	r14, r6
     1f8:	f7 28       	or	r15, r7
     1fa:	08 29       	or	r16, r8
     1fc:	19 29       	or	r17, r9
     1fe:	3c c0       	rjmp	.+120    	; 0x278 <_fpadd_parts+0x192>
     200:	23 2b       	or	r18, r19
     202:	d1 f1       	breq	.+116    	; 0x278 <_fpadd_parts+0x192>
     204:	26 0e       	add	r2, r22
     206:	37 1e       	adc	r3, r23
     208:	35 01       	movw	r6, r10
     20a:	46 01       	movw	r8, r12
     20c:	06 2e       	mov	r0, r22
     20e:	04 c0       	rjmp	.+8      	; 0x218 <_fpadd_parts+0x132>
     210:	96 94       	lsr	r9
     212:	87 94       	ror	r8
     214:	77 94       	ror	r7
     216:	67 94       	ror	r6
     218:	0a 94       	dec	r0
     21a:	d2 f7       	brpl	.-12     	; 0x210 <_fpadd_parts+0x12a>
     21c:	21 e0       	ldi	r18, 0x01	; 1
     21e:	30 e0       	ldi	r19, 0x00	; 0
     220:	40 e0       	ldi	r20, 0x00	; 0
     222:	50 e0       	ldi	r21, 0x00	; 0
     224:	04 c0       	rjmp	.+8      	; 0x22e <_fpadd_parts+0x148>
     226:	22 0f       	add	r18, r18
     228:	33 1f       	adc	r19, r19
     22a:	44 1f       	adc	r20, r20
     22c:	55 1f       	adc	r21, r21
     22e:	6a 95       	dec	r22
     230:	d2 f7       	brpl	.-12     	; 0x226 <_fpadd_parts+0x140>
     232:	21 50       	subi	r18, 0x01	; 1
     234:	30 40       	sbci	r19, 0x00	; 0
     236:	40 40       	sbci	r20, 0x00	; 0
     238:	50 40       	sbci	r21, 0x00	; 0
     23a:	2a 21       	and	r18, r10
     23c:	3b 21       	and	r19, r11
     23e:	4c 21       	and	r20, r12
     240:	5d 21       	and	r21, r13
     242:	21 15       	cp	r18, r1
     244:	31 05       	cpc	r19, r1
     246:	41 05       	cpc	r20, r1
     248:	51 05       	cpc	r21, r1
     24a:	21 f0       	breq	.+8      	; 0x254 <_fpadd_parts+0x16e>
     24c:	21 e0       	ldi	r18, 0x01	; 1
     24e:	30 e0       	ldi	r19, 0x00	; 0
     250:	40 e0       	ldi	r20, 0x00	; 0
     252:	50 e0       	ldi	r21, 0x00	; 0
     254:	59 01       	movw	r10, r18
     256:	6a 01       	movw	r12, r20
     258:	a6 28       	or	r10, r6
     25a:	b7 28       	or	r11, r7
     25c:	c8 28       	or	r12, r8
     25e:	d9 28       	or	r13, r9
     260:	0b c0       	rjmp	.+22     	; 0x278 <_fpadd_parts+0x192>
     262:	82 15       	cp	r24, r2
     264:	93 05       	cpc	r25, r3
     266:	2c f0       	brlt	.+10     	; 0x272 <_fpadd_parts+0x18c>
     268:	1c 01       	movw	r2, r24
     26a:	aa 24       	eor	r10, r10
     26c:	bb 24       	eor	r11, r11
     26e:	65 01       	movw	r12, r10
     270:	03 c0       	rjmp	.+6      	; 0x278 <_fpadd_parts+0x192>
     272:	ee 24       	eor	r14, r14
     274:	ff 24       	eor	r15, r15
     276:	87 01       	movw	r16, r14
     278:	11 96       	adiw	r26, 0x01	; 1
     27a:	9c 91       	ld	r25, X
     27c:	d2 01       	movw	r26, r4
     27e:	11 96       	adiw	r26, 0x01	; 1
     280:	8c 91       	ld	r24, X
     282:	98 17       	cp	r25, r24
     284:	09 f4       	brne	.+2      	; 0x288 <_fpadd_parts+0x1a2>
     286:	45 c0       	rjmp	.+138    	; 0x312 <_fpadd_parts+0x22c>
     288:	99 23       	and	r25, r25
     28a:	39 f0       	breq	.+14     	; 0x29a <_fpadd_parts+0x1b4>
     28c:	a8 01       	movw	r20, r16
     28e:	97 01       	movw	r18, r14
     290:	2a 19       	sub	r18, r10
     292:	3b 09       	sbc	r19, r11
     294:	4c 09       	sbc	r20, r12
     296:	5d 09       	sbc	r21, r13
     298:	06 c0       	rjmp	.+12     	; 0x2a6 <_fpadd_parts+0x1c0>
     29a:	a6 01       	movw	r20, r12
     29c:	95 01       	movw	r18, r10
     29e:	2e 19       	sub	r18, r14
     2a0:	3f 09       	sbc	r19, r15
     2a2:	40 0b       	sbc	r20, r16
     2a4:	51 0b       	sbc	r21, r17
     2a6:	57 fd       	sbrc	r21, 7
     2a8:	08 c0       	rjmp	.+16     	; 0x2ba <_fpadd_parts+0x1d4>
     2aa:	11 82       	std	Z+1, r1	; 0x01
     2ac:	33 82       	std	Z+3, r3	; 0x03
     2ae:	22 82       	std	Z+2, r2	; 0x02
     2b0:	24 83       	std	Z+4, r18	; 0x04
     2b2:	35 83       	std	Z+5, r19	; 0x05
     2b4:	46 83       	std	Z+6, r20	; 0x06
     2b6:	57 83       	std	Z+7, r21	; 0x07
     2b8:	1d c0       	rjmp	.+58     	; 0x2f4 <_fpadd_parts+0x20e>
     2ba:	81 e0       	ldi	r24, 0x01	; 1
     2bc:	81 83       	std	Z+1, r24	; 0x01
     2be:	33 82       	std	Z+3, r3	; 0x03
     2c0:	22 82       	std	Z+2, r2	; 0x02
     2c2:	88 27       	eor	r24, r24
     2c4:	99 27       	eor	r25, r25
     2c6:	dc 01       	movw	r26, r24
     2c8:	82 1b       	sub	r24, r18
     2ca:	93 0b       	sbc	r25, r19
     2cc:	a4 0b       	sbc	r26, r20
     2ce:	b5 0b       	sbc	r27, r21
     2d0:	84 83       	std	Z+4, r24	; 0x04
     2d2:	95 83       	std	Z+5, r25	; 0x05
     2d4:	a6 83       	std	Z+6, r26	; 0x06
     2d6:	b7 83       	std	Z+7, r27	; 0x07
     2d8:	0d c0       	rjmp	.+26     	; 0x2f4 <_fpadd_parts+0x20e>
     2da:	22 0f       	add	r18, r18
     2dc:	33 1f       	adc	r19, r19
     2de:	44 1f       	adc	r20, r20
     2e0:	55 1f       	adc	r21, r21
     2e2:	24 83       	std	Z+4, r18	; 0x04
     2e4:	35 83       	std	Z+5, r19	; 0x05
     2e6:	46 83       	std	Z+6, r20	; 0x06
     2e8:	57 83       	std	Z+7, r21	; 0x07
     2ea:	82 81       	ldd	r24, Z+2	; 0x02
     2ec:	93 81       	ldd	r25, Z+3	; 0x03
     2ee:	01 97       	sbiw	r24, 0x01	; 1
     2f0:	93 83       	std	Z+3, r25	; 0x03
     2f2:	82 83       	std	Z+2, r24	; 0x02
     2f4:	24 81       	ldd	r18, Z+4	; 0x04
     2f6:	35 81       	ldd	r19, Z+5	; 0x05
     2f8:	46 81       	ldd	r20, Z+6	; 0x06
     2fa:	57 81       	ldd	r21, Z+7	; 0x07
     2fc:	da 01       	movw	r26, r20
     2fe:	c9 01       	movw	r24, r18
     300:	01 97       	sbiw	r24, 0x01	; 1
     302:	a1 09       	sbc	r26, r1
     304:	b1 09       	sbc	r27, r1
     306:	8f 5f       	subi	r24, 0xFF	; 255
     308:	9f 4f       	sbci	r25, 0xFF	; 255
     30a:	af 4f       	sbci	r26, 0xFF	; 255
     30c:	bf 43       	sbci	r27, 0x3F	; 63
     30e:	28 f3       	brcs	.-54     	; 0x2da <_fpadd_parts+0x1f4>
     310:	0b c0       	rjmp	.+22     	; 0x328 <_fpadd_parts+0x242>
     312:	91 83       	std	Z+1, r25	; 0x01
     314:	33 82       	std	Z+3, r3	; 0x03
     316:	22 82       	std	Z+2, r2	; 0x02
     318:	ea 0c       	add	r14, r10
     31a:	fb 1c       	adc	r15, r11
     31c:	0c 1d       	adc	r16, r12
     31e:	1d 1d       	adc	r17, r13
     320:	e4 82       	std	Z+4, r14	; 0x04
     322:	f5 82       	std	Z+5, r15	; 0x05
     324:	06 83       	std	Z+6, r16	; 0x06
     326:	17 83       	std	Z+7, r17	; 0x07
     328:	83 e0       	ldi	r24, 0x03	; 3
     32a:	80 83       	st	Z, r24
     32c:	24 81       	ldd	r18, Z+4	; 0x04
     32e:	35 81       	ldd	r19, Z+5	; 0x05
     330:	46 81       	ldd	r20, Z+6	; 0x06
     332:	57 81       	ldd	r21, Z+7	; 0x07
     334:	57 ff       	sbrs	r21, 7
     336:	1a c0       	rjmp	.+52     	; 0x36c <_fpadd_parts+0x286>
     338:	c9 01       	movw	r24, r18
     33a:	aa 27       	eor	r26, r26
     33c:	97 fd       	sbrc	r25, 7
     33e:	a0 95       	com	r26
     340:	ba 2f       	mov	r27, r26
     342:	81 70       	andi	r24, 0x01	; 1
     344:	90 70       	andi	r25, 0x00	; 0
     346:	a0 70       	andi	r26, 0x00	; 0
     348:	b0 70       	andi	r27, 0x00	; 0
     34a:	56 95       	lsr	r21
     34c:	47 95       	ror	r20
     34e:	37 95       	ror	r19
     350:	27 95       	ror	r18
     352:	82 2b       	or	r24, r18
     354:	93 2b       	or	r25, r19
     356:	a4 2b       	or	r26, r20
     358:	b5 2b       	or	r27, r21
     35a:	84 83       	std	Z+4, r24	; 0x04
     35c:	95 83       	std	Z+5, r25	; 0x05
     35e:	a6 83       	std	Z+6, r26	; 0x06
     360:	b7 83       	std	Z+7, r27	; 0x07
     362:	82 81       	ldd	r24, Z+2	; 0x02
     364:	93 81       	ldd	r25, Z+3	; 0x03
     366:	01 96       	adiw	r24, 0x01	; 1
     368:	93 83       	std	Z+3, r25	; 0x03
     36a:	82 83       	std	Z+2, r24	; 0x02
     36c:	df 01       	movw	r26, r30
     36e:	01 c0       	rjmp	.+2      	; 0x372 <_fpadd_parts+0x28c>
     370:	d2 01       	movw	r26, r4
     372:	cd 01       	movw	r24, r26
     374:	cd b7       	in	r28, 0x3d	; 61
     376:	de b7       	in	r29, 0x3e	; 62
     378:	e2 e1       	ldi	r30, 0x12	; 18
     37a:	0c 94 c7 3b 	jmp	0x778e	; 0x778e <__epilogue_restores__>

0000037e <__subsf3>:
     37e:	a0 e2       	ldi	r26, 0x20	; 32
     380:	b0 e0       	ldi	r27, 0x00	; 0
     382:	e5 ec       	ldi	r30, 0xC5	; 197
     384:	f1 e0       	ldi	r31, 0x01	; 1
     386:	0c 94 b7 3b 	jmp	0x776e	; 0x776e <__prologue_saves__+0x18>
     38a:	69 83       	std	Y+1, r22	; 0x01
     38c:	7a 83       	std	Y+2, r23	; 0x02
     38e:	8b 83       	std	Y+3, r24	; 0x03
     390:	9c 83       	std	Y+4, r25	; 0x04
     392:	2d 83       	std	Y+5, r18	; 0x05
     394:	3e 83       	std	Y+6, r19	; 0x06
     396:	4f 83       	std	Y+7, r20	; 0x07
     398:	58 87       	std	Y+8, r21	; 0x08
     39a:	e9 e0       	ldi	r30, 0x09	; 9
     39c:	ee 2e       	mov	r14, r30
     39e:	f1 2c       	mov	r15, r1
     3a0:	ec 0e       	add	r14, r28
     3a2:	fd 1e       	adc	r15, r29
     3a4:	ce 01       	movw	r24, r28
     3a6:	01 96       	adiw	r24, 0x01	; 1
     3a8:	b7 01       	movw	r22, r14
     3aa:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__unpack_f>
     3ae:	8e 01       	movw	r16, r28
     3b0:	0f 5e       	subi	r16, 0xEF	; 239
     3b2:	1f 4f       	sbci	r17, 0xFF	; 255
     3b4:	ce 01       	movw	r24, r28
     3b6:	05 96       	adiw	r24, 0x05	; 5
     3b8:	b8 01       	movw	r22, r16
     3ba:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__unpack_f>
     3be:	8a 89       	ldd	r24, Y+18	; 0x12
     3c0:	91 e0       	ldi	r25, 0x01	; 1
     3c2:	89 27       	eor	r24, r25
     3c4:	8a 8b       	std	Y+18, r24	; 0x12
     3c6:	c7 01       	movw	r24, r14
     3c8:	b8 01       	movw	r22, r16
     3ca:	ae 01       	movw	r20, r28
     3cc:	47 5e       	subi	r20, 0xE7	; 231
     3ce:	5f 4f       	sbci	r21, 0xFF	; 255
     3d0:	0e 94 73 00 	call	0xe6	; 0xe6 <_fpadd_parts>
     3d4:	0e 94 fb 03 	call	0x7f6	; 0x7f6 <__pack_f>
     3d8:	a0 96       	adiw	r28, 0x20	; 32
     3da:	e6 e0       	ldi	r30, 0x06	; 6
     3dc:	0c 94 d3 3b 	jmp	0x77a6	; 0x77a6 <__epilogue_restores__+0x18>

000003e0 <__addsf3>:
     3e0:	a0 e2       	ldi	r26, 0x20	; 32
     3e2:	b0 e0       	ldi	r27, 0x00	; 0
     3e4:	e6 ef       	ldi	r30, 0xF6	; 246
     3e6:	f1 e0       	ldi	r31, 0x01	; 1
     3e8:	0c 94 b7 3b 	jmp	0x776e	; 0x776e <__prologue_saves__+0x18>
     3ec:	69 83       	std	Y+1, r22	; 0x01
     3ee:	7a 83       	std	Y+2, r23	; 0x02
     3f0:	8b 83       	std	Y+3, r24	; 0x03
     3f2:	9c 83       	std	Y+4, r25	; 0x04
     3f4:	2d 83       	std	Y+5, r18	; 0x05
     3f6:	3e 83       	std	Y+6, r19	; 0x06
     3f8:	4f 83       	std	Y+7, r20	; 0x07
     3fa:	58 87       	std	Y+8, r21	; 0x08
     3fc:	f9 e0       	ldi	r31, 0x09	; 9
     3fe:	ef 2e       	mov	r14, r31
     400:	f1 2c       	mov	r15, r1
     402:	ec 0e       	add	r14, r28
     404:	fd 1e       	adc	r15, r29
     406:	ce 01       	movw	r24, r28
     408:	01 96       	adiw	r24, 0x01	; 1
     40a:	b7 01       	movw	r22, r14
     40c:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__unpack_f>
     410:	8e 01       	movw	r16, r28
     412:	0f 5e       	subi	r16, 0xEF	; 239
     414:	1f 4f       	sbci	r17, 0xFF	; 255
     416:	ce 01       	movw	r24, r28
     418:	05 96       	adiw	r24, 0x05	; 5
     41a:	b8 01       	movw	r22, r16
     41c:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__unpack_f>
     420:	c7 01       	movw	r24, r14
     422:	b8 01       	movw	r22, r16
     424:	ae 01       	movw	r20, r28
     426:	47 5e       	subi	r20, 0xE7	; 231
     428:	5f 4f       	sbci	r21, 0xFF	; 255
     42a:	0e 94 73 00 	call	0xe6	; 0xe6 <_fpadd_parts>
     42e:	0e 94 fb 03 	call	0x7f6	; 0x7f6 <__pack_f>
     432:	a0 96       	adiw	r28, 0x20	; 32
     434:	e6 e0       	ldi	r30, 0x06	; 6
     436:	0c 94 d3 3b 	jmp	0x77a6	; 0x77a6 <__epilogue_restores__+0x18>

0000043a <__mulsf3>:
     43a:	a0 e2       	ldi	r26, 0x20	; 32
     43c:	b0 e0       	ldi	r27, 0x00	; 0
     43e:	e3 e2       	ldi	r30, 0x23	; 35
     440:	f2 e0       	ldi	r31, 0x02	; 2
     442:	0c 94 ab 3b 	jmp	0x7756	; 0x7756 <__prologue_saves__>
     446:	69 83       	std	Y+1, r22	; 0x01
     448:	7a 83       	std	Y+2, r23	; 0x02
     44a:	8b 83       	std	Y+3, r24	; 0x03
     44c:	9c 83       	std	Y+4, r25	; 0x04
     44e:	2d 83       	std	Y+5, r18	; 0x05
     450:	3e 83       	std	Y+6, r19	; 0x06
     452:	4f 83       	std	Y+7, r20	; 0x07
     454:	58 87       	std	Y+8, r21	; 0x08
     456:	ce 01       	movw	r24, r28
     458:	01 96       	adiw	r24, 0x01	; 1
     45a:	be 01       	movw	r22, r28
     45c:	67 5f       	subi	r22, 0xF7	; 247
     45e:	7f 4f       	sbci	r23, 0xFF	; 255
     460:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__unpack_f>
     464:	ce 01       	movw	r24, r28
     466:	05 96       	adiw	r24, 0x05	; 5
     468:	be 01       	movw	r22, r28
     46a:	6f 5e       	subi	r22, 0xEF	; 239
     46c:	7f 4f       	sbci	r23, 0xFF	; 255
     46e:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__unpack_f>
     472:	99 85       	ldd	r25, Y+9	; 0x09
     474:	92 30       	cpi	r25, 0x02	; 2
     476:	88 f0       	brcs	.+34     	; 0x49a <__mulsf3+0x60>
     478:	89 89       	ldd	r24, Y+17	; 0x11
     47a:	82 30       	cpi	r24, 0x02	; 2
     47c:	c8 f0       	brcs	.+50     	; 0x4b0 <__mulsf3+0x76>
     47e:	94 30       	cpi	r25, 0x04	; 4
     480:	19 f4       	brne	.+6      	; 0x488 <__mulsf3+0x4e>
     482:	82 30       	cpi	r24, 0x02	; 2
     484:	51 f4       	brne	.+20     	; 0x49a <__mulsf3+0x60>
     486:	04 c0       	rjmp	.+8      	; 0x490 <__mulsf3+0x56>
     488:	84 30       	cpi	r24, 0x04	; 4
     48a:	29 f4       	brne	.+10     	; 0x496 <__mulsf3+0x5c>
     48c:	92 30       	cpi	r25, 0x02	; 2
     48e:	81 f4       	brne	.+32     	; 0x4b0 <__mulsf3+0x76>
     490:	80 e8       	ldi	r24, 0x80	; 128
     492:	90 e0       	ldi	r25, 0x00	; 0
     494:	c6 c0       	rjmp	.+396    	; 0x622 <__mulsf3+0x1e8>
     496:	92 30       	cpi	r25, 0x02	; 2
     498:	49 f4       	brne	.+18     	; 0x4ac <__mulsf3+0x72>
     49a:	20 e0       	ldi	r18, 0x00	; 0
     49c:	9a 85       	ldd	r25, Y+10	; 0x0a
     49e:	8a 89       	ldd	r24, Y+18	; 0x12
     4a0:	98 13       	cpse	r25, r24
     4a2:	21 e0       	ldi	r18, 0x01	; 1
     4a4:	2a 87       	std	Y+10, r18	; 0x0a
     4a6:	ce 01       	movw	r24, r28
     4a8:	09 96       	adiw	r24, 0x09	; 9
     4aa:	bb c0       	rjmp	.+374    	; 0x622 <__mulsf3+0x1e8>
     4ac:	82 30       	cpi	r24, 0x02	; 2
     4ae:	49 f4       	brne	.+18     	; 0x4c2 <__mulsf3+0x88>
     4b0:	20 e0       	ldi	r18, 0x00	; 0
     4b2:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b4:	8a 89       	ldd	r24, Y+18	; 0x12
     4b6:	98 13       	cpse	r25, r24
     4b8:	21 e0       	ldi	r18, 0x01	; 1
     4ba:	2a 8b       	std	Y+18, r18	; 0x12
     4bc:	ce 01       	movw	r24, r28
     4be:	41 96       	adiw	r24, 0x11	; 17
     4c0:	b0 c0       	rjmp	.+352    	; 0x622 <__mulsf3+0x1e8>
     4c2:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c4:	3e 84       	ldd	r3, Y+14	; 0x0e
     4c6:	4f 84       	ldd	r4, Y+15	; 0x0f
     4c8:	58 88       	ldd	r5, Y+16	; 0x10
     4ca:	6d 88       	ldd	r6, Y+21	; 0x15
     4cc:	7e 88       	ldd	r7, Y+22	; 0x16
     4ce:	8f 88       	ldd	r8, Y+23	; 0x17
     4d0:	98 8c       	ldd	r9, Y+24	; 0x18
     4d2:	ee 24       	eor	r14, r14
     4d4:	ff 24       	eor	r15, r15
     4d6:	87 01       	movw	r16, r14
     4d8:	aa 24       	eor	r10, r10
     4da:	bb 24       	eor	r11, r11
     4dc:	65 01       	movw	r12, r10
     4de:	40 e0       	ldi	r20, 0x00	; 0
     4e0:	50 e0       	ldi	r21, 0x00	; 0
     4e2:	60 e0       	ldi	r22, 0x00	; 0
     4e4:	70 e0       	ldi	r23, 0x00	; 0
     4e6:	e0 e0       	ldi	r30, 0x00	; 0
     4e8:	f0 e0       	ldi	r31, 0x00	; 0
     4ea:	c1 01       	movw	r24, r2
     4ec:	81 70       	andi	r24, 0x01	; 1
     4ee:	90 70       	andi	r25, 0x00	; 0
     4f0:	89 2b       	or	r24, r25
     4f2:	e9 f0       	breq	.+58     	; 0x52e <__mulsf3+0xf4>
     4f4:	e6 0c       	add	r14, r6
     4f6:	f7 1c       	adc	r15, r7
     4f8:	08 1d       	adc	r16, r8
     4fa:	19 1d       	adc	r17, r9
     4fc:	9a 01       	movw	r18, r20
     4fe:	ab 01       	movw	r20, r22
     500:	2a 0d       	add	r18, r10
     502:	3b 1d       	adc	r19, r11
     504:	4c 1d       	adc	r20, r12
     506:	5d 1d       	adc	r21, r13
     508:	80 e0       	ldi	r24, 0x00	; 0
     50a:	90 e0       	ldi	r25, 0x00	; 0
     50c:	a0 e0       	ldi	r26, 0x00	; 0
     50e:	b0 e0       	ldi	r27, 0x00	; 0
     510:	e6 14       	cp	r14, r6
     512:	f7 04       	cpc	r15, r7
     514:	08 05       	cpc	r16, r8
     516:	19 05       	cpc	r17, r9
     518:	20 f4       	brcc	.+8      	; 0x522 <__mulsf3+0xe8>
     51a:	81 e0       	ldi	r24, 0x01	; 1
     51c:	90 e0       	ldi	r25, 0x00	; 0
     51e:	a0 e0       	ldi	r26, 0x00	; 0
     520:	b0 e0       	ldi	r27, 0x00	; 0
     522:	ba 01       	movw	r22, r20
     524:	a9 01       	movw	r20, r18
     526:	48 0f       	add	r20, r24
     528:	59 1f       	adc	r21, r25
     52a:	6a 1f       	adc	r22, r26
     52c:	7b 1f       	adc	r23, r27
     52e:	aa 0c       	add	r10, r10
     530:	bb 1c       	adc	r11, r11
     532:	cc 1c       	adc	r12, r12
     534:	dd 1c       	adc	r13, r13
     536:	97 fe       	sbrs	r9, 7
     538:	08 c0       	rjmp	.+16     	; 0x54a <__mulsf3+0x110>
     53a:	81 e0       	ldi	r24, 0x01	; 1
     53c:	90 e0       	ldi	r25, 0x00	; 0
     53e:	a0 e0       	ldi	r26, 0x00	; 0
     540:	b0 e0       	ldi	r27, 0x00	; 0
     542:	a8 2a       	or	r10, r24
     544:	b9 2a       	or	r11, r25
     546:	ca 2a       	or	r12, r26
     548:	db 2a       	or	r13, r27
     54a:	31 96       	adiw	r30, 0x01	; 1
     54c:	e0 32       	cpi	r30, 0x20	; 32
     54e:	f1 05       	cpc	r31, r1
     550:	49 f0       	breq	.+18     	; 0x564 <__mulsf3+0x12a>
     552:	66 0c       	add	r6, r6
     554:	77 1c       	adc	r7, r7
     556:	88 1c       	adc	r8, r8
     558:	99 1c       	adc	r9, r9
     55a:	56 94       	lsr	r5
     55c:	47 94       	ror	r4
     55e:	37 94       	ror	r3
     560:	27 94       	ror	r2
     562:	c3 cf       	rjmp	.-122    	; 0x4ea <__mulsf3+0xb0>
     564:	fa 85       	ldd	r31, Y+10	; 0x0a
     566:	ea 89       	ldd	r30, Y+18	; 0x12
     568:	2b 89       	ldd	r18, Y+19	; 0x13
     56a:	3c 89       	ldd	r19, Y+20	; 0x14
     56c:	8b 85       	ldd	r24, Y+11	; 0x0b
     56e:	9c 85       	ldd	r25, Y+12	; 0x0c
     570:	28 0f       	add	r18, r24
     572:	39 1f       	adc	r19, r25
     574:	2e 5f       	subi	r18, 0xFE	; 254
     576:	3f 4f       	sbci	r19, 0xFF	; 255
     578:	17 c0       	rjmp	.+46     	; 0x5a8 <__mulsf3+0x16e>
     57a:	ca 01       	movw	r24, r20
     57c:	81 70       	andi	r24, 0x01	; 1
     57e:	90 70       	andi	r25, 0x00	; 0
     580:	89 2b       	or	r24, r25
     582:	61 f0       	breq	.+24     	; 0x59c <__mulsf3+0x162>
     584:	16 95       	lsr	r17
     586:	07 95       	ror	r16
     588:	f7 94       	ror	r15
     58a:	e7 94       	ror	r14
     58c:	80 e0       	ldi	r24, 0x00	; 0
     58e:	90 e0       	ldi	r25, 0x00	; 0
     590:	a0 e0       	ldi	r26, 0x00	; 0
     592:	b0 e8       	ldi	r27, 0x80	; 128
     594:	e8 2a       	or	r14, r24
     596:	f9 2a       	or	r15, r25
     598:	0a 2b       	or	r16, r26
     59a:	1b 2b       	or	r17, r27
     59c:	76 95       	lsr	r23
     59e:	67 95       	ror	r22
     5a0:	57 95       	ror	r21
     5a2:	47 95       	ror	r20
     5a4:	2f 5f       	subi	r18, 0xFF	; 255
     5a6:	3f 4f       	sbci	r19, 0xFF	; 255
     5a8:	77 fd       	sbrc	r23, 7
     5aa:	e7 cf       	rjmp	.-50     	; 0x57a <__mulsf3+0x140>
     5ac:	0c c0       	rjmp	.+24     	; 0x5c6 <__mulsf3+0x18c>
     5ae:	44 0f       	add	r20, r20
     5b0:	55 1f       	adc	r21, r21
     5b2:	66 1f       	adc	r22, r22
     5b4:	77 1f       	adc	r23, r23
     5b6:	17 fd       	sbrc	r17, 7
     5b8:	41 60       	ori	r20, 0x01	; 1
     5ba:	ee 0c       	add	r14, r14
     5bc:	ff 1c       	adc	r15, r15
     5be:	00 1f       	adc	r16, r16
     5c0:	11 1f       	adc	r17, r17
     5c2:	21 50       	subi	r18, 0x01	; 1
     5c4:	30 40       	sbci	r19, 0x00	; 0
     5c6:	40 30       	cpi	r20, 0x00	; 0
     5c8:	90 e0       	ldi	r25, 0x00	; 0
     5ca:	59 07       	cpc	r21, r25
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	69 07       	cpc	r22, r25
     5d0:	90 e4       	ldi	r25, 0x40	; 64
     5d2:	79 07       	cpc	r23, r25
     5d4:	60 f3       	brcs	.-40     	; 0x5ae <__mulsf3+0x174>
     5d6:	2b 8f       	std	Y+27, r18	; 0x1b
     5d8:	3c 8f       	std	Y+28, r19	; 0x1c
     5da:	db 01       	movw	r26, r22
     5dc:	ca 01       	movw	r24, r20
     5de:	8f 77       	andi	r24, 0x7F	; 127
     5e0:	90 70       	andi	r25, 0x00	; 0
     5e2:	a0 70       	andi	r26, 0x00	; 0
     5e4:	b0 70       	andi	r27, 0x00	; 0
     5e6:	80 34       	cpi	r24, 0x40	; 64
     5e8:	91 05       	cpc	r25, r1
     5ea:	a1 05       	cpc	r26, r1
     5ec:	b1 05       	cpc	r27, r1
     5ee:	61 f4       	brne	.+24     	; 0x608 <__mulsf3+0x1ce>
     5f0:	47 fd       	sbrc	r20, 7
     5f2:	0a c0       	rjmp	.+20     	; 0x608 <__mulsf3+0x1ce>
     5f4:	e1 14       	cp	r14, r1
     5f6:	f1 04       	cpc	r15, r1
     5f8:	01 05       	cpc	r16, r1
     5fa:	11 05       	cpc	r17, r1
     5fc:	29 f0       	breq	.+10     	; 0x608 <__mulsf3+0x1ce>
     5fe:	40 5c       	subi	r20, 0xC0	; 192
     600:	5f 4f       	sbci	r21, 0xFF	; 255
     602:	6f 4f       	sbci	r22, 0xFF	; 255
     604:	7f 4f       	sbci	r23, 0xFF	; 255
     606:	40 78       	andi	r20, 0x80	; 128
     608:	1a 8e       	std	Y+26, r1	; 0x1a
     60a:	fe 17       	cp	r31, r30
     60c:	11 f0       	breq	.+4      	; 0x612 <__mulsf3+0x1d8>
     60e:	81 e0       	ldi	r24, 0x01	; 1
     610:	8a 8f       	std	Y+26, r24	; 0x1a
     612:	4d 8f       	std	Y+29, r20	; 0x1d
     614:	5e 8f       	std	Y+30, r21	; 0x1e
     616:	6f 8f       	std	Y+31, r22	; 0x1f
     618:	78 a3       	std	Y+32, r23	; 0x20
     61a:	83 e0       	ldi	r24, 0x03	; 3
     61c:	89 8f       	std	Y+25, r24	; 0x19
     61e:	ce 01       	movw	r24, r28
     620:	49 96       	adiw	r24, 0x19	; 25
     622:	0e 94 fb 03 	call	0x7f6	; 0x7f6 <__pack_f>
     626:	a0 96       	adiw	r28, 0x20	; 32
     628:	e2 e1       	ldi	r30, 0x12	; 18
     62a:	0c 94 c7 3b 	jmp	0x778e	; 0x778e <__epilogue_restores__>

0000062e <__gtsf2>:
     62e:	a8 e1       	ldi	r26, 0x18	; 24
     630:	b0 e0       	ldi	r27, 0x00	; 0
     632:	ed e1       	ldi	r30, 0x1D	; 29
     634:	f3 e0       	ldi	r31, 0x03	; 3
     636:	0c 94 b7 3b 	jmp	0x776e	; 0x776e <__prologue_saves__+0x18>
     63a:	69 83       	std	Y+1, r22	; 0x01
     63c:	7a 83       	std	Y+2, r23	; 0x02
     63e:	8b 83       	std	Y+3, r24	; 0x03
     640:	9c 83       	std	Y+4, r25	; 0x04
     642:	2d 83       	std	Y+5, r18	; 0x05
     644:	3e 83       	std	Y+6, r19	; 0x06
     646:	4f 83       	std	Y+7, r20	; 0x07
     648:	58 87       	std	Y+8, r21	; 0x08
     64a:	89 e0       	ldi	r24, 0x09	; 9
     64c:	e8 2e       	mov	r14, r24
     64e:	f1 2c       	mov	r15, r1
     650:	ec 0e       	add	r14, r28
     652:	fd 1e       	adc	r15, r29
     654:	ce 01       	movw	r24, r28
     656:	01 96       	adiw	r24, 0x01	; 1
     658:	b7 01       	movw	r22, r14
     65a:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__unpack_f>
     65e:	8e 01       	movw	r16, r28
     660:	0f 5e       	subi	r16, 0xEF	; 239
     662:	1f 4f       	sbci	r17, 0xFF	; 255
     664:	ce 01       	movw	r24, r28
     666:	05 96       	adiw	r24, 0x05	; 5
     668:	b8 01       	movw	r22, r16
     66a:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__unpack_f>
     66e:	89 85       	ldd	r24, Y+9	; 0x09
     670:	82 30       	cpi	r24, 0x02	; 2
     672:	40 f0       	brcs	.+16     	; 0x684 <__gtsf2+0x56>
     674:	89 89       	ldd	r24, Y+17	; 0x11
     676:	82 30       	cpi	r24, 0x02	; 2
     678:	28 f0       	brcs	.+10     	; 0x684 <__gtsf2+0x56>
     67a:	c7 01       	movw	r24, r14
     67c:	b8 01       	movw	r22, r16
     67e:	0e 94 48 05 	call	0xa90	; 0xa90 <__fpcmp_parts_f>
     682:	01 c0       	rjmp	.+2      	; 0x686 <__gtsf2+0x58>
     684:	8f ef       	ldi	r24, 0xFF	; 255
     686:	68 96       	adiw	r28, 0x18	; 24
     688:	e6 e0       	ldi	r30, 0x06	; 6
     68a:	0c 94 d3 3b 	jmp	0x77a6	; 0x77a6 <__epilogue_restores__+0x18>

0000068e <__gesf2>:
     68e:	a8 e1       	ldi	r26, 0x18	; 24
     690:	b0 e0       	ldi	r27, 0x00	; 0
     692:	ed e4       	ldi	r30, 0x4D	; 77
     694:	f3 e0       	ldi	r31, 0x03	; 3
     696:	0c 94 b7 3b 	jmp	0x776e	; 0x776e <__prologue_saves__+0x18>
     69a:	69 83       	std	Y+1, r22	; 0x01
     69c:	7a 83       	std	Y+2, r23	; 0x02
     69e:	8b 83       	std	Y+3, r24	; 0x03
     6a0:	9c 83       	std	Y+4, r25	; 0x04
     6a2:	2d 83       	std	Y+5, r18	; 0x05
     6a4:	3e 83       	std	Y+6, r19	; 0x06
     6a6:	4f 83       	std	Y+7, r20	; 0x07
     6a8:	58 87       	std	Y+8, r21	; 0x08
     6aa:	89 e0       	ldi	r24, 0x09	; 9
     6ac:	e8 2e       	mov	r14, r24
     6ae:	f1 2c       	mov	r15, r1
     6b0:	ec 0e       	add	r14, r28
     6b2:	fd 1e       	adc	r15, r29
     6b4:	ce 01       	movw	r24, r28
     6b6:	01 96       	adiw	r24, 0x01	; 1
     6b8:	b7 01       	movw	r22, r14
     6ba:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__unpack_f>
     6be:	8e 01       	movw	r16, r28
     6c0:	0f 5e       	subi	r16, 0xEF	; 239
     6c2:	1f 4f       	sbci	r17, 0xFF	; 255
     6c4:	ce 01       	movw	r24, r28
     6c6:	05 96       	adiw	r24, 0x05	; 5
     6c8:	b8 01       	movw	r22, r16
     6ca:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__unpack_f>
     6ce:	89 85       	ldd	r24, Y+9	; 0x09
     6d0:	82 30       	cpi	r24, 0x02	; 2
     6d2:	40 f0       	brcs	.+16     	; 0x6e4 <__gesf2+0x56>
     6d4:	89 89       	ldd	r24, Y+17	; 0x11
     6d6:	82 30       	cpi	r24, 0x02	; 2
     6d8:	28 f0       	brcs	.+10     	; 0x6e4 <__gesf2+0x56>
     6da:	c7 01       	movw	r24, r14
     6dc:	b8 01       	movw	r22, r16
     6de:	0e 94 48 05 	call	0xa90	; 0xa90 <__fpcmp_parts_f>
     6e2:	01 c0       	rjmp	.+2      	; 0x6e6 <__gesf2+0x58>
     6e4:	8f ef       	ldi	r24, 0xFF	; 255
     6e6:	68 96       	adiw	r28, 0x18	; 24
     6e8:	e6 e0       	ldi	r30, 0x06	; 6
     6ea:	0c 94 d3 3b 	jmp	0x77a6	; 0x77a6 <__epilogue_restores__+0x18>

000006ee <__ltsf2>:
     6ee:	a8 e1       	ldi	r26, 0x18	; 24
     6f0:	b0 e0       	ldi	r27, 0x00	; 0
     6f2:	ed e7       	ldi	r30, 0x7D	; 125
     6f4:	f3 e0       	ldi	r31, 0x03	; 3
     6f6:	0c 94 b7 3b 	jmp	0x776e	; 0x776e <__prologue_saves__+0x18>
     6fa:	69 83       	std	Y+1, r22	; 0x01
     6fc:	7a 83       	std	Y+2, r23	; 0x02
     6fe:	8b 83       	std	Y+3, r24	; 0x03
     700:	9c 83       	std	Y+4, r25	; 0x04
     702:	2d 83       	std	Y+5, r18	; 0x05
     704:	3e 83       	std	Y+6, r19	; 0x06
     706:	4f 83       	std	Y+7, r20	; 0x07
     708:	58 87       	std	Y+8, r21	; 0x08
     70a:	89 e0       	ldi	r24, 0x09	; 9
     70c:	e8 2e       	mov	r14, r24
     70e:	f1 2c       	mov	r15, r1
     710:	ec 0e       	add	r14, r28
     712:	fd 1e       	adc	r15, r29
     714:	ce 01       	movw	r24, r28
     716:	01 96       	adiw	r24, 0x01	; 1
     718:	b7 01       	movw	r22, r14
     71a:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__unpack_f>
     71e:	8e 01       	movw	r16, r28
     720:	0f 5e       	subi	r16, 0xEF	; 239
     722:	1f 4f       	sbci	r17, 0xFF	; 255
     724:	ce 01       	movw	r24, r28
     726:	05 96       	adiw	r24, 0x05	; 5
     728:	b8 01       	movw	r22, r16
     72a:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__unpack_f>
     72e:	89 85       	ldd	r24, Y+9	; 0x09
     730:	82 30       	cpi	r24, 0x02	; 2
     732:	40 f0       	brcs	.+16     	; 0x744 <__ltsf2+0x56>
     734:	89 89       	ldd	r24, Y+17	; 0x11
     736:	82 30       	cpi	r24, 0x02	; 2
     738:	28 f0       	brcs	.+10     	; 0x744 <__ltsf2+0x56>
     73a:	c7 01       	movw	r24, r14
     73c:	b8 01       	movw	r22, r16
     73e:	0e 94 48 05 	call	0xa90	; 0xa90 <__fpcmp_parts_f>
     742:	01 c0       	rjmp	.+2      	; 0x746 <__ltsf2+0x58>
     744:	81 e0       	ldi	r24, 0x01	; 1
     746:	68 96       	adiw	r28, 0x18	; 24
     748:	e6 e0       	ldi	r30, 0x06	; 6
     74a:	0c 94 d3 3b 	jmp	0x77a6	; 0x77a6 <__epilogue_restores__+0x18>

0000074e <__fixsfsi>:
     74e:	ac e0       	ldi	r26, 0x0C	; 12
     750:	b0 e0       	ldi	r27, 0x00	; 0
     752:	ed ea       	ldi	r30, 0xAD	; 173
     754:	f3 e0       	ldi	r31, 0x03	; 3
     756:	0c 94 bb 3b 	jmp	0x7776	; 0x7776 <__prologue_saves__+0x20>
     75a:	69 83       	std	Y+1, r22	; 0x01
     75c:	7a 83       	std	Y+2, r23	; 0x02
     75e:	8b 83       	std	Y+3, r24	; 0x03
     760:	9c 83       	std	Y+4, r25	; 0x04
     762:	ce 01       	movw	r24, r28
     764:	01 96       	adiw	r24, 0x01	; 1
     766:	be 01       	movw	r22, r28
     768:	6b 5f       	subi	r22, 0xFB	; 251
     76a:	7f 4f       	sbci	r23, 0xFF	; 255
     76c:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__unpack_f>
     770:	8d 81       	ldd	r24, Y+5	; 0x05
     772:	82 30       	cpi	r24, 0x02	; 2
     774:	61 f1       	breq	.+88     	; 0x7ce <__fixsfsi+0x80>
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	50 f1       	brcs	.+84     	; 0x7ce <__fixsfsi+0x80>
     77a:	84 30       	cpi	r24, 0x04	; 4
     77c:	21 f4       	brne	.+8      	; 0x786 <__fixsfsi+0x38>
     77e:	8e 81       	ldd	r24, Y+6	; 0x06
     780:	88 23       	and	r24, r24
     782:	51 f1       	breq	.+84     	; 0x7d8 <__fixsfsi+0x8a>
     784:	2e c0       	rjmp	.+92     	; 0x7e2 <__fixsfsi+0x94>
     786:	2f 81       	ldd	r18, Y+7	; 0x07
     788:	38 85       	ldd	r19, Y+8	; 0x08
     78a:	37 fd       	sbrc	r19, 7
     78c:	20 c0       	rjmp	.+64     	; 0x7ce <__fixsfsi+0x80>
     78e:	6e 81       	ldd	r22, Y+6	; 0x06
     790:	2f 31       	cpi	r18, 0x1F	; 31
     792:	31 05       	cpc	r19, r1
     794:	1c f0       	brlt	.+6      	; 0x79c <__fixsfsi+0x4e>
     796:	66 23       	and	r22, r22
     798:	f9 f0       	breq	.+62     	; 0x7d8 <__fixsfsi+0x8a>
     79a:	23 c0       	rjmp	.+70     	; 0x7e2 <__fixsfsi+0x94>
     79c:	8e e1       	ldi	r24, 0x1E	; 30
     79e:	90 e0       	ldi	r25, 0x00	; 0
     7a0:	82 1b       	sub	r24, r18
     7a2:	93 0b       	sbc	r25, r19
     7a4:	29 85       	ldd	r18, Y+9	; 0x09
     7a6:	3a 85       	ldd	r19, Y+10	; 0x0a
     7a8:	4b 85       	ldd	r20, Y+11	; 0x0b
     7aa:	5c 85       	ldd	r21, Y+12	; 0x0c
     7ac:	04 c0       	rjmp	.+8      	; 0x7b6 <__fixsfsi+0x68>
     7ae:	56 95       	lsr	r21
     7b0:	47 95       	ror	r20
     7b2:	37 95       	ror	r19
     7b4:	27 95       	ror	r18
     7b6:	8a 95       	dec	r24
     7b8:	d2 f7       	brpl	.-12     	; 0x7ae <__fixsfsi+0x60>
     7ba:	66 23       	and	r22, r22
     7bc:	b1 f0       	breq	.+44     	; 0x7ea <__fixsfsi+0x9c>
     7be:	50 95       	com	r21
     7c0:	40 95       	com	r20
     7c2:	30 95       	com	r19
     7c4:	21 95       	neg	r18
     7c6:	3f 4f       	sbci	r19, 0xFF	; 255
     7c8:	4f 4f       	sbci	r20, 0xFF	; 255
     7ca:	5f 4f       	sbci	r21, 0xFF	; 255
     7cc:	0e c0       	rjmp	.+28     	; 0x7ea <__fixsfsi+0x9c>
     7ce:	20 e0       	ldi	r18, 0x00	; 0
     7d0:	30 e0       	ldi	r19, 0x00	; 0
     7d2:	40 e0       	ldi	r20, 0x00	; 0
     7d4:	50 e0       	ldi	r21, 0x00	; 0
     7d6:	09 c0       	rjmp	.+18     	; 0x7ea <__fixsfsi+0x9c>
     7d8:	2f ef       	ldi	r18, 0xFF	; 255
     7da:	3f ef       	ldi	r19, 0xFF	; 255
     7dc:	4f ef       	ldi	r20, 0xFF	; 255
     7de:	5f e7       	ldi	r21, 0x7F	; 127
     7e0:	04 c0       	rjmp	.+8      	; 0x7ea <__fixsfsi+0x9c>
     7e2:	20 e0       	ldi	r18, 0x00	; 0
     7e4:	30 e0       	ldi	r19, 0x00	; 0
     7e6:	40 e0       	ldi	r20, 0x00	; 0
     7e8:	50 e8       	ldi	r21, 0x80	; 128
     7ea:	b9 01       	movw	r22, r18
     7ec:	ca 01       	movw	r24, r20
     7ee:	2c 96       	adiw	r28, 0x0c	; 12
     7f0:	e2 e0       	ldi	r30, 0x02	; 2
     7f2:	0c 94 d7 3b 	jmp	0x77ae	; 0x77ae <__epilogue_restores__+0x20>

000007f6 <__pack_f>:
     7f6:	df 92       	push	r13
     7f8:	ef 92       	push	r14
     7fa:	ff 92       	push	r15
     7fc:	0f 93       	push	r16
     7fe:	1f 93       	push	r17
     800:	fc 01       	movw	r30, r24
     802:	e4 80       	ldd	r14, Z+4	; 0x04
     804:	f5 80       	ldd	r15, Z+5	; 0x05
     806:	06 81       	ldd	r16, Z+6	; 0x06
     808:	17 81       	ldd	r17, Z+7	; 0x07
     80a:	d1 80       	ldd	r13, Z+1	; 0x01
     80c:	80 81       	ld	r24, Z
     80e:	82 30       	cpi	r24, 0x02	; 2
     810:	48 f4       	brcc	.+18     	; 0x824 <__pack_f+0x2e>
     812:	80 e0       	ldi	r24, 0x00	; 0
     814:	90 e0       	ldi	r25, 0x00	; 0
     816:	a0 e1       	ldi	r26, 0x10	; 16
     818:	b0 e0       	ldi	r27, 0x00	; 0
     81a:	e8 2a       	or	r14, r24
     81c:	f9 2a       	or	r15, r25
     81e:	0a 2b       	or	r16, r26
     820:	1b 2b       	or	r17, r27
     822:	a5 c0       	rjmp	.+330    	; 0x96e <__stack+0x10f>
     824:	84 30       	cpi	r24, 0x04	; 4
     826:	09 f4       	brne	.+2      	; 0x82a <__pack_f+0x34>
     828:	9f c0       	rjmp	.+318    	; 0x968 <__stack+0x109>
     82a:	82 30       	cpi	r24, 0x02	; 2
     82c:	21 f4       	brne	.+8      	; 0x836 <__pack_f+0x40>
     82e:	ee 24       	eor	r14, r14
     830:	ff 24       	eor	r15, r15
     832:	87 01       	movw	r16, r14
     834:	05 c0       	rjmp	.+10     	; 0x840 <__pack_f+0x4a>
     836:	e1 14       	cp	r14, r1
     838:	f1 04       	cpc	r15, r1
     83a:	01 05       	cpc	r16, r1
     83c:	11 05       	cpc	r17, r1
     83e:	19 f4       	brne	.+6      	; 0x846 <__pack_f+0x50>
     840:	e0 e0       	ldi	r30, 0x00	; 0
     842:	f0 e0       	ldi	r31, 0x00	; 0
     844:	96 c0       	rjmp	.+300    	; 0x972 <__stack+0x113>
     846:	62 81       	ldd	r22, Z+2	; 0x02
     848:	73 81       	ldd	r23, Z+3	; 0x03
     84a:	9f ef       	ldi	r25, 0xFF	; 255
     84c:	62 38       	cpi	r22, 0x82	; 130
     84e:	79 07       	cpc	r23, r25
     850:	0c f0       	brlt	.+2      	; 0x854 <__pack_f+0x5e>
     852:	5b c0       	rjmp	.+182    	; 0x90a <__stack+0xab>
     854:	22 e8       	ldi	r18, 0x82	; 130
     856:	3f ef       	ldi	r19, 0xFF	; 255
     858:	26 1b       	sub	r18, r22
     85a:	37 0b       	sbc	r19, r23
     85c:	2a 31       	cpi	r18, 0x1A	; 26
     85e:	31 05       	cpc	r19, r1
     860:	2c f0       	brlt	.+10     	; 0x86c <__stack+0xd>
     862:	20 e0       	ldi	r18, 0x00	; 0
     864:	30 e0       	ldi	r19, 0x00	; 0
     866:	40 e0       	ldi	r20, 0x00	; 0
     868:	50 e0       	ldi	r21, 0x00	; 0
     86a:	2a c0       	rjmp	.+84     	; 0x8c0 <__stack+0x61>
     86c:	b8 01       	movw	r22, r16
     86e:	a7 01       	movw	r20, r14
     870:	02 2e       	mov	r0, r18
     872:	04 c0       	rjmp	.+8      	; 0x87c <__stack+0x1d>
     874:	76 95       	lsr	r23
     876:	67 95       	ror	r22
     878:	57 95       	ror	r21
     87a:	47 95       	ror	r20
     87c:	0a 94       	dec	r0
     87e:	d2 f7       	brpl	.-12     	; 0x874 <__stack+0x15>
     880:	81 e0       	ldi	r24, 0x01	; 1
     882:	90 e0       	ldi	r25, 0x00	; 0
     884:	a0 e0       	ldi	r26, 0x00	; 0
     886:	b0 e0       	ldi	r27, 0x00	; 0
     888:	04 c0       	rjmp	.+8      	; 0x892 <__stack+0x33>
     88a:	88 0f       	add	r24, r24
     88c:	99 1f       	adc	r25, r25
     88e:	aa 1f       	adc	r26, r26
     890:	bb 1f       	adc	r27, r27
     892:	2a 95       	dec	r18
     894:	d2 f7       	brpl	.-12     	; 0x88a <__stack+0x2b>
     896:	01 97       	sbiw	r24, 0x01	; 1
     898:	a1 09       	sbc	r26, r1
     89a:	b1 09       	sbc	r27, r1
     89c:	8e 21       	and	r24, r14
     89e:	9f 21       	and	r25, r15
     8a0:	a0 23       	and	r26, r16
     8a2:	b1 23       	and	r27, r17
     8a4:	00 97       	sbiw	r24, 0x00	; 0
     8a6:	a1 05       	cpc	r26, r1
     8a8:	b1 05       	cpc	r27, r1
     8aa:	21 f0       	breq	.+8      	; 0x8b4 <__stack+0x55>
     8ac:	81 e0       	ldi	r24, 0x01	; 1
     8ae:	90 e0       	ldi	r25, 0x00	; 0
     8b0:	a0 e0       	ldi	r26, 0x00	; 0
     8b2:	b0 e0       	ldi	r27, 0x00	; 0
     8b4:	9a 01       	movw	r18, r20
     8b6:	ab 01       	movw	r20, r22
     8b8:	28 2b       	or	r18, r24
     8ba:	39 2b       	or	r19, r25
     8bc:	4a 2b       	or	r20, r26
     8be:	5b 2b       	or	r21, r27
     8c0:	da 01       	movw	r26, r20
     8c2:	c9 01       	movw	r24, r18
     8c4:	8f 77       	andi	r24, 0x7F	; 127
     8c6:	90 70       	andi	r25, 0x00	; 0
     8c8:	a0 70       	andi	r26, 0x00	; 0
     8ca:	b0 70       	andi	r27, 0x00	; 0
     8cc:	80 34       	cpi	r24, 0x40	; 64
     8ce:	91 05       	cpc	r25, r1
     8d0:	a1 05       	cpc	r26, r1
     8d2:	b1 05       	cpc	r27, r1
     8d4:	39 f4       	brne	.+14     	; 0x8e4 <__stack+0x85>
     8d6:	27 ff       	sbrs	r18, 7
     8d8:	09 c0       	rjmp	.+18     	; 0x8ec <__stack+0x8d>
     8da:	20 5c       	subi	r18, 0xC0	; 192
     8dc:	3f 4f       	sbci	r19, 0xFF	; 255
     8de:	4f 4f       	sbci	r20, 0xFF	; 255
     8e0:	5f 4f       	sbci	r21, 0xFF	; 255
     8e2:	04 c0       	rjmp	.+8      	; 0x8ec <__stack+0x8d>
     8e4:	21 5c       	subi	r18, 0xC1	; 193
     8e6:	3f 4f       	sbci	r19, 0xFF	; 255
     8e8:	4f 4f       	sbci	r20, 0xFF	; 255
     8ea:	5f 4f       	sbci	r21, 0xFF	; 255
     8ec:	e0 e0       	ldi	r30, 0x00	; 0
     8ee:	f0 e0       	ldi	r31, 0x00	; 0
     8f0:	20 30       	cpi	r18, 0x00	; 0
     8f2:	a0 e0       	ldi	r26, 0x00	; 0
     8f4:	3a 07       	cpc	r19, r26
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	4a 07       	cpc	r20, r26
     8fa:	a0 e4       	ldi	r26, 0x40	; 64
     8fc:	5a 07       	cpc	r21, r26
     8fe:	10 f0       	brcs	.+4      	; 0x904 <__stack+0xa5>
     900:	e1 e0       	ldi	r30, 0x01	; 1
     902:	f0 e0       	ldi	r31, 0x00	; 0
     904:	79 01       	movw	r14, r18
     906:	8a 01       	movw	r16, r20
     908:	27 c0       	rjmp	.+78     	; 0x958 <__stack+0xf9>
     90a:	60 38       	cpi	r22, 0x80	; 128
     90c:	71 05       	cpc	r23, r1
     90e:	64 f5       	brge	.+88     	; 0x968 <__stack+0x109>
     910:	fb 01       	movw	r30, r22
     912:	e1 58       	subi	r30, 0x81	; 129
     914:	ff 4f       	sbci	r31, 0xFF	; 255
     916:	d8 01       	movw	r26, r16
     918:	c7 01       	movw	r24, r14
     91a:	8f 77       	andi	r24, 0x7F	; 127
     91c:	90 70       	andi	r25, 0x00	; 0
     91e:	a0 70       	andi	r26, 0x00	; 0
     920:	b0 70       	andi	r27, 0x00	; 0
     922:	80 34       	cpi	r24, 0x40	; 64
     924:	91 05       	cpc	r25, r1
     926:	a1 05       	cpc	r26, r1
     928:	b1 05       	cpc	r27, r1
     92a:	39 f4       	brne	.+14     	; 0x93a <__stack+0xdb>
     92c:	e7 fe       	sbrs	r14, 7
     92e:	0d c0       	rjmp	.+26     	; 0x94a <__stack+0xeb>
     930:	80 e4       	ldi	r24, 0x40	; 64
     932:	90 e0       	ldi	r25, 0x00	; 0
     934:	a0 e0       	ldi	r26, 0x00	; 0
     936:	b0 e0       	ldi	r27, 0x00	; 0
     938:	04 c0       	rjmp	.+8      	; 0x942 <__stack+0xe3>
     93a:	8f e3       	ldi	r24, 0x3F	; 63
     93c:	90 e0       	ldi	r25, 0x00	; 0
     93e:	a0 e0       	ldi	r26, 0x00	; 0
     940:	b0 e0       	ldi	r27, 0x00	; 0
     942:	e8 0e       	add	r14, r24
     944:	f9 1e       	adc	r15, r25
     946:	0a 1f       	adc	r16, r26
     948:	1b 1f       	adc	r17, r27
     94a:	17 ff       	sbrs	r17, 7
     94c:	05 c0       	rjmp	.+10     	; 0x958 <__stack+0xf9>
     94e:	16 95       	lsr	r17
     950:	07 95       	ror	r16
     952:	f7 94       	ror	r15
     954:	e7 94       	ror	r14
     956:	31 96       	adiw	r30, 0x01	; 1
     958:	87 e0       	ldi	r24, 0x07	; 7
     95a:	16 95       	lsr	r17
     95c:	07 95       	ror	r16
     95e:	f7 94       	ror	r15
     960:	e7 94       	ror	r14
     962:	8a 95       	dec	r24
     964:	d1 f7       	brne	.-12     	; 0x95a <__stack+0xfb>
     966:	05 c0       	rjmp	.+10     	; 0x972 <__stack+0x113>
     968:	ee 24       	eor	r14, r14
     96a:	ff 24       	eor	r15, r15
     96c:	87 01       	movw	r16, r14
     96e:	ef ef       	ldi	r30, 0xFF	; 255
     970:	f0 e0       	ldi	r31, 0x00	; 0
     972:	6e 2f       	mov	r22, r30
     974:	67 95       	ror	r22
     976:	66 27       	eor	r22, r22
     978:	67 95       	ror	r22
     97a:	90 2f       	mov	r25, r16
     97c:	9f 77       	andi	r25, 0x7F	; 127
     97e:	d7 94       	ror	r13
     980:	dd 24       	eor	r13, r13
     982:	d7 94       	ror	r13
     984:	8e 2f       	mov	r24, r30
     986:	86 95       	lsr	r24
     988:	49 2f       	mov	r20, r25
     98a:	46 2b       	or	r20, r22
     98c:	58 2f       	mov	r21, r24
     98e:	5d 29       	or	r21, r13
     990:	b7 01       	movw	r22, r14
     992:	ca 01       	movw	r24, r20
     994:	1f 91       	pop	r17
     996:	0f 91       	pop	r16
     998:	ff 90       	pop	r15
     99a:	ef 90       	pop	r14
     99c:	df 90       	pop	r13
     99e:	08 95       	ret

000009a0 <__unpack_f>:
     9a0:	fc 01       	movw	r30, r24
     9a2:	db 01       	movw	r26, r22
     9a4:	40 81       	ld	r20, Z
     9a6:	51 81       	ldd	r21, Z+1	; 0x01
     9a8:	22 81       	ldd	r18, Z+2	; 0x02
     9aa:	62 2f       	mov	r22, r18
     9ac:	6f 77       	andi	r22, 0x7F	; 127
     9ae:	70 e0       	ldi	r23, 0x00	; 0
     9b0:	22 1f       	adc	r18, r18
     9b2:	22 27       	eor	r18, r18
     9b4:	22 1f       	adc	r18, r18
     9b6:	93 81       	ldd	r25, Z+3	; 0x03
     9b8:	89 2f       	mov	r24, r25
     9ba:	88 0f       	add	r24, r24
     9bc:	82 2b       	or	r24, r18
     9be:	28 2f       	mov	r18, r24
     9c0:	30 e0       	ldi	r19, 0x00	; 0
     9c2:	99 1f       	adc	r25, r25
     9c4:	99 27       	eor	r25, r25
     9c6:	99 1f       	adc	r25, r25
     9c8:	11 96       	adiw	r26, 0x01	; 1
     9ca:	9c 93       	st	X, r25
     9cc:	11 97       	sbiw	r26, 0x01	; 1
     9ce:	21 15       	cp	r18, r1
     9d0:	31 05       	cpc	r19, r1
     9d2:	a9 f5       	brne	.+106    	; 0xa3e <__unpack_f+0x9e>
     9d4:	41 15       	cp	r20, r1
     9d6:	51 05       	cpc	r21, r1
     9d8:	61 05       	cpc	r22, r1
     9da:	71 05       	cpc	r23, r1
     9dc:	11 f4       	brne	.+4      	; 0x9e2 <__unpack_f+0x42>
     9de:	82 e0       	ldi	r24, 0x02	; 2
     9e0:	37 c0       	rjmp	.+110    	; 0xa50 <__unpack_f+0xb0>
     9e2:	82 e8       	ldi	r24, 0x82	; 130
     9e4:	9f ef       	ldi	r25, 0xFF	; 255
     9e6:	13 96       	adiw	r26, 0x03	; 3
     9e8:	9c 93       	st	X, r25
     9ea:	8e 93       	st	-X, r24
     9ec:	12 97       	sbiw	r26, 0x02	; 2
     9ee:	9a 01       	movw	r18, r20
     9f0:	ab 01       	movw	r20, r22
     9f2:	67 e0       	ldi	r22, 0x07	; 7
     9f4:	22 0f       	add	r18, r18
     9f6:	33 1f       	adc	r19, r19
     9f8:	44 1f       	adc	r20, r20
     9fa:	55 1f       	adc	r21, r21
     9fc:	6a 95       	dec	r22
     9fe:	d1 f7       	brne	.-12     	; 0x9f4 <__unpack_f+0x54>
     a00:	83 e0       	ldi	r24, 0x03	; 3
     a02:	8c 93       	st	X, r24
     a04:	0d c0       	rjmp	.+26     	; 0xa20 <__unpack_f+0x80>
     a06:	22 0f       	add	r18, r18
     a08:	33 1f       	adc	r19, r19
     a0a:	44 1f       	adc	r20, r20
     a0c:	55 1f       	adc	r21, r21
     a0e:	12 96       	adiw	r26, 0x02	; 2
     a10:	8d 91       	ld	r24, X+
     a12:	9c 91       	ld	r25, X
     a14:	13 97       	sbiw	r26, 0x03	; 3
     a16:	01 97       	sbiw	r24, 0x01	; 1
     a18:	13 96       	adiw	r26, 0x03	; 3
     a1a:	9c 93       	st	X, r25
     a1c:	8e 93       	st	-X, r24
     a1e:	12 97       	sbiw	r26, 0x02	; 2
     a20:	20 30       	cpi	r18, 0x00	; 0
     a22:	80 e0       	ldi	r24, 0x00	; 0
     a24:	38 07       	cpc	r19, r24
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	48 07       	cpc	r20, r24
     a2a:	80 e4       	ldi	r24, 0x40	; 64
     a2c:	58 07       	cpc	r21, r24
     a2e:	58 f3       	brcs	.-42     	; 0xa06 <__unpack_f+0x66>
     a30:	14 96       	adiw	r26, 0x04	; 4
     a32:	2d 93       	st	X+, r18
     a34:	3d 93       	st	X+, r19
     a36:	4d 93       	st	X+, r20
     a38:	5c 93       	st	X, r21
     a3a:	17 97       	sbiw	r26, 0x07	; 7
     a3c:	08 95       	ret
     a3e:	2f 3f       	cpi	r18, 0xFF	; 255
     a40:	31 05       	cpc	r19, r1
     a42:	79 f4       	brne	.+30     	; 0xa62 <__unpack_f+0xc2>
     a44:	41 15       	cp	r20, r1
     a46:	51 05       	cpc	r21, r1
     a48:	61 05       	cpc	r22, r1
     a4a:	71 05       	cpc	r23, r1
     a4c:	19 f4       	brne	.+6      	; 0xa54 <__unpack_f+0xb4>
     a4e:	84 e0       	ldi	r24, 0x04	; 4
     a50:	8c 93       	st	X, r24
     a52:	08 95       	ret
     a54:	64 ff       	sbrs	r22, 4
     a56:	03 c0       	rjmp	.+6      	; 0xa5e <__unpack_f+0xbe>
     a58:	81 e0       	ldi	r24, 0x01	; 1
     a5a:	8c 93       	st	X, r24
     a5c:	12 c0       	rjmp	.+36     	; 0xa82 <__unpack_f+0xe2>
     a5e:	1c 92       	st	X, r1
     a60:	10 c0       	rjmp	.+32     	; 0xa82 <__unpack_f+0xe2>
     a62:	2f 57       	subi	r18, 0x7F	; 127
     a64:	30 40       	sbci	r19, 0x00	; 0
     a66:	13 96       	adiw	r26, 0x03	; 3
     a68:	3c 93       	st	X, r19
     a6a:	2e 93       	st	-X, r18
     a6c:	12 97       	sbiw	r26, 0x02	; 2
     a6e:	83 e0       	ldi	r24, 0x03	; 3
     a70:	8c 93       	st	X, r24
     a72:	87 e0       	ldi	r24, 0x07	; 7
     a74:	44 0f       	add	r20, r20
     a76:	55 1f       	adc	r21, r21
     a78:	66 1f       	adc	r22, r22
     a7a:	77 1f       	adc	r23, r23
     a7c:	8a 95       	dec	r24
     a7e:	d1 f7       	brne	.-12     	; 0xa74 <__unpack_f+0xd4>
     a80:	70 64       	ori	r23, 0x40	; 64
     a82:	14 96       	adiw	r26, 0x04	; 4
     a84:	4d 93       	st	X+, r20
     a86:	5d 93       	st	X+, r21
     a88:	6d 93       	st	X+, r22
     a8a:	7c 93       	st	X, r23
     a8c:	17 97       	sbiw	r26, 0x07	; 7
     a8e:	08 95       	ret

00000a90 <__fpcmp_parts_f>:
     a90:	1f 93       	push	r17
     a92:	dc 01       	movw	r26, r24
     a94:	fb 01       	movw	r30, r22
     a96:	9c 91       	ld	r25, X
     a98:	92 30       	cpi	r25, 0x02	; 2
     a9a:	08 f4       	brcc	.+2      	; 0xa9e <__fpcmp_parts_f+0xe>
     a9c:	47 c0       	rjmp	.+142    	; 0xb2c <__fpcmp_parts_f+0x9c>
     a9e:	80 81       	ld	r24, Z
     aa0:	82 30       	cpi	r24, 0x02	; 2
     aa2:	08 f4       	brcc	.+2      	; 0xaa6 <__fpcmp_parts_f+0x16>
     aa4:	43 c0       	rjmp	.+134    	; 0xb2c <__fpcmp_parts_f+0x9c>
     aa6:	94 30       	cpi	r25, 0x04	; 4
     aa8:	51 f4       	brne	.+20     	; 0xabe <__fpcmp_parts_f+0x2e>
     aaa:	11 96       	adiw	r26, 0x01	; 1
     aac:	1c 91       	ld	r17, X
     aae:	84 30       	cpi	r24, 0x04	; 4
     ab0:	99 f5       	brne	.+102    	; 0xb18 <__fpcmp_parts_f+0x88>
     ab2:	81 81       	ldd	r24, Z+1	; 0x01
     ab4:	68 2f       	mov	r22, r24
     ab6:	70 e0       	ldi	r23, 0x00	; 0
     ab8:	61 1b       	sub	r22, r17
     aba:	71 09       	sbc	r23, r1
     abc:	3f c0       	rjmp	.+126    	; 0xb3c <__fpcmp_parts_f+0xac>
     abe:	84 30       	cpi	r24, 0x04	; 4
     ac0:	21 f0       	breq	.+8      	; 0xaca <__fpcmp_parts_f+0x3a>
     ac2:	92 30       	cpi	r25, 0x02	; 2
     ac4:	31 f4       	brne	.+12     	; 0xad2 <__fpcmp_parts_f+0x42>
     ac6:	82 30       	cpi	r24, 0x02	; 2
     ac8:	b9 f1       	breq	.+110    	; 0xb38 <__fpcmp_parts_f+0xa8>
     aca:	81 81       	ldd	r24, Z+1	; 0x01
     acc:	88 23       	and	r24, r24
     ace:	89 f1       	breq	.+98     	; 0xb32 <__fpcmp_parts_f+0xa2>
     ad0:	2d c0       	rjmp	.+90     	; 0xb2c <__fpcmp_parts_f+0x9c>
     ad2:	11 96       	adiw	r26, 0x01	; 1
     ad4:	1c 91       	ld	r17, X
     ad6:	11 97       	sbiw	r26, 0x01	; 1
     ad8:	82 30       	cpi	r24, 0x02	; 2
     ada:	f1 f0       	breq	.+60     	; 0xb18 <__fpcmp_parts_f+0x88>
     adc:	81 81       	ldd	r24, Z+1	; 0x01
     ade:	18 17       	cp	r17, r24
     ae0:	d9 f4       	brne	.+54     	; 0xb18 <__fpcmp_parts_f+0x88>
     ae2:	12 96       	adiw	r26, 0x02	; 2
     ae4:	2d 91       	ld	r18, X+
     ae6:	3c 91       	ld	r19, X
     ae8:	13 97       	sbiw	r26, 0x03	; 3
     aea:	82 81       	ldd	r24, Z+2	; 0x02
     aec:	93 81       	ldd	r25, Z+3	; 0x03
     aee:	82 17       	cp	r24, r18
     af0:	93 07       	cpc	r25, r19
     af2:	94 f0       	brlt	.+36     	; 0xb18 <__fpcmp_parts_f+0x88>
     af4:	28 17       	cp	r18, r24
     af6:	39 07       	cpc	r19, r25
     af8:	bc f0       	brlt	.+46     	; 0xb28 <__fpcmp_parts_f+0x98>
     afa:	14 96       	adiw	r26, 0x04	; 4
     afc:	8d 91       	ld	r24, X+
     afe:	9d 91       	ld	r25, X+
     b00:	0d 90       	ld	r0, X+
     b02:	bc 91       	ld	r27, X
     b04:	a0 2d       	mov	r26, r0
     b06:	24 81       	ldd	r18, Z+4	; 0x04
     b08:	35 81       	ldd	r19, Z+5	; 0x05
     b0a:	46 81       	ldd	r20, Z+6	; 0x06
     b0c:	57 81       	ldd	r21, Z+7	; 0x07
     b0e:	28 17       	cp	r18, r24
     b10:	39 07       	cpc	r19, r25
     b12:	4a 07       	cpc	r20, r26
     b14:	5b 07       	cpc	r21, r27
     b16:	18 f4       	brcc	.+6      	; 0xb1e <__fpcmp_parts_f+0x8e>
     b18:	11 23       	and	r17, r17
     b1a:	41 f0       	breq	.+16     	; 0xb2c <__fpcmp_parts_f+0x9c>
     b1c:	0a c0       	rjmp	.+20     	; 0xb32 <__fpcmp_parts_f+0xa2>
     b1e:	82 17       	cp	r24, r18
     b20:	93 07       	cpc	r25, r19
     b22:	a4 07       	cpc	r26, r20
     b24:	b5 07       	cpc	r27, r21
     b26:	40 f4       	brcc	.+16     	; 0xb38 <__fpcmp_parts_f+0xa8>
     b28:	11 23       	and	r17, r17
     b2a:	19 f0       	breq	.+6      	; 0xb32 <__fpcmp_parts_f+0xa2>
     b2c:	61 e0       	ldi	r22, 0x01	; 1
     b2e:	70 e0       	ldi	r23, 0x00	; 0
     b30:	05 c0       	rjmp	.+10     	; 0xb3c <__fpcmp_parts_f+0xac>
     b32:	6f ef       	ldi	r22, 0xFF	; 255
     b34:	7f ef       	ldi	r23, 0xFF	; 255
     b36:	02 c0       	rjmp	.+4      	; 0xb3c <__fpcmp_parts_f+0xac>
     b38:	60 e0       	ldi	r22, 0x00	; 0
     b3a:	70 e0       	ldi	r23, 0x00	; 0
     b3c:	cb 01       	movw	r24, r22
     b3e:	1f 91       	pop	r17
     b40:	08 95       	ret

00000b42 <__vector_11>:

/* Global variables to hold the address of the call back function in the application */
static volatile void (*g_callBackPtr)(void) = NULL_PTR;

ISR (TIMER0_OVF_vect)
{
     b42:	1f 92       	push	r1
     b44:	0f 92       	push	r0
     b46:	0f b6       	in	r0, 0x3f	; 63
     b48:	0f 92       	push	r0
     b4a:	11 24       	eor	r1, r1
     b4c:	2f 93       	push	r18
     b4e:	3f 93       	push	r19
     b50:	4f 93       	push	r20
     b52:	5f 93       	push	r21
     b54:	6f 93       	push	r22
     b56:	7f 93       	push	r23
     b58:	8f 93       	push	r24
     b5a:	9f 93       	push	r25
     b5c:	af 93       	push	r26
     b5e:	bf 93       	push	r27
     b60:	ef 93       	push	r30
     b62:	ff 93       	push	r31
     b64:	df 93       	push	r29
     b66:	cf 93       	push	r28
     b68:	cd b7       	in	r28, 0x3d	; 61
     b6a:	de b7       	in	r29, 0x3e	; 62
	if(g_callBackPtr != NULL_PTR)
     b6c:	80 91 2a 01 	lds	r24, 0x012A
     b70:	90 91 2b 01 	lds	r25, 0x012B
     b74:	00 97       	sbiw	r24, 0x00	; 0
     b76:	29 f0       	breq	.+10     	; 0xb82 <__vector_11+0x40>
		{
		/* Call the Call Back function in the application after the edge is detected */
		(*g_callBackPtr)(); /* another method to call the function using pointer to function g_callBackPtr(); */
     b78:	e0 91 2a 01 	lds	r30, 0x012A
     b7c:	f0 91 2b 01 	lds	r31, 0x012B
     b80:	09 95       	icall
		}
}
     b82:	cf 91       	pop	r28
     b84:	df 91       	pop	r29
     b86:	ff 91       	pop	r31
     b88:	ef 91       	pop	r30
     b8a:	bf 91       	pop	r27
     b8c:	af 91       	pop	r26
     b8e:	9f 91       	pop	r25
     b90:	8f 91       	pop	r24
     b92:	7f 91       	pop	r23
     b94:	6f 91       	pop	r22
     b96:	5f 91       	pop	r21
     b98:	4f 91       	pop	r20
     b9a:	3f 91       	pop	r19
     b9c:	2f 91       	pop	r18
     b9e:	0f 90       	pop	r0
     ba0:	0f be       	out	0x3f, r0	; 63
     ba2:	0f 90       	pop	r0
     ba4:	1f 90       	pop	r1
     ba6:	18 95       	reti

00000ba8 <__vector_10>:

ISR (TIMER0_COMP_vect)
{
     ba8:	1f 92       	push	r1
     baa:	0f 92       	push	r0
     bac:	0f b6       	in	r0, 0x3f	; 63
     bae:	0f 92       	push	r0
     bb0:	11 24       	eor	r1, r1
     bb2:	2f 93       	push	r18
     bb4:	3f 93       	push	r19
     bb6:	4f 93       	push	r20
     bb8:	5f 93       	push	r21
     bba:	6f 93       	push	r22
     bbc:	7f 93       	push	r23
     bbe:	8f 93       	push	r24
     bc0:	9f 93       	push	r25
     bc2:	af 93       	push	r26
     bc4:	bf 93       	push	r27
     bc6:	ef 93       	push	r30
     bc8:	ff 93       	push	r31
     bca:	df 93       	push	r29
     bcc:	cf 93       	push	r28
     bce:	cd b7       	in	r28, 0x3d	; 61
     bd0:	de b7       	in	r29, 0x3e	; 62
	if(g_callBackPtr != NULL_PTR)
     bd2:	80 91 2a 01 	lds	r24, 0x012A
     bd6:	90 91 2b 01 	lds	r25, 0x012B
     bda:	00 97       	sbiw	r24, 0x00	; 0
     bdc:	29 f0       	breq	.+10     	; 0xbe8 <__vector_10+0x40>
		{
		/* Call the Call Back function in the application after the edge is detected */
		(*g_callBackPtr)(); /* another method to call the function using pointer to function g_callBackPtr(); */
     bde:	e0 91 2a 01 	lds	r30, 0x012A
     be2:	f0 91 2b 01 	lds	r31, 0x012B
     be6:	09 95       	icall
		}
}
     be8:	cf 91       	pop	r28
     bea:	df 91       	pop	r29
     bec:	ff 91       	pop	r31
     bee:	ef 91       	pop	r30
     bf0:	bf 91       	pop	r27
     bf2:	af 91       	pop	r26
     bf4:	9f 91       	pop	r25
     bf6:	8f 91       	pop	r24
     bf8:	7f 91       	pop	r23
     bfa:	6f 91       	pop	r22
     bfc:	5f 91       	pop	r21
     bfe:	4f 91       	pop	r20
     c00:	3f 91       	pop	r19
     c02:	2f 91       	pop	r18
     c04:	0f 90       	pop	r0
     c06:	0f be       	out	0x3f, r0	; 63
     c08:	0f 90       	pop	r0
     c0a:	1f 90       	pop	r1
     c0c:	18 95       	reti

00000c0e <Timer0_init>:

void Timer0_init(const Timer0_ConfigType *Config_ptr)
{
     c0e:	df 93       	push	r29
     c10:	cf 93       	push	r28
     c12:	00 d0       	rcall	.+0      	; 0xc14 <Timer0_init+0x6>
     c14:	cd b7       	in	r28, 0x3d	; 61
     c16:	de b7       	in	r29, 0x3e	; 62
     c18:	9a 83       	std	Y+2, r25	; 0x02
     c1a:	89 83       	std	Y+1, r24	; 0x01
	TCNT0 = Config_ptr->initialValue;
     c1c:	a2 e5       	ldi	r26, 0x52	; 82
     c1e:	b0 e0       	ldi	r27, 0x00	; 0
     c20:	e9 81       	ldd	r30, Y+1	; 0x01
     c22:	fa 81       	ldd	r31, Y+2	; 0x02
     c24:	82 81       	ldd	r24, Z+2	; 0x02
     c26:	8c 93       	st	X, r24
	if (Config_ptr->mode == NORMAL_MODE)
     c28:	e9 81       	ldd	r30, Y+1	; 0x01
     c2a:	fa 81       	ldd	r31, Y+2	; 0x02
     c2c:	80 81       	ld	r24, Z
     c2e:	88 23       	and	r24, r24
     c30:	d9 f4       	brne	.+54     	; 0xc68 <Timer0_init+0x5a>
	{
		TCCR0|=(1<<FOC0);
     c32:	a3 e5       	ldi	r26, 0x53	; 83
     c34:	b0 e0       	ldi	r27, 0x00	; 0
     c36:	e3 e5       	ldi	r30, 0x53	; 83
     c38:	f0 e0       	ldi	r31, 0x00	; 0
     c3a:	80 81       	ld	r24, Z
     c3c:	80 68       	ori	r24, 0x80	; 128
     c3e:	8c 93       	st	X, r24
		TIMSK|=(1<<TOIE0);
     c40:	a9 e5       	ldi	r26, 0x59	; 89
     c42:	b0 e0       	ldi	r27, 0x00	; 0
     c44:	e9 e5       	ldi	r30, 0x59	; 89
     c46:	f0 e0       	ldi	r31, 0x00	; 0
     c48:	80 81       	ld	r24, Z
     c4a:	81 60       	ori	r24, 0x01	; 1
     c4c:	8c 93       	st	X, r24
		TCCR0 = (TCCR0 & 0xF8) | (Config_ptr->clock);
     c4e:	a3 e5       	ldi	r26, 0x53	; 83
     c50:	b0 e0       	ldi	r27, 0x00	; 0
     c52:	e3 e5       	ldi	r30, 0x53	; 83
     c54:	f0 e0       	ldi	r31, 0x00	; 0
     c56:	80 81       	ld	r24, Z
     c58:	98 2f       	mov	r25, r24
     c5a:	98 7f       	andi	r25, 0xF8	; 248
     c5c:	e9 81       	ldd	r30, Y+1	; 0x01
     c5e:	fa 81       	ldd	r31, Y+2	; 0x02
     c60:	81 81       	ldd	r24, Z+1	; 0x01
     c62:	89 2b       	or	r24, r25
     c64:	8c 93       	st	X, r24
     c66:	25 c0       	rjmp	.+74     	; 0xcb2 <Timer0_init+0xa4>
	}
	else if (Config_ptr->mode == COMPARE_MODE)
     c68:	e9 81       	ldd	r30, Y+1	; 0x01
     c6a:	fa 81       	ldd	r31, Y+2	; 0x02
     c6c:	80 81       	ld	r24, Z
     c6e:	82 30       	cpi	r24, 0x02	; 2
     c70:	01 f5       	brne	.+64     	; 0xcb2 <Timer0_init+0xa4>
	{
		TCCR0 |= (1 << FOC0);
     c72:	a3 e5       	ldi	r26, 0x53	; 83
     c74:	b0 e0       	ldi	r27, 0x00	; 0
     c76:	e3 e5       	ldi	r30, 0x53	; 83
     c78:	f0 e0       	ldi	r31, 0x00	; 0
     c7a:	80 81       	ld	r24, Z
     c7c:	80 68       	ori	r24, 0x80	; 128
     c7e:	8c 93       	st	X, r24
//		TCCR0 |= (1 << WGM01);
		TIMSK |= (1 << OCIE0);
     c80:	a9 e5       	ldi	r26, 0x59	; 89
     c82:	b0 e0       	ldi	r27, 0x00	; 0
     c84:	e9 e5       	ldi	r30, 0x59	; 89
     c86:	f0 e0       	ldi	r31, 0x00	; 0
     c88:	80 81       	ld	r24, Z
     c8a:	82 60       	ori	r24, 0x02	; 2
     c8c:	8c 93       	st	X, r24
		OCR0 = Config_ptr->compareValue;
     c8e:	ac e5       	ldi	r26, 0x5C	; 92
     c90:	b0 e0       	ldi	r27, 0x00	; 0
     c92:	e9 81       	ldd	r30, Y+1	; 0x01
     c94:	fa 81       	ldd	r31, Y+2	; 0x02
     c96:	83 81       	ldd	r24, Z+3	; 0x03
     c98:	8c 93       	st	X, r24
		TCCR0 = (TCCR0 & 0xF8) | (Config_ptr->clock);
     c9a:	a3 e5       	ldi	r26, 0x53	; 83
     c9c:	b0 e0       	ldi	r27, 0x00	; 0
     c9e:	e3 e5       	ldi	r30, 0x53	; 83
     ca0:	f0 e0       	ldi	r31, 0x00	; 0
     ca2:	80 81       	ld	r24, Z
     ca4:	98 2f       	mov	r25, r24
     ca6:	98 7f       	andi	r25, 0xF8	; 248
     ca8:	e9 81       	ldd	r30, Y+1	; 0x01
     caa:	fa 81       	ldd	r31, Y+2	; 0x02
     cac:	81 81       	ldd	r24, Z+1	; 0x01
     cae:	89 2b       	or	r24, r25
     cb0:	8c 93       	st	X, r24
	}
}
     cb2:	0f 90       	pop	r0
     cb4:	0f 90       	pop	r0
     cb6:	cf 91       	pop	r28
     cb8:	df 91       	pop	r29
     cba:	08 95       	ret

00000cbc <Timer0_setCallBack>:

void Timer0_setCallBack( void(*a_ptr)(void) )
{
     cbc:	df 93       	push	r29
     cbe:	cf 93       	push	r28
     cc0:	00 d0       	rcall	.+0      	; 0xcc2 <Timer0_setCallBack+0x6>
     cc2:	cd b7       	in	r28, 0x3d	; 61
     cc4:	de b7       	in	r29, 0x3e	; 62
     cc6:	9a 83       	std	Y+2, r25	; 0x02
     cc8:	89 83       	std	Y+1, r24	; 0x01
	g_callBackPtr=a_ptr;
     cca:	89 81       	ldd	r24, Y+1	; 0x01
     ccc:	9a 81       	ldd	r25, Y+2	; 0x02
     cce:	90 93 2b 01 	sts	0x012B, r25
     cd2:	80 93 2a 01 	sts	0x012A, r24
}
     cd6:	0f 90       	pop	r0
     cd8:	0f 90       	pop	r0
     cda:	cf 91       	pop	r28
     cdc:	df 91       	pop	r29
     cde:	08 95       	ret

00000ce0 <Timer0_DeInit>:

void Timer0_DeInit(void)
{
     ce0:	df 93       	push	r29
     ce2:	cf 93       	push	r28
     ce4:	cd b7       	in	r28, 0x3d	; 61
     ce6:	de b7       	in	r29, 0x3e	; 62
	TCCR0=0;
     ce8:	e3 e5       	ldi	r30, 0x53	; 83
     cea:	f0 e0       	ldi	r31, 0x00	; 0
     cec:	10 82       	st	Z, r1
	TIMSK=0;
     cee:	e9 e5       	ldi	r30, 0x59	; 89
     cf0:	f0 e0       	ldi	r31, 0x00	; 0
     cf2:	10 82       	st	Z, r1
//	g_callBackPtr=NULL_PTR;
}
     cf4:	cf 91       	pop	r28
     cf6:	df 91       	pop	r29
     cf8:	08 95       	ret

00000cfa <EnableInterrupt>:

void EnableInterrupt(void){}
     cfa:	df 93       	push	r29
     cfc:	cf 93       	push	r28
     cfe:	cd b7       	in	r28, 0x3d	; 61
     d00:	de b7       	in	r29, 0x3e	; 62
     d02:	cf 91       	pop	r28
     d04:	df 91       	pop	r29
     d06:	08 95       	ret

00000d08 <DisableInterrupt>:


void DisableInterrupt(void){}
     d08:	df 93       	push	r29
     d0a:	cf 93       	push	r28
     d0c:	cd b7       	in	r28, 0x3d	; 61
     d0e:	de b7       	in	r29, 0x3e	; 62
     d10:	cf 91       	pop	r28
     d12:	df 91       	pop	r29
     d14:	08 95       	ret

00000d16 <SPI_initMaster>:
/*
 * Description :
 * Initialize the SPI device as Master.
 */
void SPI_initMaster(void) 
{
     d16:	df 93       	push	r29
     d18:	cf 93       	push	r28
     d1a:	cd b7       	in	r28, 0x3d	; 61
     d1c:	de b7       	in	r29, 0x3e	; 62
	 * SS(PB4)   --> Output
	 * MOSI(PB5) --> Output 
	 * MISO(PB6) --> Input
	 * SCK(PB7) --> Output
	 ********************************************/
	GPIO_setupPinDirection(PORTB_ID,PIN4_ID,PIN_OUTPUT);
     d1e:	81 e0       	ldi	r24, 0x01	; 1
     d20:	64 e0       	ldi	r22, 0x04	; 4
     d22:	41 e0       	ldi	r20, 0x01	; 1
     d24:	0e 94 16 0a 	call	0x142c	; 0x142c <GPIO_setupPinDirection>
	GPIO_setupPinDirection(PORTB_ID,PIN5_ID,PIN_OUTPUT);
     d28:	81 e0       	ldi	r24, 0x01	; 1
     d2a:	65 e0       	ldi	r22, 0x05	; 5
     d2c:	41 e0       	ldi	r20, 0x01	; 1
     d2e:	0e 94 16 0a 	call	0x142c	; 0x142c <GPIO_setupPinDirection>
	GPIO_setupPinDirection(PORTB_ID,PIN6_ID,PIN_INPUT);
     d32:	81 e0       	ldi	r24, 0x01	; 1
     d34:	66 e0       	ldi	r22, 0x06	; 6
     d36:	40 e0       	ldi	r20, 0x00	; 0
     d38:	0e 94 16 0a 	call	0x142c	; 0x142c <GPIO_setupPinDirection>
	GPIO_setupPinDirection(PORTB_ID,PIN7_ID,PIN_OUTPUT);
     d3c:	81 e0       	ldi	r24, 0x01	; 1
     d3e:	67 e0       	ldi	r22, 0x07	; 7
     d40:	41 e0       	ldi	r20, 0x01	; 1
     d42:	0e 94 16 0a 	call	0x142c	; 0x142c <GPIO_setupPinDirection>
     * MSTR    = 1 Enable Master
     * CPOL    = 0 SCK is low when idle
     * CPHA    = 0 Sample Data with the raising edge
     * SPR1:0  = 00 Choose SPI clock = Fosc/4
     ***********************************************************************/
	SPCR = (1<<SPE) | (1<<MSTR)| (1<<CPHA);
     d46:	ed e2       	ldi	r30, 0x2D	; 45
     d48:	f0 e0       	ldi	r31, 0x00	; 0
     d4a:	84 e5       	ldi	r24, 0x54	; 84
     d4c:	80 83       	st	Z, r24

	/* Clear the SPI2X bit in SPSR to Choose SPI clock = Fosc/4 */
	SPSR &= ~(1<<SPI2X);
     d4e:	ae e2       	ldi	r26, 0x2E	; 46
     d50:	b0 e0       	ldi	r27, 0x00	; 0
     d52:	ee e2       	ldi	r30, 0x2E	; 46
     d54:	f0 e0       	ldi	r31, 0x00	; 0
     d56:	80 81       	ld	r24, Z
     d58:	8e 7f       	andi	r24, 0xFE	; 254
     d5a:	8c 93       	st	X, r24
}
     d5c:	cf 91       	pop	r28
     d5e:	df 91       	pop	r29
     d60:	08 95       	ret

00000d62 <SPI_initSlave>:
/*
 * Description :
 * Initialize the SPI device as Slave.
 */
void SPI_initSlave(void)
{ 
     d62:	df 93       	push	r29
     d64:	cf 93       	push	r28
     d66:	cd b7       	in	r28, 0x3d	; 61
     d68:	de b7       	in	r29, 0x3e	; 62
	 * SS(PB4)   --> Input
	 * MOSI(PB5) --> Input
	 * MISO(PB6) --> Output
	 * SCK(PB7) --> Input
	 ********************************************/
	GPIO_setupPinDirection(PORTB_ID,PIN4_ID,PIN_INPUT);
     d6a:	81 e0       	ldi	r24, 0x01	; 1
     d6c:	64 e0       	ldi	r22, 0x04	; 4
     d6e:	40 e0       	ldi	r20, 0x00	; 0
     d70:	0e 94 16 0a 	call	0x142c	; 0x142c <GPIO_setupPinDirection>
	GPIO_setupPinDirection(PORTB_ID,PIN5_ID,PIN_INPUT);
     d74:	81 e0       	ldi	r24, 0x01	; 1
     d76:	65 e0       	ldi	r22, 0x05	; 5
     d78:	40 e0       	ldi	r20, 0x00	; 0
     d7a:	0e 94 16 0a 	call	0x142c	; 0x142c <GPIO_setupPinDirection>
	GPIO_setupPinDirection(PORTB_ID,PIN6_ID,PIN_OUTPUT);
     d7e:	81 e0       	ldi	r24, 0x01	; 1
     d80:	66 e0       	ldi	r22, 0x06	; 6
     d82:	41 e0       	ldi	r20, 0x01	; 1
     d84:	0e 94 16 0a 	call	0x142c	; 0x142c <GPIO_setupPinDirection>
	GPIO_setupPinDirection(PORTB_ID,PIN7_ID,PIN_INPUT);
     d88:	81 e0       	ldi	r24, 0x01	; 1
     d8a:	67 e0       	ldi	r22, 0x07	; 7
     d8c:	40 e0       	ldi	r20, 0x00	; 0
     d8e:	0e 94 16 0a 	call	0x142c	; 0x142c <GPIO_setupPinDirection>
	 * MSTR    = 0 Disable Master
	 * CPOL    = 0 SCK is low when idle
	 * CPHA    = 0 Sample Data with the raising edge
	 * SPR1:0  = 00 Choose SPI clock = Fosc/4
	 ***********************************************************************/
	SPCR = (1<<SPE);
     d92:	ed e2       	ldi	r30, 0x2D	; 45
     d94:	f0 e0       	ldi	r31, 0x00	; 0
     d96:	80 e4       	ldi	r24, 0x40	; 64
     d98:	80 83       	st	Z, r24

	/* Clear the SPI2X bit in SPSR to Choose SPI clock = Fosc/4 */
	SPSR &= ~(1<<SPI2X);
     d9a:	ae e2       	ldi	r26, 0x2E	; 46
     d9c:	b0 e0       	ldi	r27, 0x00	; 0
     d9e:	ee e2       	ldi	r30, 0x2E	; 46
     da0:	f0 e0       	ldi	r31, 0x00	; 0
     da2:	80 81       	ld	r24, Z
     da4:	8e 7f       	andi	r24, 0xFE	; 254
     da6:	8c 93       	st	X, r24
}
     da8:	cf 91       	pop	r28
     daa:	df 91       	pop	r29
     dac:	08 95       	ret

00000dae <SPI_sendReceiveByte>:
 * Description :
 * Send the required data through SPI to the other SPI device.
 * In the same time data will be received from the other device.
 */
uint8 SPI_sendReceiveByte(uint8 data)
{
     dae:	df 93       	push	r29
     db0:	cf 93       	push	r28
     db2:	0f 92       	push	r0
     db4:	cd b7       	in	r28, 0x3d	; 61
     db6:	de b7       	in	r29, 0x3e	; 62
     db8:	89 83       	std	Y+1, r24	; 0x01
	/* Initiate the communication and send data by SPI */
	SPDR = data;
     dba:	ef e2       	ldi	r30, 0x2F	; 47
     dbc:	f0 e0       	ldi	r31, 0x00	; 0
     dbe:	89 81       	ldd	r24, Y+1	; 0x01
     dc0:	80 83       	st	Z, r24

	/* Wait until SPI interrupt flag SPIF = 1 (data has been sent/received correctly) */
	while(BIT_IS_CLEAR(SPSR,SPIF)){}
     dc2:	ee e2       	ldi	r30, 0x2E	; 46
     dc4:	f0 e0       	ldi	r31, 0x00	; 0
     dc6:	80 81       	ld	r24, Z
     dc8:	88 23       	and	r24, r24
     dca:	dc f7       	brge	.-10     	; 0xdc2 <SPI_sendReceiveByte+0x14>

	/*
	 * Note: SPIF flag is cleared by first reading SPSR (with SPIF set) which is done in the previous step.
	 * and then accessing SPDR like the below line.
	 */
	return SPDR;
     dcc:	ef e2       	ldi	r30, 0x2F	; 47
     dce:	f0 e0       	ldi	r31, 0x00	; 0
     dd0:	80 81       	ld	r24, Z
}
     dd2:	0f 90       	pop	r0
     dd4:	cf 91       	pop	r28
     dd6:	df 91       	pop	r29
     dd8:	08 95       	ret

00000dda <SPI_sendString>:
/*
 * Description :
 * Send the required string through SPI to the other SPI device.
 */
void SPI_sendString(const uint8 *str)
{
     dda:	df 93       	push	r29
     ddc:	cf 93       	push	r28
     dde:	00 d0       	rcall	.+0      	; 0xde0 <SPI_sendString+0x6>
     de0:	00 d0       	rcall	.+0      	; 0xde2 <SPI_sendString+0x8>
     de2:	cd b7       	in	r28, 0x3d	; 61
     de4:	de b7       	in	r29, 0x3e	; 62
     de6:	9c 83       	std	Y+4, r25	; 0x04
     de8:	8b 83       	std	Y+3, r24	; 0x03
	uint8 i = 0;
     dea:	1a 82       	std	Y+2, r1	; 0x02
	uint8 received_data = 0;
     dec:	19 82       	std	Y+1, r1	; 0x01
     dee:	0f c0       	rjmp	.+30     	; 0xe0e <SPI_sendString+0x34>
	{
		/*
		 * received_data contains the received data from the other device.
		 * It is a dummy data variable as we just need to send the string to other device.
		 */
		received_data = SPI_sendReceiveByte(str[i]);
     df0:	8a 81       	ldd	r24, Y+2	; 0x02
     df2:	28 2f       	mov	r18, r24
     df4:	30 e0       	ldi	r19, 0x00	; 0
     df6:	8b 81       	ldd	r24, Y+3	; 0x03
     df8:	9c 81       	ldd	r25, Y+4	; 0x04
     dfa:	fc 01       	movw	r30, r24
     dfc:	e2 0f       	add	r30, r18
     dfe:	f3 1f       	adc	r31, r19
     e00:	80 81       	ld	r24, Z
     e02:	0e 94 d7 06 	call	0xdae	; 0xdae <SPI_sendReceiveByte>
     e06:	89 83       	std	Y+1, r24	; 0x01
		i++;
     e08:	8a 81       	ldd	r24, Y+2	; 0x02
     e0a:	8f 5f       	subi	r24, 0xFF	; 255
     e0c:	8a 83       	std	Y+2, r24	; 0x02
{
	uint8 i = 0;
	uint8 received_data = 0;

	/* Send the whole string */
	while(str[i] != '\0')
     e0e:	8a 81       	ldd	r24, Y+2	; 0x02
     e10:	28 2f       	mov	r18, r24
     e12:	30 e0       	ldi	r19, 0x00	; 0
     e14:	8b 81       	ldd	r24, Y+3	; 0x03
     e16:	9c 81       	ldd	r25, Y+4	; 0x04
     e18:	fc 01       	movw	r30, r24
     e1a:	e2 0f       	add	r30, r18
     e1c:	f3 1f       	adc	r31, r19
     e1e:	80 81       	ld	r24, Z
     e20:	88 23       	and	r24, r24
     e22:	31 f7       	brne	.-52     	; 0xdf0 <SPI_sendString+0x16>
		 * It is a dummy data variable as we just need to send the string to other device.
		 */
		received_data = SPI_sendReceiveByte(str[i]);
		i++;
	}
}
     e24:	0f 90       	pop	r0
     e26:	0f 90       	pop	r0
     e28:	0f 90       	pop	r0
     e2a:	0f 90       	pop	r0
     e2c:	cf 91       	pop	r28
     e2e:	df 91       	pop	r29
     e30:	08 95       	ret

00000e32 <SPI_receiveString>:
/*
 * Description :
 * Receive the required string until the '#' symbol through SPI from the other SPI device.
 */
void SPI_receiveString(uint8 *str)
{
     e32:	0f 93       	push	r16
     e34:	1f 93       	push	r17
     e36:	df 93       	push	r29
     e38:	cf 93       	push	r28
     e3a:	00 d0       	rcall	.+0      	; 0xe3c <SPI_receiveString+0xa>
     e3c:	0f 92       	push	r0
     e3e:	cd b7       	in	r28, 0x3d	; 61
     e40:	de b7       	in	r29, 0x3e	; 62
     e42:	9b 83       	std	Y+3, r25	; 0x03
     e44:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
     e46:	19 82       	std	Y+1, r1	; 0x01

	/* Receive the first byte */
	str[i] = SPI_sendReceiveByte(SPI_DEFAULT_DATA_VALUE);
     e48:	89 81       	ldd	r24, Y+1	; 0x01
     e4a:	28 2f       	mov	r18, r24
     e4c:	30 e0       	ldi	r19, 0x00	; 0
     e4e:	8a 81       	ldd	r24, Y+2	; 0x02
     e50:	9b 81       	ldd	r25, Y+3	; 0x03
     e52:	8c 01       	movw	r16, r24
     e54:	02 0f       	add	r16, r18
     e56:	13 1f       	adc	r17, r19
     e58:	8f ef       	ldi	r24, 0xFF	; 255
     e5a:	0e 94 d7 06 	call	0xdae	; 0xdae <SPI_sendReceiveByte>
     e5e:	f8 01       	movw	r30, r16
     e60:	80 83       	st	Z, r24
     e62:	10 c0       	rjmp	.+32     	; 0xe84 <SPI_receiveString+0x52>

	/* Receive the whole string until the '#' */
	while(str[i] != '#')
	{
		i++;
     e64:	89 81       	ldd	r24, Y+1	; 0x01
     e66:	8f 5f       	subi	r24, 0xFF	; 255
     e68:	89 83       	std	Y+1, r24	; 0x01
		str[i] = SPI_sendReceiveByte(SPI_DEFAULT_DATA_VALUE);
     e6a:	89 81       	ldd	r24, Y+1	; 0x01
     e6c:	28 2f       	mov	r18, r24
     e6e:	30 e0       	ldi	r19, 0x00	; 0
     e70:	8a 81       	ldd	r24, Y+2	; 0x02
     e72:	9b 81       	ldd	r25, Y+3	; 0x03
     e74:	8c 01       	movw	r16, r24
     e76:	02 0f       	add	r16, r18
     e78:	13 1f       	adc	r17, r19
     e7a:	8f ef       	ldi	r24, 0xFF	; 255
     e7c:	0e 94 d7 06 	call	0xdae	; 0xdae <SPI_sendReceiveByte>
     e80:	f8 01       	movw	r30, r16
     e82:	80 83       	st	Z, r24

	/* Receive the first byte */
	str[i] = SPI_sendReceiveByte(SPI_DEFAULT_DATA_VALUE);

	/* Receive the whole string until the '#' */
	while(str[i] != '#')
     e84:	89 81       	ldd	r24, Y+1	; 0x01
     e86:	28 2f       	mov	r18, r24
     e88:	30 e0       	ldi	r19, 0x00	; 0
     e8a:	8a 81       	ldd	r24, Y+2	; 0x02
     e8c:	9b 81       	ldd	r25, Y+3	; 0x03
     e8e:	fc 01       	movw	r30, r24
     e90:	e2 0f       	add	r30, r18
     e92:	f3 1f       	adc	r31, r19
     e94:	80 81       	ld	r24, Z
     e96:	83 32       	cpi	r24, 0x23	; 35
     e98:	29 f7       	brne	.-54     	; 0xe64 <SPI_receiveString+0x32>
		i++;
		str[i] = SPI_sendReceiveByte(SPI_DEFAULT_DATA_VALUE);
	}

	/* After receiving the whole string plus the '#', replace the '#' with '\0' */
	str[i] = '\0';
     e9a:	89 81       	ldd	r24, Y+1	; 0x01
     e9c:	28 2f       	mov	r18, r24
     e9e:	30 e0       	ldi	r19, 0x00	; 0
     ea0:	8a 81       	ldd	r24, Y+2	; 0x02
     ea2:	9b 81       	ldd	r25, Y+3	; 0x03
     ea4:	fc 01       	movw	r30, r24
     ea6:	e2 0f       	add	r30, r18
     ea8:	f3 1f       	adc	r31, r19
     eaa:	10 82       	st	Z, r1
}
     eac:	0f 90       	pop	r0
     eae:	0f 90       	pop	r0
     eb0:	0f 90       	pop	r0
     eb2:	cf 91       	pop	r28
     eb4:	df 91       	pop	r29
     eb6:	1f 91       	pop	r17
     eb8:	0f 91       	pop	r16
     eba:	08 95       	ret

00000ebc <GPIO_Init>:
 * Description :
 * configure every pin in the gpio.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_Init(const GPIO_ConfigType GPIO_ConfigPtr[])
{
     ebc:	df 93       	push	r29
     ebe:	cf 93       	push	r28
     ec0:	00 d0       	rcall	.+0      	; 0xec2 <GPIO_Init+0x6>
     ec2:	0f 92       	push	r0
     ec4:	cd b7       	in	r28, 0x3d	; 61
     ec6:	de b7       	in	r29, 0x3e	; 62
     ec8:	9b 83       	std	Y+3, r25	; 0x03
     eca:	8a 83       	std	Y+2, r24	; 0x02
    uint8 i = 0;
     ecc:	19 82       	std	Y+1, r1	; 0x01
     ece:	ca c0       	rjmp	.+404    	; 0x1064 <GPIO_Init+0x1a8>
    for (; i < TOTAL_PINS_NUM; ++i)
    {
	if(((GPIO_ConfigPtr[i].pin_num) >= NUM_OF_PINS_PER_PORT) || ((GPIO_ConfigPtr[i].port_num )>= NUM_OF_PORTS) )
     ed0:	89 81       	ldd	r24, Y+1	; 0x01
     ed2:	28 2f       	mov	r18, r24
     ed4:	30 e0       	ldi	r19, 0x00	; 0
     ed6:	c9 01       	movw	r24, r18
     ed8:	88 0f       	add	r24, r24
     eda:	99 1f       	adc	r25, r25
     edc:	88 0f       	add	r24, r24
     ede:	99 1f       	adc	r25, r25
     ee0:	28 0f       	add	r18, r24
     ee2:	39 1f       	adc	r19, r25
     ee4:	8a 81       	ldd	r24, Y+2	; 0x02
     ee6:	9b 81       	ldd	r25, Y+3	; 0x03
     ee8:	fc 01       	movw	r30, r24
     eea:	e2 0f       	add	r30, r18
     eec:	f3 1f       	adc	r31, r19
     eee:	81 81       	ldd	r24, Z+1	; 0x01
     ef0:	88 30       	cpi	r24, 0x08	; 8
     ef2:	08 f0       	brcs	.+2      	; 0xef6 <GPIO_Init+0x3a>
     ef4:	b4 c0       	rjmp	.+360    	; 0x105e <GPIO_Init+0x1a2>
     ef6:	89 81       	ldd	r24, Y+1	; 0x01
     ef8:	28 2f       	mov	r18, r24
     efa:	30 e0       	ldi	r19, 0x00	; 0
     efc:	c9 01       	movw	r24, r18
     efe:	88 0f       	add	r24, r24
     f00:	99 1f       	adc	r25, r25
     f02:	88 0f       	add	r24, r24
     f04:	99 1f       	adc	r25, r25
     f06:	28 0f       	add	r18, r24
     f08:	39 1f       	adc	r19, r25
     f0a:	8a 81       	ldd	r24, Y+2	; 0x02
     f0c:	9b 81       	ldd	r25, Y+3	; 0x03
     f0e:	fc 01       	movw	r30, r24
     f10:	e2 0f       	add	r30, r18
     f12:	f3 1f       	adc	r31, r19
     f14:	80 81       	ld	r24, Z
     f16:	84 30       	cpi	r24, 0x04	; 4
     f18:	08 f0       	brcs	.+2      	; 0xf1c <GPIO_Init+0x60>
     f1a:	a1 c0       	rjmp	.+322    	; 0x105e <GPIO_Init+0x1a2>
		/* Do Nothing */
	}
	else
	{

		GPIO_setupPinDirection(GPIO_ConfigPtr[i].port_num, GPIO_ConfigPtr[i].pin_num, GPIO_ConfigPtr[i].direction);
     f1c:	89 81       	ldd	r24, Y+1	; 0x01
     f1e:	28 2f       	mov	r18, r24
     f20:	30 e0       	ldi	r19, 0x00	; 0
     f22:	c9 01       	movw	r24, r18
     f24:	88 0f       	add	r24, r24
     f26:	99 1f       	adc	r25, r25
     f28:	88 0f       	add	r24, r24
     f2a:	99 1f       	adc	r25, r25
     f2c:	28 0f       	add	r18, r24
     f2e:	39 1f       	adc	r19, r25
     f30:	8a 81       	ldd	r24, Y+2	; 0x02
     f32:	9b 81       	ldd	r25, Y+3	; 0x03
     f34:	fc 01       	movw	r30, r24
     f36:	e2 0f       	add	r30, r18
     f38:	f3 1f       	adc	r31, r19
     f3a:	50 81       	ld	r21, Z
     f3c:	89 81       	ldd	r24, Y+1	; 0x01
     f3e:	28 2f       	mov	r18, r24
     f40:	30 e0       	ldi	r19, 0x00	; 0
     f42:	c9 01       	movw	r24, r18
     f44:	88 0f       	add	r24, r24
     f46:	99 1f       	adc	r25, r25
     f48:	88 0f       	add	r24, r24
     f4a:	99 1f       	adc	r25, r25
     f4c:	28 0f       	add	r18, r24
     f4e:	39 1f       	adc	r19, r25
     f50:	8a 81       	ldd	r24, Y+2	; 0x02
     f52:	9b 81       	ldd	r25, Y+3	; 0x03
     f54:	fc 01       	movw	r30, r24
     f56:	e2 0f       	add	r30, r18
     f58:	f3 1f       	adc	r31, r19
     f5a:	41 81       	ldd	r20, Z+1	; 0x01
     f5c:	89 81       	ldd	r24, Y+1	; 0x01
     f5e:	28 2f       	mov	r18, r24
     f60:	30 e0       	ldi	r19, 0x00	; 0
     f62:	c9 01       	movw	r24, r18
     f64:	88 0f       	add	r24, r24
     f66:	99 1f       	adc	r25, r25
     f68:	88 0f       	add	r24, r24
     f6a:	99 1f       	adc	r25, r25
     f6c:	28 0f       	add	r18, r24
     f6e:	39 1f       	adc	r19, r25
     f70:	8a 81       	ldd	r24, Y+2	; 0x02
     f72:	9b 81       	ldd	r25, Y+3	; 0x03
     f74:	fc 01       	movw	r30, r24
     f76:	e2 0f       	add	r30, r18
     f78:	f3 1f       	adc	r31, r19
     f7a:	92 81       	ldd	r25, Z+2	; 0x02
     f7c:	85 2f       	mov	r24, r21
     f7e:	64 2f       	mov	r22, r20
     f80:	49 2f       	mov	r20, r25
     f82:	0e 94 16 0a 	call	0x142c	; 0x142c <GPIO_setupPinDirection>

		GPIO_writePin(GPIO_ConfigPtr[i].port_num, GPIO_ConfigPtr[i].pin_num, GPIO_ConfigPtr[i].initial_value);
     f86:	89 81       	ldd	r24, Y+1	; 0x01
     f88:	28 2f       	mov	r18, r24
     f8a:	30 e0       	ldi	r19, 0x00	; 0
     f8c:	c9 01       	movw	r24, r18
     f8e:	88 0f       	add	r24, r24
     f90:	99 1f       	adc	r25, r25
     f92:	88 0f       	add	r24, r24
     f94:	99 1f       	adc	r25, r25
     f96:	28 0f       	add	r18, r24
     f98:	39 1f       	adc	r19, r25
     f9a:	8a 81       	ldd	r24, Y+2	; 0x02
     f9c:	9b 81       	ldd	r25, Y+3	; 0x03
     f9e:	fc 01       	movw	r30, r24
     fa0:	e2 0f       	add	r30, r18
     fa2:	f3 1f       	adc	r31, r19
     fa4:	50 81       	ld	r21, Z
     fa6:	89 81       	ldd	r24, Y+1	; 0x01
     fa8:	28 2f       	mov	r18, r24
     faa:	30 e0       	ldi	r19, 0x00	; 0
     fac:	c9 01       	movw	r24, r18
     fae:	88 0f       	add	r24, r24
     fb0:	99 1f       	adc	r25, r25
     fb2:	88 0f       	add	r24, r24
     fb4:	99 1f       	adc	r25, r25
     fb6:	28 0f       	add	r18, r24
     fb8:	39 1f       	adc	r19, r25
     fba:	8a 81       	ldd	r24, Y+2	; 0x02
     fbc:	9b 81       	ldd	r25, Y+3	; 0x03
     fbe:	fc 01       	movw	r30, r24
     fc0:	e2 0f       	add	r30, r18
     fc2:	f3 1f       	adc	r31, r19
     fc4:	41 81       	ldd	r20, Z+1	; 0x01
     fc6:	89 81       	ldd	r24, Y+1	; 0x01
     fc8:	28 2f       	mov	r18, r24
     fca:	30 e0       	ldi	r19, 0x00	; 0
     fcc:	c9 01       	movw	r24, r18
     fce:	88 0f       	add	r24, r24
     fd0:	99 1f       	adc	r25, r25
     fd2:	88 0f       	add	r24, r24
     fd4:	99 1f       	adc	r25, r25
     fd6:	28 0f       	add	r18, r24
     fd8:	39 1f       	adc	r19, r25
     fda:	8a 81       	ldd	r24, Y+2	; 0x02
     fdc:	9b 81       	ldd	r25, Y+3	; 0x03
     fde:	fc 01       	movw	r30, r24
     fe0:	e2 0f       	add	r30, r18
     fe2:	f3 1f       	adc	r31, r19
     fe4:	94 81       	ldd	r25, Z+4	; 0x04
     fe6:	85 2f       	mov	r24, r21
     fe8:	64 2f       	mov	r22, r20
     fea:	49 2f       	mov	r20, r25
     fec:	0e 94 01 0b 	call	0x1602	; 0x1602 <GPIO_writePin>


		if(GPIO_ConfigPtr[i].resistor == GPIO_PULL_UP)
     ff0:	89 81       	ldd	r24, Y+1	; 0x01
     ff2:	28 2f       	mov	r18, r24
     ff4:	30 e0       	ldi	r19, 0x00	; 0
     ff6:	c9 01       	movw	r24, r18
     ff8:	88 0f       	add	r24, r24
     ffa:	99 1f       	adc	r25, r25
     ffc:	88 0f       	add	r24, r24
     ffe:	99 1f       	adc	r25, r25
    1000:	28 0f       	add	r18, r24
    1002:	39 1f       	adc	r19, r25
    1004:	8a 81       	ldd	r24, Y+2	; 0x02
    1006:	9b 81       	ldd	r25, Y+3	; 0x03
    1008:	fc 01       	movw	r30, r24
    100a:	e2 0f       	add	r30, r18
    100c:	f3 1f       	adc	r31, r19
    100e:	83 81       	ldd	r24, Z+3	; 0x03
    1010:	81 30       	cpi	r24, 0x01	; 1
    1012:	29 f5       	brne	.+74     	; 0x105e <GPIO_Init+0x1a2>
		{
			GPIO_writePin(GPIO_ConfigPtr[i].port_num, GPIO_ConfigPtr[i].pin_num,LOGIC_HIGH);
    1014:	89 81       	ldd	r24, Y+1	; 0x01
    1016:	28 2f       	mov	r18, r24
    1018:	30 e0       	ldi	r19, 0x00	; 0
    101a:	c9 01       	movw	r24, r18
    101c:	88 0f       	add	r24, r24
    101e:	99 1f       	adc	r25, r25
    1020:	88 0f       	add	r24, r24
    1022:	99 1f       	adc	r25, r25
    1024:	28 0f       	add	r18, r24
    1026:	39 1f       	adc	r19, r25
    1028:	8a 81       	ldd	r24, Y+2	; 0x02
    102a:	9b 81       	ldd	r25, Y+3	; 0x03
    102c:	fc 01       	movw	r30, r24
    102e:	e2 0f       	add	r30, r18
    1030:	f3 1f       	adc	r31, r19
    1032:	40 81       	ld	r20, Z
    1034:	89 81       	ldd	r24, Y+1	; 0x01
    1036:	28 2f       	mov	r18, r24
    1038:	30 e0       	ldi	r19, 0x00	; 0
    103a:	c9 01       	movw	r24, r18
    103c:	88 0f       	add	r24, r24
    103e:	99 1f       	adc	r25, r25
    1040:	88 0f       	add	r24, r24
    1042:	99 1f       	adc	r25, r25
    1044:	28 0f       	add	r18, r24
    1046:	39 1f       	adc	r19, r25
    1048:	8a 81       	ldd	r24, Y+2	; 0x02
    104a:	9b 81       	ldd	r25, Y+3	; 0x03
    104c:	fc 01       	movw	r30, r24
    104e:	e2 0f       	add	r30, r18
    1050:	f3 1f       	adc	r31, r19
    1052:	91 81       	ldd	r25, Z+1	; 0x01
    1054:	84 2f       	mov	r24, r20
    1056:	69 2f       	mov	r22, r25
    1058:	41 e0       	ldi	r20, 0x01	; 1
    105a:	0e 94 01 0b 	call	0x1602	; 0x1602 <GPIO_writePin>
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_Init(const GPIO_ConfigType GPIO_ConfigPtr[])
{
    uint8 i = 0;
    for (; i < TOTAL_PINS_NUM; ++i)
    105e:	89 81       	ldd	r24, Y+1	; 0x01
    1060:	8f 5f       	subi	r24, 0xFF	; 255
    1062:	89 83       	std	Y+1, r24	; 0x01
    1064:	89 81       	ldd	r24, Y+1	; 0x01
    1066:	80 32       	cpi	r24, 0x20	; 32
    1068:	08 f4       	brcc	.+2      	; 0x106c <GPIO_Init+0x1b0>
    106a:	32 cf       	rjmp	.-412    	; 0xed0 <GPIO_Init+0x14>
		{

		}
	}
}
}
    106c:	0f 90       	pop	r0
    106e:	0f 90       	pop	r0
    1070:	0f 90       	pop	r0
    1072:	cf 91       	pop	r28
    1074:	df 91       	pop	r29
    1076:	08 95       	ret

00001078 <GPIO_ChannelGroupWrite>:
/*
 *  Description :
 *  write in a group of of pin
 */
void GPIO_ChannelGroupWrite(ChannelGroupType* ChannelID ,uint8 dataPtr[]){
    1078:	df 93       	push	r29
    107a:	cf 93       	push	r28
    107c:	cd b7       	in	r28, 0x3d	; 61
    107e:	de b7       	in	r29, 0x3e	; 62
    1080:	28 97       	sbiw	r28, 0x08	; 8
    1082:	0f b6       	in	r0, 0x3f	; 63
    1084:	f8 94       	cli
    1086:	de bf       	out	0x3e, r29	; 62
    1088:	0f be       	out	0x3f, r0	; 63
    108a:	cd bf       	out	0x3d, r28	; 61
    108c:	9e 83       	std	Y+6, r25	; 0x06
    108e:	8d 83       	std	Y+5, r24	; 0x05
    1090:	78 87       	std	Y+8, r23	; 0x08
    1092:	6f 83       	std	Y+7, r22	; 0x07
    uint8 i = 0;
    1094:	1c 82       	std	Y+4, r1	; 0x04
    uint8 id=0;
    1096:	1b 82       	std	Y+3, r1	; 0x03
    uint8 port_num=0;
    1098:	1a 82       	std	Y+2, r1	; 0x02
    uint8 pin_num=0;
    109a:	19 82       	std	Y+1, r1	; 0x01
    109c:	40 c0       	rjmp	.+128    	; 0x111e <GPIO_ChannelGroupWrite+0xa6>
	for(; i < ChannelID->no_of_channels; ++i)
	{
	    id= ChannelID->group_ids[i];
    109e:	8c 81       	ldd	r24, Y+4	; 0x04
    10a0:	28 2f       	mov	r18, r24
    10a2:	30 e0       	ldi	r19, 0x00	; 0
    10a4:	8d 81       	ldd	r24, Y+5	; 0x05
    10a6:	9e 81       	ldd	r25, Y+6	; 0x06
    10a8:	82 0f       	add	r24, r18
    10aa:	93 1f       	adc	r25, r19
    10ac:	fc 01       	movw	r30, r24
    10ae:	31 96       	adiw	r30, 0x01	; 1
    10b0:	80 81       	ld	r24, Z
    10b2:	8b 83       	std	Y+3, r24	; 0x03
	    port_num = GPIO_ConfigPin[id].port_num;
    10b4:	8b 81       	ldd	r24, Y+3	; 0x03
    10b6:	28 2f       	mov	r18, r24
    10b8:	30 e0       	ldi	r19, 0x00	; 0
    10ba:	c9 01       	movw	r24, r18
    10bc:	88 0f       	add	r24, r24
    10be:	99 1f       	adc	r25, r25
    10c0:	88 0f       	add	r24, r24
    10c2:	99 1f       	adc	r25, r25
    10c4:	82 0f       	add	r24, r18
    10c6:	93 1f       	adc	r25, r19
    10c8:	fc 01       	movw	r30, r24
    10ca:	e7 57       	subi	r30, 0x77	; 119
    10cc:	ff 4f       	sbci	r31, 0xFF	; 255
    10ce:	80 81       	ld	r24, Z
    10d0:	8a 83       	std	Y+2, r24	; 0x02
	    pin_num=GPIO_ConfigPin[id].pin_num;
    10d2:	8b 81       	ldd	r24, Y+3	; 0x03
    10d4:	28 2f       	mov	r18, r24
    10d6:	30 e0       	ldi	r19, 0x00	; 0
    10d8:	c9 01       	movw	r24, r18
    10da:	88 0f       	add	r24, r24
    10dc:	99 1f       	adc	r25, r25
    10de:	88 0f       	add	r24, r24
    10e0:	99 1f       	adc	r25, r25
    10e2:	82 0f       	add	r24, r18
    10e4:	93 1f       	adc	r25, r19
    10e6:	fc 01       	movw	r30, r24
    10e8:	e6 57       	subi	r30, 0x76	; 118
    10ea:	ff 4f       	sbci	r31, 0xFF	; 255
    10ec:	80 81       	ld	r24, Z
    10ee:	89 83       	std	Y+1, r24	; 0x01

		if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS) )
    10f0:	89 81       	ldd	r24, Y+1	; 0x01
    10f2:	88 30       	cpi	r24, 0x08	; 8
    10f4:	88 f4       	brcc	.+34     	; 0x1118 <GPIO_ChannelGroupWrite+0xa0>
    10f6:	8a 81       	ldd	r24, Y+2	; 0x02
    10f8:	84 30       	cpi	r24, 0x04	; 4
    10fa:	70 f4       	brcc	.+28     	; 0x1118 <GPIO_ChannelGroupWrite+0xa0>
		}
		else
		{


			GPIO_writePin(port_num, pin_num,dataPtr[i]);
    10fc:	8c 81       	ldd	r24, Y+4	; 0x04
    10fe:	28 2f       	mov	r18, r24
    1100:	30 e0       	ldi	r19, 0x00	; 0
    1102:	8f 81       	ldd	r24, Y+7	; 0x07
    1104:	98 85       	ldd	r25, Y+8	; 0x08
    1106:	fc 01       	movw	r30, r24
    1108:	e2 0f       	add	r30, r18
    110a:	f3 1f       	adc	r31, r19
    110c:	90 81       	ld	r25, Z
    110e:	8a 81       	ldd	r24, Y+2	; 0x02
    1110:	69 81       	ldd	r22, Y+1	; 0x01
    1112:	49 2f       	mov	r20, r25
    1114:	0e 94 01 0b 	call	0x1602	; 0x1602 <GPIO_writePin>
void GPIO_ChannelGroupWrite(ChannelGroupType* ChannelID ,uint8 dataPtr[]){
    uint8 i = 0;
    uint8 id=0;
    uint8 port_num=0;
    uint8 pin_num=0;
	for(; i < ChannelID->no_of_channels; ++i)
    1118:	8c 81       	ldd	r24, Y+4	; 0x04
    111a:	8f 5f       	subi	r24, 0xFF	; 255
    111c:	8c 83       	std	Y+4, r24	; 0x04
    111e:	ed 81       	ldd	r30, Y+5	; 0x05
    1120:	fe 81       	ldd	r31, Y+6	; 0x06
    1122:	90 81       	ld	r25, Z
    1124:	8c 81       	ldd	r24, Y+4	; 0x04
    1126:	89 17       	cp	r24, r25
    1128:	08 f4       	brcc	.+2      	; 0x112c <GPIO_ChannelGroupWrite+0xb4>
    112a:	b9 cf       	rjmp	.-142    	; 0x109e <GPIO_ChannelGroupWrite+0x26>

			GPIO_writePin(port_num, pin_num,dataPtr[i]);

		}
	}
}
    112c:	28 96       	adiw	r28, 0x08	; 8
    112e:	0f b6       	in	r0, 0x3f	; 63
    1130:	f8 94       	cli
    1132:	de bf       	out	0x3e, r29	; 62
    1134:	0f be       	out	0x3f, r0	; 63
    1136:	cd bf       	out	0x3d, r28	; 61
    1138:	cf 91       	pop	r28
    113a:	df 91       	pop	r29
    113c:	08 95       	ret

0000113e <GPIO_ChannelGroupRead>:
/*
 *  Description :
 *  read in a group of of pin
 */
void GPIO_ChannelGroupRead(ChannelGroupType* ChannelID,uint8 dataPtr[]){
    113e:	0f 93       	push	r16
    1140:	1f 93       	push	r17
    1142:	df 93       	push	r29
    1144:	cf 93       	push	r28
    1146:	cd b7       	in	r28, 0x3d	; 61
    1148:	de b7       	in	r29, 0x3e	; 62
    114a:	a4 97       	sbiw	r28, 0x24	; 36
    114c:	0f b6       	in	r0, 0x3f	; 63
    114e:	f8 94       	cli
    1150:	de bf       	out	0x3e, r29	; 62
    1152:	0f be       	out	0x3f, r0	; 63
    1154:	cd bf       	out	0x3d, r28	; 61
    1156:	9a a3       	std	Y+34, r25	; 0x22
    1158:	89 a3       	std	Y+33, r24	; 0x21
    115a:	7c a3       	std	Y+36, r23	; 0x24
    115c:	6b a3       	std	Y+35, r22	; 0x23
    uint8 i = 0;
    115e:	18 a2       	std	Y+32, r1	; 0x20
    uint8 id=0;
    1160:	1f 8e       	std	Y+31, r1	; 0x1f
    uint8 port_num=0;
    1162:	1e 8e       	std	Y+30, r1	; 0x1e
    uint8 pin_num=0;
    1164:	1d 8e       	std	Y+29, r1	; 0x1d
    1166:	50 c1       	rjmp	.+672    	; 0x1408 <GPIO_ChannelGroupRead+0x2ca>
	for(; i < ChannelID->no_of_channels; ++i)
	{
		id= ChannelID->group_ids[i];
    1168:	88 a1       	ldd	r24, Y+32	; 0x20
    116a:	28 2f       	mov	r18, r24
    116c:	30 e0       	ldi	r19, 0x00	; 0
    116e:	89 a1       	ldd	r24, Y+33	; 0x21
    1170:	9a a1       	ldd	r25, Y+34	; 0x22
    1172:	82 0f       	add	r24, r18
    1174:	93 1f       	adc	r25, r19
    1176:	fc 01       	movw	r30, r24
    1178:	31 96       	adiw	r30, 0x01	; 1
    117a:	80 81       	ld	r24, Z
    117c:	8f 8f       	std	Y+31, r24	; 0x1f
		port_num = GPIO_ConfigPin[id].port_num;
    117e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1180:	28 2f       	mov	r18, r24
    1182:	30 e0       	ldi	r19, 0x00	; 0
    1184:	c9 01       	movw	r24, r18
    1186:	88 0f       	add	r24, r24
    1188:	99 1f       	adc	r25, r25
    118a:	88 0f       	add	r24, r24
    118c:	99 1f       	adc	r25, r25
    118e:	82 0f       	add	r24, r18
    1190:	93 1f       	adc	r25, r19
    1192:	fc 01       	movw	r30, r24
    1194:	e7 57       	subi	r30, 0x77	; 119
    1196:	ff 4f       	sbci	r31, 0xFF	; 255
    1198:	80 81       	ld	r24, Z
    119a:	8e 8f       	std	Y+30, r24	; 0x1e
		pin_num=GPIO_ConfigPin[id].pin_num;
    119c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    119e:	28 2f       	mov	r18, r24
    11a0:	30 e0       	ldi	r19, 0x00	; 0
    11a2:	c9 01       	movw	r24, r18
    11a4:	88 0f       	add	r24, r24
    11a6:	99 1f       	adc	r25, r25
    11a8:	88 0f       	add	r24, r24
    11aa:	99 1f       	adc	r25, r25
    11ac:	82 0f       	add	r24, r18
    11ae:	93 1f       	adc	r25, r19
    11b0:	fc 01       	movw	r30, r24
    11b2:	e6 57       	subi	r30, 0x76	; 118
    11b4:	ff 4f       	sbci	r31, 0xFF	; 255
    11b6:	80 81       	ld	r24, Z
    11b8:	8d 8f       	std	Y+29, r24	; 0x1d

		if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS) )
    11ba:	8d 8d       	ldd	r24, Y+29	; 0x1d
    11bc:	88 30       	cpi	r24, 0x08	; 8
    11be:	08 f0       	brcs	.+2      	; 0x11c2 <GPIO_ChannelGroupRead+0x84>
    11c0:	20 c1       	rjmp	.+576    	; 0x1402 <GPIO_ChannelGroupRead+0x2c4>
    11c2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    11c4:	84 30       	cpi	r24, 0x04	; 4
    11c6:	08 f0       	brcs	.+2      	; 0x11ca <GPIO_ChannelGroupRead+0x8c>
    11c8:	1c c1       	rjmp	.+568    	; 0x1402 <GPIO_ChannelGroupRead+0x2c4>
			/* Do Nothing */
		}
		else
		{

			if(GPIO_readPin(port_num, pin_num) == LOGIC_HIGH)
    11ca:	8e 8d       	ldd	r24, Y+30	; 0x1e
    11cc:	6d 8d       	ldd	r22, Y+29	; 0x1d
    11ce:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <GPIO_readPin>
    11d2:	81 30       	cpi	r24, 0x01	; 1
    11d4:	09 f0       	breq	.+2      	; 0x11d8 <GPIO_ChannelGroupRead+0x9a>
    11d6:	88 c0       	rjmp	.+272    	; 0x12e8 <GPIO_ChannelGroupRead+0x1aa>
    11d8:	80 e0       	ldi	r24, 0x00	; 0
    11da:	90 e0       	ldi	r25, 0x00	; 0
    11dc:	a0 ef       	ldi	r26, 0xF0	; 240
    11de:	b1 e4       	ldi	r27, 0x41	; 65
    11e0:	89 8f       	std	Y+25, r24	; 0x19
    11e2:	9a 8f       	std	Y+26, r25	; 0x1a
    11e4:	ab 8f       	std	Y+27, r26	; 0x1b
    11e6:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    11e8:	69 8d       	ldd	r22, Y+25	; 0x19
    11ea:	7a 8d       	ldd	r23, Y+26	; 0x1a
    11ec:	8b 8d       	ldd	r24, Y+27	; 0x1b
    11ee:	9c 8d       	ldd	r25, Y+28	; 0x1c
    11f0:	20 e0       	ldi	r18, 0x00	; 0
    11f2:	30 e0       	ldi	r19, 0x00	; 0
    11f4:	4a ef       	ldi	r20, 0xFA	; 250
    11f6:	54 e4       	ldi	r21, 0x44	; 68
    11f8:	0e 94 1d 02 	call	0x43a	; 0x43a <__mulsf3>
    11fc:	dc 01       	movw	r26, r24
    11fe:	cb 01       	movw	r24, r22
    1200:	8d 8b       	std	Y+21, r24	; 0x15
    1202:	9e 8b       	std	Y+22, r25	; 0x16
    1204:	af 8b       	std	Y+23, r26	; 0x17
    1206:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1208:	6d 89       	ldd	r22, Y+21	; 0x15
    120a:	7e 89       	ldd	r23, Y+22	; 0x16
    120c:	8f 89       	ldd	r24, Y+23	; 0x17
    120e:	98 8d       	ldd	r25, Y+24	; 0x18
    1210:	20 e0       	ldi	r18, 0x00	; 0
    1212:	30 e0       	ldi	r19, 0x00	; 0
    1214:	40 e8       	ldi	r20, 0x80	; 128
    1216:	5f e3       	ldi	r21, 0x3F	; 63
    1218:	0e 94 77 03 	call	0x6ee	; 0x6ee <__ltsf2>
    121c:	88 23       	and	r24, r24
    121e:	2c f4       	brge	.+10     	; 0x122a <GPIO_ChannelGroupRead+0xec>
		__ticks = 1;
    1220:	81 e0       	ldi	r24, 0x01	; 1
    1222:	90 e0       	ldi	r25, 0x00	; 0
    1224:	9c 8b       	std	Y+20, r25	; 0x14
    1226:	8b 8b       	std	Y+19, r24	; 0x13
    1228:	3f c0       	rjmp	.+126    	; 0x12a8 <GPIO_ChannelGroupRead+0x16a>
	else if (__tmp > 65535)
    122a:	6d 89       	ldd	r22, Y+21	; 0x15
    122c:	7e 89       	ldd	r23, Y+22	; 0x16
    122e:	8f 89       	ldd	r24, Y+23	; 0x17
    1230:	98 8d       	ldd	r25, Y+24	; 0x18
    1232:	20 e0       	ldi	r18, 0x00	; 0
    1234:	3f ef       	ldi	r19, 0xFF	; 255
    1236:	4f e7       	ldi	r20, 0x7F	; 127
    1238:	57 e4       	ldi	r21, 0x47	; 71
    123a:	0e 94 17 03 	call	0x62e	; 0x62e <__gtsf2>
    123e:	18 16       	cp	r1, r24
    1240:	4c f5       	brge	.+82     	; 0x1294 <GPIO_ChannelGroupRead+0x156>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1242:	69 8d       	ldd	r22, Y+25	; 0x19
    1244:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1246:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1248:	9c 8d       	ldd	r25, Y+28	; 0x1c
    124a:	20 e0       	ldi	r18, 0x00	; 0
    124c:	30 e0       	ldi	r19, 0x00	; 0
    124e:	40 e2       	ldi	r20, 0x20	; 32
    1250:	51 e4       	ldi	r21, 0x41	; 65
    1252:	0e 94 1d 02 	call	0x43a	; 0x43a <__mulsf3>
    1256:	dc 01       	movw	r26, r24
    1258:	cb 01       	movw	r24, r22
    125a:	bc 01       	movw	r22, r24
    125c:	cd 01       	movw	r24, r26
    125e:	0e 94 47 00 	call	0x8e	; 0x8e <__fixunssfsi>
    1262:	dc 01       	movw	r26, r24
    1264:	cb 01       	movw	r24, r22
    1266:	9c 8b       	std	Y+20, r25	; 0x14
    1268:	8b 8b       	std	Y+19, r24	; 0x13
    126a:	0f c0       	rjmp	.+30     	; 0x128a <GPIO_ChannelGroupRead+0x14c>
    126c:	88 ec       	ldi	r24, 0xC8	; 200
    126e:	90 e0       	ldi	r25, 0x00	; 0
    1270:	9a 8b       	std	Y+18, r25	; 0x12
    1272:	89 8b       	std	Y+17, r24	; 0x11
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1274:	89 89       	ldd	r24, Y+17	; 0x11
    1276:	9a 89       	ldd	r25, Y+18	; 0x12
    1278:	01 97       	sbiw	r24, 0x01	; 1
    127a:	f1 f7       	brne	.-4      	; 0x1278 <GPIO_ChannelGroupRead+0x13a>
    127c:	9a 8b       	std	Y+18, r25	; 0x12
    127e:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1280:	8b 89       	ldd	r24, Y+19	; 0x13
    1282:	9c 89       	ldd	r25, Y+20	; 0x14
    1284:	01 97       	sbiw	r24, 0x01	; 1
    1286:	9c 8b       	std	Y+20, r25	; 0x14
    1288:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    128a:	8b 89       	ldd	r24, Y+19	; 0x13
    128c:	9c 89       	ldd	r25, Y+20	; 0x14
    128e:	00 97       	sbiw	r24, 0x00	; 0
    1290:	69 f7       	brne	.-38     	; 0x126c <GPIO_ChannelGroupRead+0x12e>
    1292:	14 c0       	rjmp	.+40     	; 0x12bc <GPIO_ChannelGroupRead+0x17e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1294:	6d 89       	ldd	r22, Y+21	; 0x15
    1296:	7e 89       	ldd	r23, Y+22	; 0x16
    1298:	8f 89       	ldd	r24, Y+23	; 0x17
    129a:	98 8d       	ldd	r25, Y+24	; 0x18
    129c:	0e 94 47 00 	call	0x8e	; 0x8e <__fixunssfsi>
    12a0:	dc 01       	movw	r26, r24
    12a2:	cb 01       	movw	r24, r22
    12a4:	9c 8b       	std	Y+20, r25	; 0x14
    12a6:	8b 8b       	std	Y+19, r24	; 0x13
    12a8:	8b 89       	ldd	r24, Y+19	; 0x13
    12aa:	9c 89       	ldd	r25, Y+20	; 0x14
    12ac:	98 8b       	std	Y+16, r25	; 0x10
    12ae:	8f 87       	std	Y+15, r24	; 0x0f
    12b0:	8f 85       	ldd	r24, Y+15	; 0x0f
    12b2:	98 89       	ldd	r25, Y+16	; 0x10
    12b4:	01 97       	sbiw	r24, 0x01	; 1
    12b6:	f1 f7       	brne	.-4      	; 0x12b4 <GPIO_ChannelGroupRead+0x176>
    12b8:	98 8b       	std	Y+16, r25	; 0x10
    12ba:	8f 87       	std	Y+15, r24	; 0x0f
			{
				_delay_ms((double)30);
				if(GPIO_readPin(port_num, pin_num) == LOGIC_HIGH)
    12bc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    12be:	6d 8d       	ldd	r22, Y+29	; 0x1d
    12c0:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <GPIO_readPin>
    12c4:	81 30       	cpi	r24, 0x01	; 1
    12c6:	09 f0       	breq	.+2      	; 0x12ca <GPIO_ChannelGroupRead+0x18c>
    12c8:	9c c0       	rjmp	.+312    	; 0x1402 <GPIO_ChannelGroupRead+0x2c4>
				{
				dataPtr[i] = GPIO_readPin(port_num, pin_num);
    12ca:	88 a1       	ldd	r24, Y+32	; 0x20
    12cc:	28 2f       	mov	r18, r24
    12ce:	30 e0       	ldi	r19, 0x00	; 0
    12d0:	8b a1       	ldd	r24, Y+35	; 0x23
    12d2:	9c a1       	ldd	r25, Y+36	; 0x24
    12d4:	8c 01       	movw	r16, r24
    12d6:	02 0f       	add	r16, r18
    12d8:	13 1f       	adc	r17, r19
    12da:	8e 8d       	ldd	r24, Y+30	; 0x1e
    12dc:	6d 8d       	ldd	r22, Y+29	; 0x1d
    12de:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <GPIO_readPin>
    12e2:	f8 01       	movw	r30, r16
    12e4:	80 83       	st	Z, r24
    12e6:	8d c0       	rjmp	.+282    	; 0x1402 <GPIO_ChannelGroupRead+0x2c4>
				}
			}
			else if(GPIO_readPin(port_num, pin_num) == LOGIC_LOW)
    12e8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    12ea:	6d 8d       	ldd	r22, Y+29	; 0x1d
    12ec:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <GPIO_readPin>
    12f0:	88 23       	and	r24, r24
    12f2:	09 f0       	breq	.+2      	; 0x12f6 <GPIO_ChannelGroupRead+0x1b8>
    12f4:	86 c0       	rjmp	.+268    	; 0x1402 <GPIO_ChannelGroupRead+0x2c4>
    12f6:	80 e0       	ldi	r24, 0x00	; 0
    12f8:	90 e0       	ldi	r25, 0x00	; 0
    12fa:	a0 ef       	ldi	r26, 0xF0	; 240
    12fc:	b1 e4       	ldi	r27, 0x41	; 65
    12fe:	8b 87       	std	Y+11, r24	; 0x0b
    1300:	9c 87       	std	Y+12, r25	; 0x0c
    1302:	ad 87       	std	Y+13, r26	; 0x0d
    1304:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1306:	6b 85       	ldd	r22, Y+11	; 0x0b
    1308:	7c 85       	ldd	r23, Y+12	; 0x0c
    130a:	8d 85       	ldd	r24, Y+13	; 0x0d
    130c:	9e 85       	ldd	r25, Y+14	; 0x0e
    130e:	20 e0       	ldi	r18, 0x00	; 0
    1310:	30 e0       	ldi	r19, 0x00	; 0
    1312:	4a ef       	ldi	r20, 0xFA	; 250
    1314:	54 e4       	ldi	r21, 0x44	; 68
    1316:	0e 94 1d 02 	call	0x43a	; 0x43a <__mulsf3>
    131a:	dc 01       	movw	r26, r24
    131c:	cb 01       	movw	r24, r22
    131e:	8f 83       	std	Y+7, r24	; 0x07
    1320:	98 87       	std	Y+8, r25	; 0x08
    1322:	a9 87       	std	Y+9, r26	; 0x09
    1324:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1326:	6f 81       	ldd	r22, Y+7	; 0x07
    1328:	78 85       	ldd	r23, Y+8	; 0x08
    132a:	89 85       	ldd	r24, Y+9	; 0x09
    132c:	9a 85       	ldd	r25, Y+10	; 0x0a
    132e:	20 e0       	ldi	r18, 0x00	; 0
    1330:	30 e0       	ldi	r19, 0x00	; 0
    1332:	40 e8       	ldi	r20, 0x80	; 128
    1334:	5f e3       	ldi	r21, 0x3F	; 63
    1336:	0e 94 77 03 	call	0x6ee	; 0x6ee <__ltsf2>
    133a:	88 23       	and	r24, r24
    133c:	2c f4       	brge	.+10     	; 0x1348 <GPIO_ChannelGroupRead+0x20a>
		__ticks = 1;
    133e:	81 e0       	ldi	r24, 0x01	; 1
    1340:	90 e0       	ldi	r25, 0x00	; 0
    1342:	9e 83       	std	Y+6, r25	; 0x06
    1344:	8d 83       	std	Y+5, r24	; 0x05
    1346:	3f c0       	rjmp	.+126    	; 0x13c6 <GPIO_ChannelGroupRead+0x288>
	else if (__tmp > 65535)
    1348:	6f 81       	ldd	r22, Y+7	; 0x07
    134a:	78 85       	ldd	r23, Y+8	; 0x08
    134c:	89 85       	ldd	r24, Y+9	; 0x09
    134e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1350:	20 e0       	ldi	r18, 0x00	; 0
    1352:	3f ef       	ldi	r19, 0xFF	; 255
    1354:	4f e7       	ldi	r20, 0x7F	; 127
    1356:	57 e4       	ldi	r21, 0x47	; 71
    1358:	0e 94 17 03 	call	0x62e	; 0x62e <__gtsf2>
    135c:	18 16       	cp	r1, r24
    135e:	4c f5       	brge	.+82     	; 0x13b2 <GPIO_ChannelGroupRead+0x274>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1360:	6b 85       	ldd	r22, Y+11	; 0x0b
    1362:	7c 85       	ldd	r23, Y+12	; 0x0c
    1364:	8d 85       	ldd	r24, Y+13	; 0x0d
    1366:	9e 85       	ldd	r25, Y+14	; 0x0e
    1368:	20 e0       	ldi	r18, 0x00	; 0
    136a:	30 e0       	ldi	r19, 0x00	; 0
    136c:	40 e2       	ldi	r20, 0x20	; 32
    136e:	51 e4       	ldi	r21, 0x41	; 65
    1370:	0e 94 1d 02 	call	0x43a	; 0x43a <__mulsf3>
    1374:	dc 01       	movw	r26, r24
    1376:	cb 01       	movw	r24, r22
    1378:	bc 01       	movw	r22, r24
    137a:	cd 01       	movw	r24, r26
    137c:	0e 94 47 00 	call	0x8e	; 0x8e <__fixunssfsi>
    1380:	dc 01       	movw	r26, r24
    1382:	cb 01       	movw	r24, r22
    1384:	9e 83       	std	Y+6, r25	; 0x06
    1386:	8d 83       	std	Y+5, r24	; 0x05
    1388:	0f c0       	rjmp	.+30     	; 0x13a8 <GPIO_ChannelGroupRead+0x26a>
    138a:	88 ec       	ldi	r24, 0xC8	; 200
    138c:	90 e0       	ldi	r25, 0x00	; 0
    138e:	9c 83       	std	Y+4, r25	; 0x04
    1390:	8b 83       	std	Y+3, r24	; 0x03
    1392:	8b 81       	ldd	r24, Y+3	; 0x03
    1394:	9c 81       	ldd	r25, Y+4	; 0x04
    1396:	01 97       	sbiw	r24, 0x01	; 1
    1398:	f1 f7       	brne	.-4      	; 0x1396 <GPIO_ChannelGroupRead+0x258>
    139a:	9c 83       	std	Y+4, r25	; 0x04
    139c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    139e:	8d 81       	ldd	r24, Y+5	; 0x05
    13a0:	9e 81       	ldd	r25, Y+6	; 0x06
    13a2:	01 97       	sbiw	r24, 0x01	; 1
    13a4:	9e 83       	std	Y+6, r25	; 0x06
    13a6:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    13a8:	8d 81       	ldd	r24, Y+5	; 0x05
    13aa:	9e 81       	ldd	r25, Y+6	; 0x06
    13ac:	00 97       	sbiw	r24, 0x00	; 0
    13ae:	69 f7       	brne	.-38     	; 0x138a <GPIO_ChannelGroupRead+0x24c>
    13b0:	14 c0       	rjmp	.+40     	; 0x13da <GPIO_ChannelGroupRead+0x29c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    13b2:	6f 81       	ldd	r22, Y+7	; 0x07
    13b4:	78 85       	ldd	r23, Y+8	; 0x08
    13b6:	89 85       	ldd	r24, Y+9	; 0x09
    13b8:	9a 85       	ldd	r25, Y+10	; 0x0a
    13ba:	0e 94 47 00 	call	0x8e	; 0x8e <__fixunssfsi>
    13be:	dc 01       	movw	r26, r24
    13c0:	cb 01       	movw	r24, r22
    13c2:	9e 83       	std	Y+6, r25	; 0x06
    13c4:	8d 83       	std	Y+5, r24	; 0x05
    13c6:	8d 81       	ldd	r24, Y+5	; 0x05
    13c8:	9e 81       	ldd	r25, Y+6	; 0x06
    13ca:	9a 83       	std	Y+2, r25	; 0x02
    13cc:	89 83       	std	Y+1, r24	; 0x01
    13ce:	89 81       	ldd	r24, Y+1	; 0x01
    13d0:	9a 81       	ldd	r25, Y+2	; 0x02
    13d2:	01 97       	sbiw	r24, 0x01	; 1
    13d4:	f1 f7       	brne	.-4      	; 0x13d2 <GPIO_ChannelGroupRead+0x294>
    13d6:	9a 83       	std	Y+2, r25	; 0x02
    13d8:	89 83       	std	Y+1, r24	; 0x01
			{
				_delay_ms((double)30);
				if(GPIO_readPin(port_num, pin_num) == LOGIC_LOW)
    13da:	8e 8d       	ldd	r24, Y+30	; 0x1e
    13dc:	6d 8d       	ldd	r22, Y+29	; 0x1d
    13de:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <GPIO_readPin>
    13e2:	88 23       	and	r24, r24
    13e4:	71 f4       	brne	.+28     	; 0x1402 <GPIO_ChannelGroupRead+0x2c4>
				{
				dataPtr[i] = GPIO_readPin(port_num, pin_num);
    13e6:	88 a1       	ldd	r24, Y+32	; 0x20
    13e8:	28 2f       	mov	r18, r24
    13ea:	30 e0       	ldi	r19, 0x00	; 0
    13ec:	8b a1       	ldd	r24, Y+35	; 0x23
    13ee:	9c a1       	ldd	r25, Y+36	; 0x24
    13f0:	8c 01       	movw	r16, r24
    13f2:	02 0f       	add	r16, r18
    13f4:	13 1f       	adc	r17, r19
    13f6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    13f8:	6d 8d       	ldd	r22, Y+29	; 0x1d
    13fa:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <GPIO_readPin>
    13fe:	f8 01       	movw	r30, r16
    1400:	80 83       	st	Z, r24
void GPIO_ChannelGroupRead(ChannelGroupType* ChannelID,uint8 dataPtr[]){
    uint8 i = 0;
    uint8 id=0;
    uint8 port_num=0;
    uint8 pin_num=0;
	for(; i < ChannelID->no_of_channels; ++i)
    1402:	88 a1       	ldd	r24, Y+32	; 0x20
    1404:	8f 5f       	subi	r24, 0xFF	; 255
    1406:	88 a3       	std	Y+32, r24	; 0x20
    1408:	e9 a1       	ldd	r30, Y+33	; 0x21
    140a:	fa a1       	ldd	r31, Y+34	; 0x22
    140c:	90 81       	ld	r25, Z
    140e:	88 a1       	ldd	r24, Y+32	; 0x20
    1410:	89 17       	cp	r24, r25
    1412:	08 f4       	brcc	.+2      	; 0x1416 <GPIO_ChannelGroupRead+0x2d8>
    1414:	a9 ce       	rjmp	.-686    	; 0x1168 <GPIO_ChannelGroupRead+0x2a>

			}

		}
	}
}
    1416:	a4 96       	adiw	r28, 0x24	; 36
    1418:	0f b6       	in	r0, 0x3f	; 63
    141a:	f8 94       	cli
    141c:	de bf       	out	0x3e, r29	; 62
    141e:	0f be       	out	0x3f, r0	; 63
    1420:	cd bf       	out	0x3d, r28	; 61
    1422:	cf 91       	pop	r28
    1424:	df 91       	pop	r29
    1426:	1f 91       	pop	r17
    1428:	0f 91       	pop	r16
    142a:	08 95       	ret

0000142c <GPIO_setupPinDirection>:
 * Description :
 * Setup the direction of the required pin input/output.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_setupPinDirection(uint8 port_num, uint8 pin_num, GPIO_PinDirectionType direction)
{
    142c:	df 93       	push	r29
    142e:	cf 93       	push	r28
    1430:	00 d0       	rcall	.+0      	; 0x1432 <GPIO_setupPinDirection+0x6>
    1432:	00 d0       	rcall	.+0      	; 0x1434 <GPIO_setupPinDirection+0x8>
    1434:	0f 92       	push	r0
    1436:	cd b7       	in	r28, 0x3d	; 61
    1438:	de b7       	in	r29, 0x3e	; 62
    143a:	89 83       	std	Y+1, r24	; 0x01
    143c:	6a 83       	std	Y+2, r22	; 0x02
    143e:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    1440:	8a 81       	ldd	r24, Y+2	; 0x02
    1442:	88 30       	cpi	r24, 0x08	; 8
    1444:	08 f0       	brcs	.+2      	; 0x1448 <GPIO_setupPinDirection+0x1c>
    1446:	d5 c0       	rjmp	.+426    	; 0x15f2 <GPIO_setupPinDirection+0x1c6>
    1448:	89 81       	ldd	r24, Y+1	; 0x01
    144a:	84 30       	cpi	r24, 0x04	; 4
    144c:	08 f0       	brcs	.+2      	; 0x1450 <GPIO_setupPinDirection+0x24>
    144e:	d1 c0       	rjmp	.+418    	; 0x15f2 <GPIO_setupPinDirection+0x1c6>
		/* Do Nothing */
	}
	else
	{
		/* Setup the pin direction as required */
		switch(port_num)
    1450:	89 81       	ldd	r24, Y+1	; 0x01
    1452:	28 2f       	mov	r18, r24
    1454:	30 e0       	ldi	r19, 0x00	; 0
    1456:	3d 83       	std	Y+5, r19	; 0x05
    1458:	2c 83       	std	Y+4, r18	; 0x04
    145a:	8c 81       	ldd	r24, Y+4	; 0x04
    145c:	9d 81       	ldd	r25, Y+5	; 0x05
    145e:	81 30       	cpi	r24, 0x01	; 1
    1460:	91 05       	cpc	r25, r1
    1462:	09 f4       	brne	.+2      	; 0x1466 <GPIO_setupPinDirection+0x3a>
    1464:	43 c0       	rjmp	.+134    	; 0x14ec <GPIO_setupPinDirection+0xc0>
    1466:	2c 81       	ldd	r18, Y+4	; 0x04
    1468:	3d 81       	ldd	r19, Y+5	; 0x05
    146a:	22 30       	cpi	r18, 0x02	; 2
    146c:	31 05       	cpc	r19, r1
    146e:	2c f4       	brge	.+10     	; 0x147a <GPIO_setupPinDirection+0x4e>
    1470:	8c 81       	ldd	r24, Y+4	; 0x04
    1472:	9d 81       	ldd	r25, Y+5	; 0x05
    1474:	00 97       	sbiw	r24, 0x00	; 0
    1476:	71 f0       	breq	.+28     	; 0x1494 <GPIO_setupPinDirection+0x68>
    1478:	bc c0       	rjmp	.+376    	; 0x15f2 <GPIO_setupPinDirection+0x1c6>
    147a:	2c 81       	ldd	r18, Y+4	; 0x04
    147c:	3d 81       	ldd	r19, Y+5	; 0x05
    147e:	22 30       	cpi	r18, 0x02	; 2
    1480:	31 05       	cpc	r19, r1
    1482:	09 f4       	brne	.+2      	; 0x1486 <GPIO_setupPinDirection+0x5a>
    1484:	5f c0       	rjmp	.+190    	; 0x1544 <GPIO_setupPinDirection+0x118>
    1486:	8c 81       	ldd	r24, Y+4	; 0x04
    1488:	9d 81       	ldd	r25, Y+5	; 0x05
    148a:	83 30       	cpi	r24, 0x03	; 3
    148c:	91 05       	cpc	r25, r1
    148e:	09 f4       	brne	.+2      	; 0x1492 <GPIO_setupPinDirection+0x66>
    1490:	85 c0       	rjmp	.+266    	; 0x159c <GPIO_setupPinDirection+0x170>
    1492:	af c0       	rjmp	.+350    	; 0x15f2 <GPIO_setupPinDirection+0x1c6>
		{
		case PORTA_ID:
			if(direction == PIN_OUTPUT)
    1494:	8b 81       	ldd	r24, Y+3	; 0x03
    1496:	81 30       	cpi	r24, 0x01	; 1
    1498:	a1 f4       	brne	.+40     	; 0x14c2 <GPIO_setupPinDirection+0x96>
			{
				SET_BIT(DDRA,pin_num);
    149a:	aa e3       	ldi	r26, 0x3A	; 58
    149c:	b0 e0       	ldi	r27, 0x00	; 0
    149e:	ea e3       	ldi	r30, 0x3A	; 58
    14a0:	f0 e0       	ldi	r31, 0x00	; 0
    14a2:	80 81       	ld	r24, Z
    14a4:	48 2f       	mov	r20, r24
    14a6:	8a 81       	ldd	r24, Y+2	; 0x02
    14a8:	28 2f       	mov	r18, r24
    14aa:	30 e0       	ldi	r19, 0x00	; 0
    14ac:	81 e0       	ldi	r24, 0x01	; 1
    14ae:	90 e0       	ldi	r25, 0x00	; 0
    14b0:	02 2e       	mov	r0, r18
    14b2:	02 c0       	rjmp	.+4      	; 0x14b8 <GPIO_setupPinDirection+0x8c>
    14b4:	88 0f       	add	r24, r24
    14b6:	99 1f       	adc	r25, r25
    14b8:	0a 94       	dec	r0
    14ba:	e2 f7       	brpl	.-8      	; 0x14b4 <GPIO_setupPinDirection+0x88>
    14bc:	84 2b       	or	r24, r20
    14be:	8c 93       	st	X, r24
    14c0:	98 c0       	rjmp	.+304    	; 0x15f2 <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRA,pin_num);
    14c2:	aa e3       	ldi	r26, 0x3A	; 58
    14c4:	b0 e0       	ldi	r27, 0x00	; 0
    14c6:	ea e3       	ldi	r30, 0x3A	; 58
    14c8:	f0 e0       	ldi	r31, 0x00	; 0
    14ca:	80 81       	ld	r24, Z
    14cc:	48 2f       	mov	r20, r24
    14ce:	8a 81       	ldd	r24, Y+2	; 0x02
    14d0:	28 2f       	mov	r18, r24
    14d2:	30 e0       	ldi	r19, 0x00	; 0
    14d4:	81 e0       	ldi	r24, 0x01	; 1
    14d6:	90 e0       	ldi	r25, 0x00	; 0
    14d8:	02 2e       	mov	r0, r18
    14da:	02 c0       	rjmp	.+4      	; 0x14e0 <GPIO_setupPinDirection+0xb4>
    14dc:	88 0f       	add	r24, r24
    14de:	99 1f       	adc	r25, r25
    14e0:	0a 94       	dec	r0
    14e2:	e2 f7       	brpl	.-8      	; 0x14dc <GPIO_setupPinDirection+0xb0>
    14e4:	80 95       	com	r24
    14e6:	84 23       	and	r24, r20
    14e8:	8c 93       	st	X, r24
    14ea:	83 c0       	rjmp	.+262    	; 0x15f2 <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTB_ID:
			if(direction == PIN_OUTPUT)
    14ec:	8b 81       	ldd	r24, Y+3	; 0x03
    14ee:	81 30       	cpi	r24, 0x01	; 1
    14f0:	a1 f4       	brne	.+40     	; 0x151a <GPIO_setupPinDirection+0xee>
			{
				SET_BIT(DDRB,pin_num);
    14f2:	a7 e3       	ldi	r26, 0x37	; 55
    14f4:	b0 e0       	ldi	r27, 0x00	; 0
    14f6:	e7 e3       	ldi	r30, 0x37	; 55
    14f8:	f0 e0       	ldi	r31, 0x00	; 0
    14fa:	80 81       	ld	r24, Z
    14fc:	48 2f       	mov	r20, r24
    14fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1500:	28 2f       	mov	r18, r24
    1502:	30 e0       	ldi	r19, 0x00	; 0
    1504:	81 e0       	ldi	r24, 0x01	; 1
    1506:	90 e0       	ldi	r25, 0x00	; 0
    1508:	02 2e       	mov	r0, r18
    150a:	02 c0       	rjmp	.+4      	; 0x1510 <GPIO_setupPinDirection+0xe4>
    150c:	88 0f       	add	r24, r24
    150e:	99 1f       	adc	r25, r25
    1510:	0a 94       	dec	r0
    1512:	e2 f7       	brpl	.-8      	; 0x150c <GPIO_setupPinDirection+0xe0>
    1514:	84 2b       	or	r24, r20
    1516:	8c 93       	st	X, r24
    1518:	6c c0       	rjmp	.+216    	; 0x15f2 <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRB,pin_num);
    151a:	a7 e3       	ldi	r26, 0x37	; 55
    151c:	b0 e0       	ldi	r27, 0x00	; 0
    151e:	e7 e3       	ldi	r30, 0x37	; 55
    1520:	f0 e0       	ldi	r31, 0x00	; 0
    1522:	80 81       	ld	r24, Z
    1524:	48 2f       	mov	r20, r24
    1526:	8a 81       	ldd	r24, Y+2	; 0x02
    1528:	28 2f       	mov	r18, r24
    152a:	30 e0       	ldi	r19, 0x00	; 0
    152c:	81 e0       	ldi	r24, 0x01	; 1
    152e:	90 e0       	ldi	r25, 0x00	; 0
    1530:	02 2e       	mov	r0, r18
    1532:	02 c0       	rjmp	.+4      	; 0x1538 <GPIO_setupPinDirection+0x10c>
    1534:	88 0f       	add	r24, r24
    1536:	99 1f       	adc	r25, r25
    1538:	0a 94       	dec	r0
    153a:	e2 f7       	brpl	.-8      	; 0x1534 <GPIO_setupPinDirection+0x108>
    153c:	80 95       	com	r24
    153e:	84 23       	and	r24, r20
    1540:	8c 93       	st	X, r24
    1542:	57 c0       	rjmp	.+174    	; 0x15f2 <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTC_ID:
			if(direction == PIN_OUTPUT)
    1544:	8b 81       	ldd	r24, Y+3	; 0x03
    1546:	81 30       	cpi	r24, 0x01	; 1
    1548:	a1 f4       	brne	.+40     	; 0x1572 <GPIO_setupPinDirection+0x146>
			{
				SET_BIT(DDRC,pin_num);
    154a:	a4 e3       	ldi	r26, 0x34	; 52
    154c:	b0 e0       	ldi	r27, 0x00	; 0
    154e:	e4 e3       	ldi	r30, 0x34	; 52
    1550:	f0 e0       	ldi	r31, 0x00	; 0
    1552:	80 81       	ld	r24, Z
    1554:	48 2f       	mov	r20, r24
    1556:	8a 81       	ldd	r24, Y+2	; 0x02
    1558:	28 2f       	mov	r18, r24
    155a:	30 e0       	ldi	r19, 0x00	; 0
    155c:	81 e0       	ldi	r24, 0x01	; 1
    155e:	90 e0       	ldi	r25, 0x00	; 0
    1560:	02 2e       	mov	r0, r18
    1562:	02 c0       	rjmp	.+4      	; 0x1568 <GPIO_setupPinDirection+0x13c>
    1564:	88 0f       	add	r24, r24
    1566:	99 1f       	adc	r25, r25
    1568:	0a 94       	dec	r0
    156a:	e2 f7       	brpl	.-8      	; 0x1564 <GPIO_setupPinDirection+0x138>
    156c:	84 2b       	or	r24, r20
    156e:	8c 93       	st	X, r24
    1570:	40 c0       	rjmp	.+128    	; 0x15f2 <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRC,pin_num);
    1572:	a4 e3       	ldi	r26, 0x34	; 52
    1574:	b0 e0       	ldi	r27, 0x00	; 0
    1576:	e4 e3       	ldi	r30, 0x34	; 52
    1578:	f0 e0       	ldi	r31, 0x00	; 0
    157a:	80 81       	ld	r24, Z
    157c:	48 2f       	mov	r20, r24
    157e:	8a 81       	ldd	r24, Y+2	; 0x02
    1580:	28 2f       	mov	r18, r24
    1582:	30 e0       	ldi	r19, 0x00	; 0
    1584:	81 e0       	ldi	r24, 0x01	; 1
    1586:	90 e0       	ldi	r25, 0x00	; 0
    1588:	02 2e       	mov	r0, r18
    158a:	02 c0       	rjmp	.+4      	; 0x1590 <GPIO_setupPinDirection+0x164>
    158c:	88 0f       	add	r24, r24
    158e:	99 1f       	adc	r25, r25
    1590:	0a 94       	dec	r0
    1592:	e2 f7       	brpl	.-8      	; 0x158c <GPIO_setupPinDirection+0x160>
    1594:	80 95       	com	r24
    1596:	84 23       	and	r24, r20
    1598:	8c 93       	st	X, r24
    159a:	2b c0       	rjmp	.+86     	; 0x15f2 <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTD_ID:
			if(direction == PIN_OUTPUT)
    159c:	8b 81       	ldd	r24, Y+3	; 0x03
    159e:	81 30       	cpi	r24, 0x01	; 1
    15a0:	a1 f4       	brne	.+40     	; 0x15ca <GPIO_setupPinDirection+0x19e>
			{
				SET_BIT(DDRD,pin_num);
    15a2:	a1 e3       	ldi	r26, 0x31	; 49
    15a4:	b0 e0       	ldi	r27, 0x00	; 0
    15a6:	e1 e3       	ldi	r30, 0x31	; 49
    15a8:	f0 e0       	ldi	r31, 0x00	; 0
    15aa:	80 81       	ld	r24, Z
    15ac:	48 2f       	mov	r20, r24
    15ae:	8a 81       	ldd	r24, Y+2	; 0x02
    15b0:	28 2f       	mov	r18, r24
    15b2:	30 e0       	ldi	r19, 0x00	; 0
    15b4:	81 e0       	ldi	r24, 0x01	; 1
    15b6:	90 e0       	ldi	r25, 0x00	; 0
    15b8:	02 2e       	mov	r0, r18
    15ba:	02 c0       	rjmp	.+4      	; 0x15c0 <GPIO_setupPinDirection+0x194>
    15bc:	88 0f       	add	r24, r24
    15be:	99 1f       	adc	r25, r25
    15c0:	0a 94       	dec	r0
    15c2:	e2 f7       	brpl	.-8      	; 0x15bc <GPIO_setupPinDirection+0x190>
    15c4:	84 2b       	or	r24, r20
    15c6:	8c 93       	st	X, r24
    15c8:	14 c0       	rjmp	.+40     	; 0x15f2 <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRD,pin_num);
    15ca:	a1 e3       	ldi	r26, 0x31	; 49
    15cc:	b0 e0       	ldi	r27, 0x00	; 0
    15ce:	e1 e3       	ldi	r30, 0x31	; 49
    15d0:	f0 e0       	ldi	r31, 0x00	; 0
    15d2:	80 81       	ld	r24, Z
    15d4:	48 2f       	mov	r20, r24
    15d6:	8a 81       	ldd	r24, Y+2	; 0x02
    15d8:	28 2f       	mov	r18, r24
    15da:	30 e0       	ldi	r19, 0x00	; 0
    15dc:	81 e0       	ldi	r24, 0x01	; 1
    15de:	90 e0       	ldi	r25, 0x00	; 0
    15e0:	02 2e       	mov	r0, r18
    15e2:	02 c0       	rjmp	.+4      	; 0x15e8 <GPIO_setupPinDirection+0x1bc>
    15e4:	88 0f       	add	r24, r24
    15e6:	99 1f       	adc	r25, r25
    15e8:	0a 94       	dec	r0
    15ea:	e2 f7       	brpl	.-8      	; 0x15e4 <GPIO_setupPinDirection+0x1b8>
    15ec:	80 95       	com	r24
    15ee:	84 23       	and	r24, r20
    15f0:	8c 93       	st	X, r24
			break;
		default:
		    break;
		}
	}
}
    15f2:	0f 90       	pop	r0
    15f4:	0f 90       	pop	r0
    15f6:	0f 90       	pop	r0
    15f8:	0f 90       	pop	r0
    15fa:	0f 90       	pop	r0
    15fc:	cf 91       	pop	r28
    15fe:	df 91       	pop	r29
    1600:	08 95       	ret

00001602 <GPIO_writePin>:
 * Write the value Logic High or Logic Low on the required pin.
 * If the input port number or pin number are not correct, The function will not handle the request.
 * If the pin is input, this function will enable/disable the internal pull-up resistor.
 */
void GPIO_writePin(uint8 port_num, uint8 pin_num, uint8 value)
{
    1602:	df 93       	push	r29
    1604:	cf 93       	push	r28
    1606:	00 d0       	rcall	.+0      	; 0x1608 <GPIO_writePin+0x6>
    1608:	00 d0       	rcall	.+0      	; 0x160a <GPIO_writePin+0x8>
    160a:	0f 92       	push	r0
    160c:	cd b7       	in	r28, 0x3d	; 61
    160e:	de b7       	in	r29, 0x3e	; 62
    1610:	89 83       	std	Y+1, r24	; 0x01
    1612:	6a 83       	std	Y+2, r22	; 0x02
    1614:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    1616:	8a 81       	ldd	r24, Y+2	; 0x02
    1618:	88 30       	cpi	r24, 0x08	; 8
    161a:	08 f0       	brcs	.+2      	; 0x161e <GPIO_writePin+0x1c>
    161c:	d5 c0       	rjmp	.+426    	; 0x17c8 <GPIO_writePin+0x1c6>
    161e:	89 81       	ldd	r24, Y+1	; 0x01
    1620:	84 30       	cpi	r24, 0x04	; 4
    1622:	08 f0       	brcs	.+2      	; 0x1626 <GPIO_writePin+0x24>
    1624:	d1 c0       	rjmp	.+418    	; 0x17c8 <GPIO_writePin+0x1c6>
		/* Do Nothing */
	}
	else
	{
		/* Write the pin value as required */
		switch(port_num)
    1626:	89 81       	ldd	r24, Y+1	; 0x01
    1628:	28 2f       	mov	r18, r24
    162a:	30 e0       	ldi	r19, 0x00	; 0
    162c:	3d 83       	std	Y+5, r19	; 0x05
    162e:	2c 83       	std	Y+4, r18	; 0x04
    1630:	8c 81       	ldd	r24, Y+4	; 0x04
    1632:	9d 81       	ldd	r25, Y+5	; 0x05
    1634:	81 30       	cpi	r24, 0x01	; 1
    1636:	91 05       	cpc	r25, r1
    1638:	09 f4       	brne	.+2      	; 0x163c <GPIO_writePin+0x3a>
    163a:	43 c0       	rjmp	.+134    	; 0x16c2 <GPIO_writePin+0xc0>
    163c:	2c 81       	ldd	r18, Y+4	; 0x04
    163e:	3d 81       	ldd	r19, Y+5	; 0x05
    1640:	22 30       	cpi	r18, 0x02	; 2
    1642:	31 05       	cpc	r19, r1
    1644:	2c f4       	brge	.+10     	; 0x1650 <GPIO_writePin+0x4e>
    1646:	8c 81       	ldd	r24, Y+4	; 0x04
    1648:	9d 81       	ldd	r25, Y+5	; 0x05
    164a:	00 97       	sbiw	r24, 0x00	; 0
    164c:	71 f0       	breq	.+28     	; 0x166a <GPIO_writePin+0x68>
    164e:	bc c0       	rjmp	.+376    	; 0x17c8 <GPIO_writePin+0x1c6>
    1650:	2c 81       	ldd	r18, Y+4	; 0x04
    1652:	3d 81       	ldd	r19, Y+5	; 0x05
    1654:	22 30       	cpi	r18, 0x02	; 2
    1656:	31 05       	cpc	r19, r1
    1658:	09 f4       	brne	.+2      	; 0x165c <GPIO_writePin+0x5a>
    165a:	5f c0       	rjmp	.+190    	; 0x171a <GPIO_writePin+0x118>
    165c:	8c 81       	ldd	r24, Y+4	; 0x04
    165e:	9d 81       	ldd	r25, Y+5	; 0x05
    1660:	83 30       	cpi	r24, 0x03	; 3
    1662:	91 05       	cpc	r25, r1
    1664:	09 f4       	brne	.+2      	; 0x1668 <GPIO_writePin+0x66>
    1666:	85 c0       	rjmp	.+266    	; 0x1772 <GPIO_writePin+0x170>
    1668:	af c0       	rjmp	.+350    	; 0x17c8 <GPIO_writePin+0x1c6>
		{
		case PORTA_ID:
			if(value == LOGIC_HIGH)
    166a:	8b 81       	ldd	r24, Y+3	; 0x03
    166c:	81 30       	cpi	r24, 0x01	; 1
    166e:	a1 f4       	brne	.+40     	; 0x1698 <GPIO_writePin+0x96>
			{
				SET_BIT(PORTA,pin_num);
    1670:	ab e3       	ldi	r26, 0x3B	; 59
    1672:	b0 e0       	ldi	r27, 0x00	; 0
    1674:	eb e3       	ldi	r30, 0x3B	; 59
    1676:	f0 e0       	ldi	r31, 0x00	; 0
    1678:	80 81       	ld	r24, Z
    167a:	48 2f       	mov	r20, r24
    167c:	8a 81       	ldd	r24, Y+2	; 0x02
    167e:	28 2f       	mov	r18, r24
    1680:	30 e0       	ldi	r19, 0x00	; 0
    1682:	81 e0       	ldi	r24, 0x01	; 1
    1684:	90 e0       	ldi	r25, 0x00	; 0
    1686:	02 2e       	mov	r0, r18
    1688:	02 c0       	rjmp	.+4      	; 0x168e <GPIO_writePin+0x8c>
    168a:	88 0f       	add	r24, r24
    168c:	99 1f       	adc	r25, r25
    168e:	0a 94       	dec	r0
    1690:	e2 f7       	brpl	.-8      	; 0x168a <GPIO_writePin+0x88>
    1692:	84 2b       	or	r24, r20
    1694:	8c 93       	st	X, r24
    1696:	98 c0       	rjmp	.+304    	; 0x17c8 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTA,pin_num);
    1698:	ab e3       	ldi	r26, 0x3B	; 59
    169a:	b0 e0       	ldi	r27, 0x00	; 0
    169c:	eb e3       	ldi	r30, 0x3B	; 59
    169e:	f0 e0       	ldi	r31, 0x00	; 0
    16a0:	80 81       	ld	r24, Z
    16a2:	48 2f       	mov	r20, r24
    16a4:	8a 81       	ldd	r24, Y+2	; 0x02
    16a6:	28 2f       	mov	r18, r24
    16a8:	30 e0       	ldi	r19, 0x00	; 0
    16aa:	81 e0       	ldi	r24, 0x01	; 1
    16ac:	90 e0       	ldi	r25, 0x00	; 0
    16ae:	02 2e       	mov	r0, r18
    16b0:	02 c0       	rjmp	.+4      	; 0x16b6 <GPIO_writePin+0xb4>
    16b2:	88 0f       	add	r24, r24
    16b4:	99 1f       	adc	r25, r25
    16b6:	0a 94       	dec	r0
    16b8:	e2 f7       	brpl	.-8      	; 0x16b2 <GPIO_writePin+0xb0>
    16ba:	80 95       	com	r24
    16bc:	84 23       	and	r24, r20
    16be:	8c 93       	st	X, r24
    16c0:	83 c0       	rjmp	.+262    	; 0x17c8 <GPIO_writePin+0x1c6>
			}
			break;
		case PORTB_ID:
			if(value == LOGIC_HIGH)
    16c2:	8b 81       	ldd	r24, Y+3	; 0x03
    16c4:	81 30       	cpi	r24, 0x01	; 1
    16c6:	a1 f4       	brne	.+40     	; 0x16f0 <GPIO_writePin+0xee>
			{
				SET_BIT(PORTB,pin_num);
    16c8:	a8 e3       	ldi	r26, 0x38	; 56
    16ca:	b0 e0       	ldi	r27, 0x00	; 0
    16cc:	e8 e3       	ldi	r30, 0x38	; 56
    16ce:	f0 e0       	ldi	r31, 0x00	; 0
    16d0:	80 81       	ld	r24, Z
    16d2:	48 2f       	mov	r20, r24
    16d4:	8a 81       	ldd	r24, Y+2	; 0x02
    16d6:	28 2f       	mov	r18, r24
    16d8:	30 e0       	ldi	r19, 0x00	; 0
    16da:	81 e0       	ldi	r24, 0x01	; 1
    16dc:	90 e0       	ldi	r25, 0x00	; 0
    16de:	02 2e       	mov	r0, r18
    16e0:	02 c0       	rjmp	.+4      	; 0x16e6 <GPIO_writePin+0xe4>
    16e2:	88 0f       	add	r24, r24
    16e4:	99 1f       	adc	r25, r25
    16e6:	0a 94       	dec	r0
    16e8:	e2 f7       	brpl	.-8      	; 0x16e2 <GPIO_writePin+0xe0>
    16ea:	84 2b       	or	r24, r20
    16ec:	8c 93       	st	X, r24
    16ee:	6c c0       	rjmp	.+216    	; 0x17c8 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTB,pin_num);
    16f0:	a8 e3       	ldi	r26, 0x38	; 56
    16f2:	b0 e0       	ldi	r27, 0x00	; 0
    16f4:	e8 e3       	ldi	r30, 0x38	; 56
    16f6:	f0 e0       	ldi	r31, 0x00	; 0
    16f8:	80 81       	ld	r24, Z
    16fa:	48 2f       	mov	r20, r24
    16fc:	8a 81       	ldd	r24, Y+2	; 0x02
    16fe:	28 2f       	mov	r18, r24
    1700:	30 e0       	ldi	r19, 0x00	; 0
    1702:	81 e0       	ldi	r24, 0x01	; 1
    1704:	90 e0       	ldi	r25, 0x00	; 0
    1706:	02 2e       	mov	r0, r18
    1708:	02 c0       	rjmp	.+4      	; 0x170e <GPIO_writePin+0x10c>
    170a:	88 0f       	add	r24, r24
    170c:	99 1f       	adc	r25, r25
    170e:	0a 94       	dec	r0
    1710:	e2 f7       	brpl	.-8      	; 0x170a <GPIO_writePin+0x108>
    1712:	80 95       	com	r24
    1714:	84 23       	and	r24, r20
    1716:	8c 93       	st	X, r24
    1718:	57 c0       	rjmp	.+174    	; 0x17c8 <GPIO_writePin+0x1c6>
			}
			break;
		case PORTC_ID:
			if(value == LOGIC_HIGH)
    171a:	8b 81       	ldd	r24, Y+3	; 0x03
    171c:	81 30       	cpi	r24, 0x01	; 1
    171e:	a1 f4       	brne	.+40     	; 0x1748 <GPIO_writePin+0x146>
			{
				SET_BIT(PORTC,pin_num);
    1720:	a5 e3       	ldi	r26, 0x35	; 53
    1722:	b0 e0       	ldi	r27, 0x00	; 0
    1724:	e5 e3       	ldi	r30, 0x35	; 53
    1726:	f0 e0       	ldi	r31, 0x00	; 0
    1728:	80 81       	ld	r24, Z
    172a:	48 2f       	mov	r20, r24
    172c:	8a 81       	ldd	r24, Y+2	; 0x02
    172e:	28 2f       	mov	r18, r24
    1730:	30 e0       	ldi	r19, 0x00	; 0
    1732:	81 e0       	ldi	r24, 0x01	; 1
    1734:	90 e0       	ldi	r25, 0x00	; 0
    1736:	02 2e       	mov	r0, r18
    1738:	02 c0       	rjmp	.+4      	; 0x173e <GPIO_writePin+0x13c>
    173a:	88 0f       	add	r24, r24
    173c:	99 1f       	adc	r25, r25
    173e:	0a 94       	dec	r0
    1740:	e2 f7       	brpl	.-8      	; 0x173a <GPIO_writePin+0x138>
    1742:	84 2b       	or	r24, r20
    1744:	8c 93       	st	X, r24
    1746:	40 c0       	rjmp	.+128    	; 0x17c8 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTC,pin_num);
    1748:	a5 e3       	ldi	r26, 0x35	; 53
    174a:	b0 e0       	ldi	r27, 0x00	; 0
    174c:	e5 e3       	ldi	r30, 0x35	; 53
    174e:	f0 e0       	ldi	r31, 0x00	; 0
    1750:	80 81       	ld	r24, Z
    1752:	48 2f       	mov	r20, r24
    1754:	8a 81       	ldd	r24, Y+2	; 0x02
    1756:	28 2f       	mov	r18, r24
    1758:	30 e0       	ldi	r19, 0x00	; 0
    175a:	81 e0       	ldi	r24, 0x01	; 1
    175c:	90 e0       	ldi	r25, 0x00	; 0
    175e:	02 2e       	mov	r0, r18
    1760:	02 c0       	rjmp	.+4      	; 0x1766 <GPIO_writePin+0x164>
    1762:	88 0f       	add	r24, r24
    1764:	99 1f       	adc	r25, r25
    1766:	0a 94       	dec	r0
    1768:	e2 f7       	brpl	.-8      	; 0x1762 <GPIO_writePin+0x160>
    176a:	80 95       	com	r24
    176c:	84 23       	and	r24, r20
    176e:	8c 93       	st	X, r24
    1770:	2b c0       	rjmp	.+86     	; 0x17c8 <GPIO_writePin+0x1c6>
			}
			break;
		case PORTD_ID:
			if(value == LOGIC_HIGH)
    1772:	8b 81       	ldd	r24, Y+3	; 0x03
    1774:	81 30       	cpi	r24, 0x01	; 1
    1776:	a1 f4       	brne	.+40     	; 0x17a0 <GPIO_writePin+0x19e>
			{
				SET_BIT(PORTD,pin_num);
    1778:	a2 e3       	ldi	r26, 0x32	; 50
    177a:	b0 e0       	ldi	r27, 0x00	; 0
    177c:	e2 e3       	ldi	r30, 0x32	; 50
    177e:	f0 e0       	ldi	r31, 0x00	; 0
    1780:	80 81       	ld	r24, Z
    1782:	48 2f       	mov	r20, r24
    1784:	8a 81       	ldd	r24, Y+2	; 0x02
    1786:	28 2f       	mov	r18, r24
    1788:	30 e0       	ldi	r19, 0x00	; 0
    178a:	81 e0       	ldi	r24, 0x01	; 1
    178c:	90 e0       	ldi	r25, 0x00	; 0
    178e:	02 2e       	mov	r0, r18
    1790:	02 c0       	rjmp	.+4      	; 0x1796 <GPIO_writePin+0x194>
    1792:	88 0f       	add	r24, r24
    1794:	99 1f       	adc	r25, r25
    1796:	0a 94       	dec	r0
    1798:	e2 f7       	brpl	.-8      	; 0x1792 <GPIO_writePin+0x190>
    179a:	84 2b       	or	r24, r20
    179c:	8c 93       	st	X, r24
    179e:	14 c0       	rjmp	.+40     	; 0x17c8 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTD,pin_num);
    17a0:	a2 e3       	ldi	r26, 0x32	; 50
    17a2:	b0 e0       	ldi	r27, 0x00	; 0
    17a4:	e2 e3       	ldi	r30, 0x32	; 50
    17a6:	f0 e0       	ldi	r31, 0x00	; 0
    17a8:	80 81       	ld	r24, Z
    17aa:	48 2f       	mov	r20, r24
    17ac:	8a 81       	ldd	r24, Y+2	; 0x02
    17ae:	28 2f       	mov	r18, r24
    17b0:	30 e0       	ldi	r19, 0x00	; 0
    17b2:	81 e0       	ldi	r24, 0x01	; 1
    17b4:	90 e0       	ldi	r25, 0x00	; 0
    17b6:	02 2e       	mov	r0, r18
    17b8:	02 c0       	rjmp	.+4      	; 0x17be <GPIO_writePin+0x1bc>
    17ba:	88 0f       	add	r24, r24
    17bc:	99 1f       	adc	r25, r25
    17be:	0a 94       	dec	r0
    17c0:	e2 f7       	brpl	.-8      	; 0x17ba <GPIO_writePin+0x1b8>
    17c2:	80 95       	com	r24
    17c4:	84 23       	and	r24, r20
    17c6:	8c 93       	st	X, r24
			break;
		default:
		            break;
		}
	}
}
    17c8:	0f 90       	pop	r0
    17ca:	0f 90       	pop	r0
    17cc:	0f 90       	pop	r0
    17ce:	0f 90       	pop	r0
    17d0:	0f 90       	pop	r0
    17d2:	cf 91       	pop	r28
    17d4:	df 91       	pop	r29
    17d6:	08 95       	ret

000017d8 <GPIO_TogglePin>:
void GPIO_TogglePin(uint8 port_num, uint8 pin_num){
    17d8:	df 93       	push	r29
    17da:	cf 93       	push	r28
    17dc:	00 d0       	rcall	.+0      	; 0x17de <GPIO_TogglePin+0x6>
    17de:	00 d0       	rcall	.+0      	; 0x17e0 <GPIO_TogglePin+0x8>
    17e0:	cd b7       	in	r28, 0x3d	; 61
    17e2:	de b7       	in	r29, 0x3e	; 62
    17e4:	89 83       	std	Y+1, r24	; 0x01
    17e6:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    17e8:	8a 81       	ldd	r24, Y+2	; 0x02
    17ea:	88 30       	cpi	r24, 0x08	; 8
    17ec:	08 f0       	brcs	.+2      	; 0x17f0 <GPIO_TogglePin+0x18>
    17ee:	72 c0       	rjmp	.+228    	; 0x18d4 <GPIO_TogglePin+0xfc>
    17f0:	89 81       	ldd	r24, Y+1	; 0x01
    17f2:	84 30       	cpi	r24, 0x04	; 4
    17f4:	08 f0       	brcs	.+2      	; 0x17f8 <GPIO_TogglePin+0x20>
    17f6:	6e c0       	rjmp	.+220    	; 0x18d4 <GPIO_TogglePin+0xfc>
		/* Do Nothing */
	}
	else
	{
		/* Write the pin value as required */
		switch(port_num)
    17f8:	89 81       	ldd	r24, Y+1	; 0x01
    17fa:	28 2f       	mov	r18, r24
    17fc:	30 e0       	ldi	r19, 0x00	; 0
    17fe:	3c 83       	std	Y+4, r19	; 0x04
    1800:	2b 83       	std	Y+3, r18	; 0x03
    1802:	8b 81       	ldd	r24, Y+3	; 0x03
    1804:	9c 81       	ldd	r25, Y+4	; 0x04
    1806:	81 30       	cpi	r24, 0x01	; 1
    1808:	91 05       	cpc	r25, r1
    180a:	49 f1       	breq	.+82     	; 0x185e <GPIO_TogglePin+0x86>
    180c:	2b 81       	ldd	r18, Y+3	; 0x03
    180e:	3c 81       	ldd	r19, Y+4	; 0x04
    1810:	22 30       	cpi	r18, 0x02	; 2
    1812:	31 05       	cpc	r19, r1
    1814:	2c f4       	brge	.+10     	; 0x1820 <GPIO_TogglePin+0x48>
    1816:	8b 81       	ldd	r24, Y+3	; 0x03
    1818:	9c 81       	ldd	r25, Y+4	; 0x04
    181a:	00 97       	sbiw	r24, 0x00	; 0
    181c:	61 f0       	breq	.+24     	; 0x1836 <GPIO_TogglePin+0x5e>
    181e:	5a c0       	rjmp	.+180    	; 0x18d4 <GPIO_TogglePin+0xfc>
    1820:	2b 81       	ldd	r18, Y+3	; 0x03
    1822:	3c 81       	ldd	r19, Y+4	; 0x04
    1824:	22 30       	cpi	r18, 0x02	; 2
    1826:	31 05       	cpc	r19, r1
    1828:	71 f1       	breq	.+92     	; 0x1886 <GPIO_TogglePin+0xae>
    182a:	8b 81       	ldd	r24, Y+3	; 0x03
    182c:	9c 81       	ldd	r25, Y+4	; 0x04
    182e:	83 30       	cpi	r24, 0x03	; 3
    1830:	91 05       	cpc	r25, r1
    1832:	e9 f1       	breq	.+122    	; 0x18ae <GPIO_TogglePin+0xd6>
    1834:	4f c0       	rjmp	.+158    	; 0x18d4 <GPIO_TogglePin+0xfc>
		{
		case PORTA_ID:
			TOGGLE_BIT(PORTA,pin_num);
    1836:	ab e3       	ldi	r26, 0x3B	; 59
    1838:	b0 e0       	ldi	r27, 0x00	; 0
    183a:	eb e3       	ldi	r30, 0x3B	; 59
    183c:	f0 e0       	ldi	r31, 0x00	; 0
    183e:	80 81       	ld	r24, Z
    1840:	48 2f       	mov	r20, r24
    1842:	8a 81       	ldd	r24, Y+2	; 0x02
    1844:	28 2f       	mov	r18, r24
    1846:	30 e0       	ldi	r19, 0x00	; 0
    1848:	81 e0       	ldi	r24, 0x01	; 1
    184a:	90 e0       	ldi	r25, 0x00	; 0
    184c:	02 2e       	mov	r0, r18
    184e:	02 c0       	rjmp	.+4      	; 0x1854 <GPIO_TogglePin+0x7c>
    1850:	88 0f       	add	r24, r24
    1852:	99 1f       	adc	r25, r25
    1854:	0a 94       	dec	r0
    1856:	e2 f7       	brpl	.-8      	; 0x1850 <GPIO_TogglePin+0x78>
    1858:	84 27       	eor	r24, r20
    185a:	8c 93       	st	X, r24
    185c:	3b c0       	rjmp	.+118    	; 0x18d4 <GPIO_TogglePin+0xfc>
			break;
		case PORTB_ID:
			TOGGLE_BIT(PORTB,pin_num);
    185e:	a8 e3       	ldi	r26, 0x38	; 56
    1860:	b0 e0       	ldi	r27, 0x00	; 0
    1862:	e8 e3       	ldi	r30, 0x38	; 56
    1864:	f0 e0       	ldi	r31, 0x00	; 0
    1866:	80 81       	ld	r24, Z
    1868:	48 2f       	mov	r20, r24
    186a:	8a 81       	ldd	r24, Y+2	; 0x02
    186c:	28 2f       	mov	r18, r24
    186e:	30 e0       	ldi	r19, 0x00	; 0
    1870:	81 e0       	ldi	r24, 0x01	; 1
    1872:	90 e0       	ldi	r25, 0x00	; 0
    1874:	02 2e       	mov	r0, r18
    1876:	02 c0       	rjmp	.+4      	; 0x187c <GPIO_TogglePin+0xa4>
    1878:	88 0f       	add	r24, r24
    187a:	99 1f       	adc	r25, r25
    187c:	0a 94       	dec	r0
    187e:	e2 f7       	brpl	.-8      	; 0x1878 <GPIO_TogglePin+0xa0>
    1880:	84 27       	eor	r24, r20
    1882:	8c 93       	st	X, r24
    1884:	27 c0       	rjmp	.+78     	; 0x18d4 <GPIO_TogglePin+0xfc>
			break;
		case PORTC_ID:
			TOGGLE_BIT(PORTC,pin_num);
    1886:	a5 e3       	ldi	r26, 0x35	; 53
    1888:	b0 e0       	ldi	r27, 0x00	; 0
    188a:	e5 e3       	ldi	r30, 0x35	; 53
    188c:	f0 e0       	ldi	r31, 0x00	; 0
    188e:	80 81       	ld	r24, Z
    1890:	48 2f       	mov	r20, r24
    1892:	8a 81       	ldd	r24, Y+2	; 0x02
    1894:	28 2f       	mov	r18, r24
    1896:	30 e0       	ldi	r19, 0x00	; 0
    1898:	81 e0       	ldi	r24, 0x01	; 1
    189a:	90 e0       	ldi	r25, 0x00	; 0
    189c:	02 2e       	mov	r0, r18
    189e:	02 c0       	rjmp	.+4      	; 0x18a4 <GPIO_TogglePin+0xcc>
    18a0:	88 0f       	add	r24, r24
    18a2:	99 1f       	adc	r25, r25
    18a4:	0a 94       	dec	r0
    18a6:	e2 f7       	brpl	.-8      	; 0x18a0 <GPIO_TogglePin+0xc8>
    18a8:	84 27       	eor	r24, r20
    18aa:	8c 93       	st	X, r24
    18ac:	13 c0       	rjmp	.+38     	; 0x18d4 <GPIO_TogglePin+0xfc>
			break;
		case PORTD_ID:

			TOGGLE_BIT(PORTD,pin_num);
    18ae:	a2 e3       	ldi	r26, 0x32	; 50
    18b0:	b0 e0       	ldi	r27, 0x00	; 0
    18b2:	e2 e3       	ldi	r30, 0x32	; 50
    18b4:	f0 e0       	ldi	r31, 0x00	; 0
    18b6:	80 81       	ld	r24, Z
    18b8:	48 2f       	mov	r20, r24
    18ba:	8a 81       	ldd	r24, Y+2	; 0x02
    18bc:	28 2f       	mov	r18, r24
    18be:	30 e0       	ldi	r19, 0x00	; 0
    18c0:	81 e0       	ldi	r24, 0x01	; 1
    18c2:	90 e0       	ldi	r25, 0x00	; 0
    18c4:	02 2e       	mov	r0, r18
    18c6:	02 c0       	rjmp	.+4      	; 0x18cc <GPIO_TogglePin+0xf4>
    18c8:	88 0f       	add	r24, r24
    18ca:	99 1f       	adc	r25, r25
    18cc:	0a 94       	dec	r0
    18ce:	e2 f7       	brpl	.-8      	; 0x18c8 <GPIO_TogglePin+0xf0>
    18d0:	84 27       	eor	r24, r20
    18d2:	8c 93       	st	X, r24
			break;
		default:
		    break;
		}
	}
}
    18d4:	0f 90       	pop	r0
    18d6:	0f 90       	pop	r0
    18d8:	0f 90       	pop	r0
    18da:	0f 90       	pop	r0
    18dc:	cf 91       	pop	r28
    18de:	df 91       	pop	r29
    18e0:	08 95       	ret

000018e2 <GPIO_readPin>:
 * Description :
 * Read and return the value for the required pin, it should be Logic High or Logic Low.
 * If the input port number or pin number are not correct, The function will return Logic Low.
 */
uint8 GPIO_readPin(uint8 port_num, uint8 pin_num)
{
    18e2:	df 93       	push	r29
    18e4:	cf 93       	push	r28
    18e6:	00 d0       	rcall	.+0      	; 0x18e8 <GPIO_readPin+0x6>
    18e8:	00 d0       	rcall	.+0      	; 0x18ea <GPIO_readPin+0x8>
    18ea:	0f 92       	push	r0
    18ec:	cd b7       	in	r28, 0x3d	; 61
    18ee:	de b7       	in	r29, 0x3e	; 62
    18f0:	8a 83       	std	Y+2, r24	; 0x02
    18f2:	6b 83       	std	Y+3, r22	; 0x03
	uint8 pin_value = LOGIC_LOW;
    18f4:	19 82       	std	Y+1, r1	; 0x01
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    18f6:	8b 81       	ldd	r24, Y+3	; 0x03
    18f8:	88 30       	cpi	r24, 0x08	; 8
    18fa:	08 f0       	brcs	.+2      	; 0x18fe <GPIO_readPin+0x1c>
    18fc:	84 c0       	rjmp	.+264    	; 0x1a06 <GPIO_readPin+0x124>
    18fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1900:	84 30       	cpi	r24, 0x04	; 4
    1902:	08 f0       	brcs	.+2      	; 0x1906 <GPIO_readPin+0x24>
    1904:	80 c0       	rjmp	.+256    	; 0x1a06 <GPIO_readPin+0x124>
		/* Do Nothing */
	}
	else
	{
		/* Read the pin value as required */
		switch(port_num)
    1906:	8a 81       	ldd	r24, Y+2	; 0x02
    1908:	28 2f       	mov	r18, r24
    190a:	30 e0       	ldi	r19, 0x00	; 0
    190c:	3d 83       	std	Y+5, r19	; 0x05
    190e:	2c 83       	std	Y+4, r18	; 0x04
    1910:	4c 81       	ldd	r20, Y+4	; 0x04
    1912:	5d 81       	ldd	r21, Y+5	; 0x05
    1914:	41 30       	cpi	r20, 0x01	; 1
    1916:	51 05       	cpc	r21, r1
    1918:	79 f1       	breq	.+94     	; 0x1978 <GPIO_readPin+0x96>
    191a:	8c 81       	ldd	r24, Y+4	; 0x04
    191c:	9d 81       	ldd	r25, Y+5	; 0x05
    191e:	82 30       	cpi	r24, 0x02	; 2
    1920:	91 05       	cpc	r25, r1
    1922:	34 f4       	brge	.+12     	; 0x1930 <GPIO_readPin+0x4e>
    1924:	2c 81       	ldd	r18, Y+4	; 0x04
    1926:	3d 81       	ldd	r19, Y+5	; 0x05
    1928:	21 15       	cp	r18, r1
    192a:	31 05       	cpc	r19, r1
    192c:	69 f0       	breq	.+26     	; 0x1948 <GPIO_readPin+0x66>
    192e:	6b c0       	rjmp	.+214    	; 0x1a06 <GPIO_readPin+0x124>
    1930:	4c 81       	ldd	r20, Y+4	; 0x04
    1932:	5d 81       	ldd	r21, Y+5	; 0x05
    1934:	42 30       	cpi	r20, 0x02	; 2
    1936:	51 05       	cpc	r21, r1
    1938:	b9 f1       	breq	.+110    	; 0x19a8 <GPIO_readPin+0xc6>
    193a:	8c 81       	ldd	r24, Y+4	; 0x04
    193c:	9d 81       	ldd	r25, Y+5	; 0x05
    193e:	83 30       	cpi	r24, 0x03	; 3
    1940:	91 05       	cpc	r25, r1
    1942:	09 f4       	brne	.+2      	; 0x1946 <GPIO_readPin+0x64>
    1944:	49 c0       	rjmp	.+146    	; 0x19d8 <GPIO_readPin+0xf6>
    1946:	5f c0       	rjmp	.+190    	; 0x1a06 <GPIO_readPin+0x124>
		{
		case PORTA_ID:
			if(BIT_IS_SET(PINA,pin_num))
    1948:	e9 e3       	ldi	r30, 0x39	; 57
    194a:	f0 e0       	ldi	r31, 0x00	; 0
    194c:	80 81       	ld	r24, Z
    194e:	28 2f       	mov	r18, r24
    1950:	30 e0       	ldi	r19, 0x00	; 0
    1952:	8b 81       	ldd	r24, Y+3	; 0x03
    1954:	88 2f       	mov	r24, r24
    1956:	90 e0       	ldi	r25, 0x00	; 0
    1958:	a9 01       	movw	r20, r18
    195a:	02 c0       	rjmp	.+4      	; 0x1960 <GPIO_readPin+0x7e>
    195c:	55 95       	asr	r21
    195e:	47 95       	ror	r20
    1960:	8a 95       	dec	r24
    1962:	e2 f7       	brpl	.-8      	; 0x195c <GPIO_readPin+0x7a>
    1964:	ca 01       	movw	r24, r20
    1966:	81 70       	andi	r24, 0x01	; 1
    1968:	90 70       	andi	r25, 0x00	; 0
    196a:	88 23       	and	r24, r24
    196c:	19 f0       	breq	.+6      	; 0x1974 <GPIO_readPin+0x92>
			{
				pin_value = LOGIC_HIGH;
    196e:	81 e0       	ldi	r24, 0x01	; 1
    1970:	89 83       	std	Y+1, r24	; 0x01
    1972:	49 c0       	rjmp	.+146    	; 0x1a06 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    1974:	19 82       	std	Y+1, r1	; 0x01
    1976:	47 c0       	rjmp	.+142    	; 0x1a06 <GPIO_readPin+0x124>
			}
			break;
		case PORTB_ID:
			if(BIT_IS_SET(PINB,pin_num))
    1978:	e6 e3       	ldi	r30, 0x36	; 54
    197a:	f0 e0       	ldi	r31, 0x00	; 0
    197c:	80 81       	ld	r24, Z
    197e:	28 2f       	mov	r18, r24
    1980:	30 e0       	ldi	r19, 0x00	; 0
    1982:	8b 81       	ldd	r24, Y+3	; 0x03
    1984:	88 2f       	mov	r24, r24
    1986:	90 e0       	ldi	r25, 0x00	; 0
    1988:	a9 01       	movw	r20, r18
    198a:	02 c0       	rjmp	.+4      	; 0x1990 <GPIO_readPin+0xae>
    198c:	55 95       	asr	r21
    198e:	47 95       	ror	r20
    1990:	8a 95       	dec	r24
    1992:	e2 f7       	brpl	.-8      	; 0x198c <GPIO_readPin+0xaa>
    1994:	ca 01       	movw	r24, r20
    1996:	81 70       	andi	r24, 0x01	; 1
    1998:	90 70       	andi	r25, 0x00	; 0
    199a:	88 23       	and	r24, r24
    199c:	19 f0       	breq	.+6      	; 0x19a4 <GPIO_readPin+0xc2>
			{
				pin_value = LOGIC_HIGH;
    199e:	81 e0       	ldi	r24, 0x01	; 1
    19a0:	89 83       	std	Y+1, r24	; 0x01
    19a2:	31 c0       	rjmp	.+98     	; 0x1a06 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    19a4:	19 82       	std	Y+1, r1	; 0x01
    19a6:	2f c0       	rjmp	.+94     	; 0x1a06 <GPIO_readPin+0x124>
			}
			break;
		case PORTC_ID:
			if(BIT_IS_SET(PINC,pin_num))
    19a8:	e3 e3       	ldi	r30, 0x33	; 51
    19aa:	f0 e0       	ldi	r31, 0x00	; 0
    19ac:	80 81       	ld	r24, Z
    19ae:	28 2f       	mov	r18, r24
    19b0:	30 e0       	ldi	r19, 0x00	; 0
    19b2:	8b 81       	ldd	r24, Y+3	; 0x03
    19b4:	88 2f       	mov	r24, r24
    19b6:	90 e0       	ldi	r25, 0x00	; 0
    19b8:	a9 01       	movw	r20, r18
    19ba:	02 c0       	rjmp	.+4      	; 0x19c0 <GPIO_readPin+0xde>
    19bc:	55 95       	asr	r21
    19be:	47 95       	ror	r20
    19c0:	8a 95       	dec	r24
    19c2:	e2 f7       	brpl	.-8      	; 0x19bc <GPIO_readPin+0xda>
    19c4:	ca 01       	movw	r24, r20
    19c6:	81 70       	andi	r24, 0x01	; 1
    19c8:	90 70       	andi	r25, 0x00	; 0
    19ca:	88 23       	and	r24, r24
    19cc:	19 f0       	breq	.+6      	; 0x19d4 <GPIO_readPin+0xf2>
			{
				pin_value = LOGIC_HIGH;
    19ce:	81 e0       	ldi	r24, 0x01	; 1
    19d0:	89 83       	std	Y+1, r24	; 0x01
    19d2:	19 c0       	rjmp	.+50     	; 0x1a06 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    19d4:	19 82       	std	Y+1, r1	; 0x01
    19d6:	17 c0       	rjmp	.+46     	; 0x1a06 <GPIO_readPin+0x124>
			}
			break;
		case PORTD_ID:
			if(BIT_IS_SET(PIND,pin_num))
    19d8:	e0 e3       	ldi	r30, 0x30	; 48
    19da:	f0 e0       	ldi	r31, 0x00	; 0
    19dc:	80 81       	ld	r24, Z
    19de:	28 2f       	mov	r18, r24
    19e0:	30 e0       	ldi	r19, 0x00	; 0
    19e2:	8b 81       	ldd	r24, Y+3	; 0x03
    19e4:	88 2f       	mov	r24, r24
    19e6:	90 e0       	ldi	r25, 0x00	; 0
    19e8:	a9 01       	movw	r20, r18
    19ea:	02 c0       	rjmp	.+4      	; 0x19f0 <GPIO_readPin+0x10e>
    19ec:	55 95       	asr	r21
    19ee:	47 95       	ror	r20
    19f0:	8a 95       	dec	r24
    19f2:	e2 f7       	brpl	.-8      	; 0x19ec <GPIO_readPin+0x10a>
    19f4:	ca 01       	movw	r24, r20
    19f6:	81 70       	andi	r24, 0x01	; 1
    19f8:	90 70       	andi	r25, 0x00	; 0
    19fa:	88 23       	and	r24, r24
    19fc:	19 f0       	breq	.+6      	; 0x1a04 <GPIO_readPin+0x122>
			{
				pin_value = LOGIC_HIGH;
    19fe:	81 e0       	ldi	r24, 0x01	; 1
    1a00:	89 83       	std	Y+1, r24	; 0x01
    1a02:	01 c0       	rjmp	.+2      	; 0x1a06 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    1a04:	19 82       	std	Y+1, r1	; 0x01
		default:
		            break;
		}
	}

	return pin_value;
    1a06:	89 81       	ldd	r24, Y+1	; 0x01
}
    1a08:	0f 90       	pop	r0
    1a0a:	0f 90       	pop	r0
    1a0c:	0f 90       	pop	r0
    1a0e:	0f 90       	pop	r0
    1a10:	0f 90       	pop	r0
    1a12:	cf 91       	pop	r28
    1a14:	df 91       	pop	r29
    1a16:	08 95       	ret

00001a18 <GPIO_setupPortDirection>:
 * If the direction value is PORT_INPUT all pins in this port should be input pins.
 * If the direction value is PORT_OUTPUT all pins in this port should be output pins.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_setupPortDirection(uint8 port_num, GPIO_PortDirectionType direction)
{
    1a18:	df 93       	push	r29
    1a1a:	cf 93       	push	r28
    1a1c:	00 d0       	rcall	.+0      	; 0x1a1e <GPIO_setupPortDirection+0x6>
    1a1e:	00 d0       	rcall	.+0      	; 0x1a20 <GPIO_setupPortDirection+0x8>
    1a20:	cd b7       	in	r28, 0x3d	; 61
    1a22:	de b7       	in	r29, 0x3e	; 62
    1a24:	89 83       	std	Y+1, r24	; 0x01
    1a26:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    1a28:	89 81       	ldd	r24, Y+1	; 0x01
    1a2a:	84 30       	cpi	r24, 0x04	; 4
    1a2c:	90 f5       	brcc	.+100    	; 0x1a92 <GPIO_setupPortDirection+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Setup the port direction as required */
		switch(port_num)
    1a2e:	89 81       	ldd	r24, Y+1	; 0x01
    1a30:	28 2f       	mov	r18, r24
    1a32:	30 e0       	ldi	r19, 0x00	; 0
    1a34:	3c 83       	std	Y+4, r19	; 0x04
    1a36:	2b 83       	std	Y+3, r18	; 0x03
    1a38:	8b 81       	ldd	r24, Y+3	; 0x03
    1a3a:	9c 81       	ldd	r25, Y+4	; 0x04
    1a3c:	81 30       	cpi	r24, 0x01	; 1
    1a3e:	91 05       	cpc	r25, r1
    1a40:	d1 f0       	breq	.+52     	; 0x1a76 <GPIO_setupPortDirection+0x5e>
    1a42:	2b 81       	ldd	r18, Y+3	; 0x03
    1a44:	3c 81       	ldd	r19, Y+4	; 0x04
    1a46:	22 30       	cpi	r18, 0x02	; 2
    1a48:	31 05       	cpc	r19, r1
    1a4a:	2c f4       	brge	.+10     	; 0x1a56 <GPIO_setupPortDirection+0x3e>
    1a4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a4e:	9c 81       	ldd	r25, Y+4	; 0x04
    1a50:	00 97       	sbiw	r24, 0x00	; 0
    1a52:	61 f0       	breq	.+24     	; 0x1a6c <GPIO_setupPortDirection+0x54>
    1a54:	1e c0       	rjmp	.+60     	; 0x1a92 <GPIO_setupPortDirection+0x7a>
    1a56:	2b 81       	ldd	r18, Y+3	; 0x03
    1a58:	3c 81       	ldd	r19, Y+4	; 0x04
    1a5a:	22 30       	cpi	r18, 0x02	; 2
    1a5c:	31 05       	cpc	r19, r1
    1a5e:	81 f0       	breq	.+32     	; 0x1a80 <GPIO_setupPortDirection+0x68>
    1a60:	8b 81       	ldd	r24, Y+3	; 0x03
    1a62:	9c 81       	ldd	r25, Y+4	; 0x04
    1a64:	83 30       	cpi	r24, 0x03	; 3
    1a66:	91 05       	cpc	r25, r1
    1a68:	81 f0       	breq	.+32     	; 0x1a8a <GPIO_setupPortDirection+0x72>
    1a6a:	13 c0       	rjmp	.+38     	; 0x1a92 <GPIO_setupPortDirection+0x7a>
		{
		case PORTA_ID:
			DDRA = direction;
    1a6c:	ea e3       	ldi	r30, 0x3A	; 58
    1a6e:	f0 e0       	ldi	r31, 0x00	; 0
    1a70:	8a 81       	ldd	r24, Y+2	; 0x02
    1a72:	80 83       	st	Z, r24
    1a74:	0e c0       	rjmp	.+28     	; 0x1a92 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTB_ID:
			DDRB = direction;
    1a76:	e7 e3       	ldi	r30, 0x37	; 55
    1a78:	f0 e0       	ldi	r31, 0x00	; 0
    1a7a:	8a 81       	ldd	r24, Y+2	; 0x02
    1a7c:	80 83       	st	Z, r24
    1a7e:	09 c0       	rjmp	.+18     	; 0x1a92 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTC_ID:
			DDRC = direction;
    1a80:	e4 e3       	ldi	r30, 0x34	; 52
    1a82:	f0 e0       	ldi	r31, 0x00	; 0
    1a84:	8a 81       	ldd	r24, Y+2	; 0x02
    1a86:	80 83       	st	Z, r24
    1a88:	04 c0       	rjmp	.+8      	; 0x1a92 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTD_ID:
			DDRD = direction;
    1a8a:	e1 e3       	ldi	r30, 0x31	; 49
    1a8c:	f0 e0       	ldi	r31, 0x00	; 0
    1a8e:	8a 81       	ldd	r24, Y+2	; 0x02
    1a90:	80 83       	st	Z, r24
			break;
		default:
		            break;
		}
	}
}
    1a92:	0f 90       	pop	r0
    1a94:	0f 90       	pop	r0
    1a96:	0f 90       	pop	r0
    1a98:	0f 90       	pop	r0
    1a9a:	cf 91       	pop	r28
    1a9c:	df 91       	pop	r29
    1a9e:	08 95       	ret

00001aa0 <GPIO_writePort>:
 * If any pin in the port is output pin the value will be written.
 * If any pin in the port is input pin this will activate/deactivate the internal pull-up resistor.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_writePort(uint8 port_num, uint8 value)
{
    1aa0:	df 93       	push	r29
    1aa2:	cf 93       	push	r28
    1aa4:	00 d0       	rcall	.+0      	; 0x1aa6 <GPIO_writePort+0x6>
    1aa6:	00 d0       	rcall	.+0      	; 0x1aa8 <GPIO_writePort+0x8>
    1aa8:	cd b7       	in	r28, 0x3d	; 61
    1aaa:	de b7       	in	r29, 0x3e	; 62
    1aac:	89 83       	std	Y+1, r24	; 0x01
    1aae:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    1ab0:	89 81       	ldd	r24, Y+1	; 0x01
    1ab2:	84 30       	cpi	r24, 0x04	; 4
    1ab4:	90 f5       	brcc	.+100    	; 0x1b1a <GPIO_writePort+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Write the port value as required */
		switch(port_num)
    1ab6:	89 81       	ldd	r24, Y+1	; 0x01
    1ab8:	28 2f       	mov	r18, r24
    1aba:	30 e0       	ldi	r19, 0x00	; 0
    1abc:	3c 83       	std	Y+4, r19	; 0x04
    1abe:	2b 83       	std	Y+3, r18	; 0x03
    1ac0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ac2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ac4:	81 30       	cpi	r24, 0x01	; 1
    1ac6:	91 05       	cpc	r25, r1
    1ac8:	d1 f0       	breq	.+52     	; 0x1afe <GPIO_writePort+0x5e>
    1aca:	2b 81       	ldd	r18, Y+3	; 0x03
    1acc:	3c 81       	ldd	r19, Y+4	; 0x04
    1ace:	22 30       	cpi	r18, 0x02	; 2
    1ad0:	31 05       	cpc	r19, r1
    1ad2:	2c f4       	brge	.+10     	; 0x1ade <GPIO_writePort+0x3e>
    1ad4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ad6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ad8:	00 97       	sbiw	r24, 0x00	; 0
    1ada:	61 f0       	breq	.+24     	; 0x1af4 <GPIO_writePort+0x54>
    1adc:	1e c0       	rjmp	.+60     	; 0x1b1a <GPIO_writePort+0x7a>
    1ade:	2b 81       	ldd	r18, Y+3	; 0x03
    1ae0:	3c 81       	ldd	r19, Y+4	; 0x04
    1ae2:	22 30       	cpi	r18, 0x02	; 2
    1ae4:	31 05       	cpc	r19, r1
    1ae6:	81 f0       	breq	.+32     	; 0x1b08 <GPIO_writePort+0x68>
    1ae8:	8b 81       	ldd	r24, Y+3	; 0x03
    1aea:	9c 81       	ldd	r25, Y+4	; 0x04
    1aec:	83 30       	cpi	r24, 0x03	; 3
    1aee:	91 05       	cpc	r25, r1
    1af0:	81 f0       	breq	.+32     	; 0x1b12 <GPIO_writePort+0x72>
    1af2:	13 c0       	rjmp	.+38     	; 0x1b1a <GPIO_writePort+0x7a>
		{
		case PORTA_ID:
			PORTA = value;
    1af4:	eb e3       	ldi	r30, 0x3B	; 59
    1af6:	f0 e0       	ldi	r31, 0x00	; 0
    1af8:	8a 81       	ldd	r24, Y+2	; 0x02
    1afa:	80 83       	st	Z, r24
    1afc:	0e c0       	rjmp	.+28     	; 0x1b1a <GPIO_writePort+0x7a>
			break;
		case PORTB_ID:
			PORTB = value;
    1afe:	e8 e3       	ldi	r30, 0x38	; 56
    1b00:	f0 e0       	ldi	r31, 0x00	; 0
    1b02:	8a 81       	ldd	r24, Y+2	; 0x02
    1b04:	80 83       	st	Z, r24
    1b06:	09 c0       	rjmp	.+18     	; 0x1b1a <GPIO_writePort+0x7a>
			break;
		case PORTC_ID:
			PORTC = value;
    1b08:	e5 e3       	ldi	r30, 0x35	; 53
    1b0a:	f0 e0       	ldi	r31, 0x00	; 0
    1b0c:	8a 81       	ldd	r24, Y+2	; 0x02
    1b0e:	80 83       	st	Z, r24
    1b10:	04 c0       	rjmp	.+8      	; 0x1b1a <GPIO_writePort+0x7a>
			break;
		case PORTD_ID:
			PORTD = value;
    1b12:	e2 e3       	ldi	r30, 0x32	; 50
    1b14:	f0 e0       	ldi	r31, 0x00	; 0
    1b16:	8a 81       	ldd	r24, Y+2	; 0x02
    1b18:	80 83       	st	Z, r24
			break;
		default:
		            break;
		}
	}
}
    1b1a:	0f 90       	pop	r0
    1b1c:	0f 90       	pop	r0
    1b1e:	0f 90       	pop	r0
    1b20:	0f 90       	pop	r0
    1b22:	cf 91       	pop	r28
    1b24:	df 91       	pop	r29
    1b26:	08 95       	ret

00001b28 <GPIO_readPort>:
 * Description :
 * Read and return the value of the required port.
 * If the input port number is not correct, The function will return ZERO value.
 */
uint8 GPIO_readPort(uint8 port_num)
{
    1b28:	df 93       	push	r29
    1b2a:	cf 93       	push	r28
    1b2c:	00 d0       	rcall	.+0      	; 0x1b2e <GPIO_readPort+0x6>
    1b2e:	00 d0       	rcall	.+0      	; 0x1b30 <GPIO_readPort+0x8>
    1b30:	cd b7       	in	r28, 0x3d	; 61
    1b32:	de b7       	in	r29, 0x3e	; 62
    1b34:	8a 83       	std	Y+2, r24	; 0x02
	uint8 value = LOGIC_LOW;
    1b36:	19 82       	std	Y+1, r1	; 0x01

	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    1b38:	8a 81       	ldd	r24, Y+2	; 0x02
    1b3a:	84 30       	cpi	r24, 0x04	; 4
    1b3c:	90 f5       	brcc	.+100    	; 0x1ba2 <GPIO_readPort+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Read the port value as required */
		switch(port_num)
    1b3e:	8a 81       	ldd	r24, Y+2	; 0x02
    1b40:	28 2f       	mov	r18, r24
    1b42:	30 e0       	ldi	r19, 0x00	; 0
    1b44:	3c 83       	std	Y+4, r19	; 0x04
    1b46:	2b 83       	std	Y+3, r18	; 0x03
    1b48:	8b 81       	ldd	r24, Y+3	; 0x03
    1b4a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b4c:	81 30       	cpi	r24, 0x01	; 1
    1b4e:	91 05       	cpc	r25, r1
    1b50:	d1 f0       	breq	.+52     	; 0x1b86 <GPIO_readPort+0x5e>
    1b52:	2b 81       	ldd	r18, Y+3	; 0x03
    1b54:	3c 81       	ldd	r19, Y+4	; 0x04
    1b56:	22 30       	cpi	r18, 0x02	; 2
    1b58:	31 05       	cpc	r19, r1
    1b5a:	2c f4       	brge	.+10     	; 0x1b66 <GPIO_readPort+0x3e>
    1b5c:	8b 81       	ldd	r24, Y+3	; 0x03
    1b5e:	9c 81       	ldd	r25, Y+4	; 0x04
    1b60:	00 97       	sbiw	r24, 0x00	; 0
    1b62:	61 f0       	breq	.+24     	; 0x1b7c <GPIO_readPort+0x54>
    1b64:	1e c0       	rjmp	.+60     	; 0x1ba2 <GPIO_readPort+0x7a>
    1b66:	2b 81       	ldd	r18, Y+3	; 0x03
    1b68:	3c 81       	ldd	r19, Y+4	; 0x04
    1b6a:	22 30       	cpi	r18, 0x02	; 2
    1b6c:	31 05       	cpc	r19, r1
    1b6e:	81 f0       	breq	.+32     	; 0x1b90 <GPIO_readPort+0x68>
    1b70:	8b 81       	ldd	r24, Y+3	; 0x03
    1b72:	9c 81       	ldd	r25, Y+4	; 0x04
    1b74:	83 30       	cpi	r24, 0x03	; 3
    1b76:	91 05       	cpc	r25, r1
    1b78:	81 f0       	breq	.+32     	; 0x1b9a <GPIO_readPort+0x72>
    1b7a:	13 c0       	rjmp	.+38     	; 0x1ba2 <GPIO_readPort+0x7a>
		{
		case PORTA_ID:
			value = PINA;
    1b7c:	e9 e3       	ldi	r30, 0x39	; 57
    1b7e:	f0 e0       	ldi	r31, 0x00	; 0
    1b80:	80 81       	ld	r24, Z
    1b82:	89 83       	std	Y+1, r24	; 0x01
    1b84:	0e c0       	rjmp	.+28     	; 0x1ba2 <GPIO_readPort+0x7a>
			break;
		case PORTB_ID:
			value = PINB;
    1b86:	e6 e3       	ldi	r30, 0x36	; 54
    1b88:	f0 e0       	ldi	r31, 0x00	; 0
    1b8a:	80 81       	ld	r24, Z
    1b8c:	89 83       	std	Y+1, r24	; 0x01
    1b8e:	09 c0       	rjmp	.+18     	; 0x1ba2 <GPIO_readPort+0x7a>
			break;
		case PORTC_ID:
			value = PINC;
    1b90:	e3 e3       	ldi	r30, 0x33	; 51
    1b92:	f0 e0       	ldi	r31, 0x00	; 0
    1b94:	80 81       	ld	r24, Z
    1b96:	89 83       	std	Y+1, r24	; 0x01
    1b98:	04 c0       	rjmp	.+8      	; 0x1ba2 <GPIO_readPort+0x7a>
			break;
		case PORTD_ID:
			value = PIND;
    1b9a:	e0 e3       	ldi	r30, 0x30	; 48
    1b9c:	f0 e0       	ldi	r31, 0x00	; 0
    1b9e:	80 81       	ld	r24, Z
    1ba0:	89 83       	std	Y+1, r24	; 0x01
		default:
		            break;
		}
	}

	return value;
    1ba2:	89 81       	ldd	r24, Y+1	; 0x01
}
    1ba4:	0f 90       	pop	r0
    1ba6:	0f 90       	pop	r0
    1ba8:	0f 90       	pop	r0
    1baa:	0f 90       	pop	r0
    1bac:	cf 91       	pop	r28
    1bae:	df 91       	pop	r29
    1bb0:	08 95       	ret

00001bb2 <Scheduler_RTOS_LED_Blink_AVR323>:

TaskHandle_t task1ptr;
TaskHandle_t task2ptr;
TaskHandle_t task3ptr;

void Scheduler_RTOS_LED_Blink_AVR323(void){
    1bb2:	ef 92       	push	r14
    1bb4:	ff 92       	push	r15
    1bb6:	0f 93       	push	r16
    1bb8:	df 93       	push	r29
    1bba:	cf 93       	push	r28
    1bbc:	cd b7       	in	r28, 0x3d	; 61
    1bbe:	de b7       	in	r29, 0x3e	; 62
	GPIO_setupPortDirection(PORTC_ID, PORT_OUTPUT);
    1bc0:	82 e0       	ldi	r24, 0x02	; 2
    1bc2:	6f ef       	ldi	r22, 0xFF	; 255
    1bc4:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <GPIO_setupPortDirection>
	xTaskCreate(Task1_Func,"first",configMINIMAL_STACK_SIZE,NULL,1,&task1ptr);
    1bc8:	89 e1       	ldi	r24, 0x19	; 25
    1bca:	9e e0       	ldi	r25, 0x0E	; 14
    1bcc:	20 e6       	ldi	r18, 0x60	; 96
    1bce:	30 e0       	ldi	r19, 0x00	; 0
    1bd0:	e4 ec       	ldi	r30, 0xC4	; 196
    1bd2:	f7 e0       	ldi	r31, 0x07	; 7
    1bd4:	b9 01       	movw	r22, r18
    1bd6:	45 e5       	ldi	r20, 0x55	; 85
    1bd8:	50 e0       	ldi	r21, 0x00	; 0
    1bda:	20 e0       	ldi	r18, 0x00	; 0
    1bdc:	30 e0       	ldi	r19, 0x00	; 0
    1bde:	01 e0       	ldi	r16, 0x01	; 1
    1be0:	7f 01       	movw	r14, r30
    1be2:	0e 94 4b 22 	call	0x4496	; 0x4496 <xTaskCreate>
	xTaskCreate(Task2_Func,"second",configMINIMAL_STACK_SIZE,NULL,1,&task2ptr);
    1be6:	86 e2       	ldi	r24, 0x26	; 38
    1be8:	9e e0       	ldi	r25, 0x0E	; 14
    1bea:	26 e6       	ldi	r18, 0x66	; 102
    1bec:	30 e0       	ldi	r19, 0x00	; 0
    1bee:	e2 ec       	ldi	r30, 0xC2	; 194
    1bf0:	f7 e0       	ldi	r31, 0x07	; 7
    1bf2:	b9 01       	movw	r22, r18
    1bf4:	45 e5       	ldi	r20, 0x55	; 85
    1bf6:	50 e0       	ldi	r21, 0x00	; 0
    1bf8:	20 e0       	ldi	r18, 0x00	; 0
    1bfa:	30 e0       	ldi	r19, 0x00	; 0
    1bfc:	01 e0       	ldi	r16, 0x01	; 1
    1bfe:	7f 01       	movw	r14, r30
    1c00:	0e 94 4b 22 	call	0x4496	; 0x4496 <xTaskCreate>
	xTaskCreate(Task3_Func,"third",configMINIMAL_STACK_SIZE,NULL,1,&task3ptr);
    1c04:	83 e3       	ldi	r24, 0x33	; 51
    1c06:	9e e0       	ldi	r25, 0x0E	; 14
    1c08:	2d e6       	ldi	r18, 0x6D	; 109
    1c0a:	30 e0       	ldi	r19, 0x00	; 0
    1c0c:	e0 ec       	ldi	r30, 0xC0	; 192
    1c0e:	f7 e0       	ldi	r31, 0x07	; 7
    1c10:	b9 01       	movw	r22, r18
    1c12:	45 e5       	ldi	r20, 0x55	; 85
    1c14:	50 e0       	ldi	r21, 0x00	; 0
    1c16:	20 e0       	ldi	r18, 0x00	; 0
    1c18:	30 e0       	ldi	r19, 0x00	; 0
    1c1a:	01 e0       	ldi	r16, 0x01	; 1
    1c1c:	7f 01       	movw	r14, r30
    1c1e:	0e 94 4b 22 	call	0x4496	; 0x4496 <xTaskCreate>
	vTaskStartScheduler();
    1c22:	0e 94 55 25 	call	0x4aaa	; 0x4aaa <vTaskStartScheduler>
}
    1c26:	cf 91       	pop	r28
    1c28:	df 91       	pop	r29
    1c2a:	0f 91       	pop	r16
    1c2c:	ff 90       	pop	r15
    1c2e:	ef 90       	pop	r14
    1c30:	08 95       	ret

00001c32 <Task1_Func>:


void Task1_Func(void)
{
    1c32:	df 93       	push	r29
    1c34:	cf 93       	push	r28
    1c36:	cd b7       	in	r28, 0x3d	; 61
    1c38:	de b7       	in	r29, 0x3e	; 62
	while(1)
	{
		GPIO_TogglePin(PORTC_ID,PIN1_ID);
    1c3a:	82 e0       	ldi	r24, 0x02	; 2
    1c3c:	61 e0       	ldi	r22, 0x01	; 1
    1c3e:	0e 94 ec 0b 	call	0x17d8	; 0x17d8 <GPIO_TogglePin>
		vTaskDelay(100);
    1c42:	84 e6       	ldi	r24, 0x64	; 100
    1c44:	90 e0       	ldi	r25, 0x00	; 0
    1c46:	0e 94 33 25 	call	0x4a66	; 0x4a66 <vTaskDelay>
    1c4a:	f7 cf       	rjmp	.-18     	; 0x1c3a <Task1_Func+0x8>

00001c4c <Task2_Func>:
	}
}

void Task2_Func(void)
{
    1c4c:	df 93       	push	r29
    1c4e:	cf 93       	push	r28
    1c50:	cd b7       	in	r28, 0x3d	; 61
    1c52:	de b7       	in	r29, 0x3e	; 62

	while(1)
	{
		GPIO_TogglePin(PORTC_ID,PIN4_ID);
    1c54:	82 e0       	ldi	r24, 0x02	; 2
    1c56:	64 e0       	ldi	r22, 0x04	; 4
    1c58:	0e 94 ec 0b 	call	0x17d8	; 0x17d8 <GPIO_TogglePin>
		vTaskDelay(100);
    1c5c:	84 e6       	ldi	r24, 0x64	; 100
    1c5e:	90 e0       	ldi	r25, 0x00	; 0
    1c60:	0e 94 33 25 	call	0x4a66	; 0x4a66 <vTaskDelay>
    1c64:	f7 cf       	rjmp	.-18     	; 0x1c54 <Task2_Func+0x8>

00001c66 <Task3_Func>:
	}
}


void Task3_Func(void)
{
    1c66:	df 93       	push	r29
    1c68:	cf 93       	push	r28
    1c6a:	cd b7       	in	r28, 0x3d	; 61
    1c6c:	de b7       	in	r29, 0x3e	; 62

	while(1)
	{
		GPIO_TogglePin(PORTC_ID,PIN7_ID);
    1c6e:	82 e0       	ldi	r24, 0x02	; 2
    1c70:	67 e0       	ldi	r22, 0x07	; 7
    1c72:	0e 94 ec 0b 	call	0x17d8	; 0x17d8 <GPIO_TogglePin>
		vTaskDelay(100);
    1c76:	84 e6       	ldi	r24, 0x64	; 100
    1c78:	90 e0       	ldi	r25, 0x00	; 0
    1c7a:	0e 94 33 25 	call	0x4a66	; 0x4a66 <vTaskDelay>
    1c7e:	f7 cf       	rjmp	.-18     	; 0x1c6e <Task3_Func+0x8>

00001c80 <main>:
	}

}

int main(void)
{
    1c80:	df 93       	push	r29
    1c82:	cf 93       	push	r28
    1c84:	cd b7       	in	r28, 0x3d	; 61
    1c86:	de b7       	in	r29, 0x3e	; 62

	Scheduler_RTOS_LED_Blink_AVR323();
    1c88:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <Scheduler_RTOS_LED_Blink_AVR323>
    1c8c:	ff cf       	rjmp	.-2      	; 0x1c8c <main+0xc>

00001c8e <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
    1c8e:	df 93       	push	r29
    1c90:	cf 93       	push	r28
    1c92:	00 d0       	rcall	.+0      	; 0x1c94 <pvPortMalloc+0x6>
    1c94:	00 d0       	rcall	.+0      	; 0x1c96 <pvPortMalloc+0x8>
    1c96:	cd b7       	in	r28, 0x3d	; 61
    1c98:	de b7       	in	r29, 0x3e	; 62
    1c9a:	9c 83       	std	Y+4, r25	; 0x04
    1c9c:	8b 83       	std	Y+3, r24	; 0x03
    void * pvReturn = NULL;
    1c9e:	1a 82       	std	Y+2, r1	; 0x02
    1ca0:	19 82       	std	Y+1, r1	; 0x01
                }
            }
        }
    #endif

    vTaskSuspendAll();
    1ca2:	0e 94 9c 25 	call	0x4b38	; 0x4b38 <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
    1ca6:	80 91 2e 01 	lds	r24, 0x012E
    1caa:	90 91 2f 01 	lds	r25, 0x012F
    1cae:	00 97       	sbiw	r24, 0x00	; 0
    1cb0:	31 f4       	brne	.+12     	; 0x1cbe <pvPortMalloc+0x30>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1cb2:	80 e3       	ldi	r24, 0x30	; 48
    1cb4:	91 e0       	ldi	r25, 0x01	; 1
    1cb6:	90 93 2f 01 	sts	0x012F, r25
    1cba:	80 93 2e 01 	sts	0x012E, r24
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) && /* valid size */
    1cbe:	8b 81       	ldd	r24, Y+3	; 0x03
    1cc0:	9c 81       	ldd	r25, Y+4	; 0x04
    1cc2:	00 97       	sbiw	r24, 0x00	; 0
    1cc4:	99 f1       	breq	.+102    	; 0x1d2c <pvPortMalloc+0x9e>
    1cc6:	80 91 2c 01 	lds	r24, 0x012C
    1cca:	90 91 2d 01 	lds	r25, 0x012D
    1cce:	2b 81       	ldd	r18, Y+3	; 0x03
    1cd0:	3c 81       	ldd	r19, Y+4	; 0x04
    1cd2:	82 0f       	add	r24, r18
    1cd4:	93 1f       	adc	r25, r19
    1cd6:	25 e0       	ldi	r18, 0x05	; 5
    1cd8:	8b 3d       	cpi	r24, 0xDB	; 219
    1cda:	92 07       	cpc	r25, r18
    1cdc:	38 f5       	brcc	.+78     	; 0x1d2c <pvPortMalloc+0x9e>
    1cde:	20 91 2c 01 	lds	r18, 0x012C
    1ce2:	30 91 2d 01 	lds	r19, 0x012D
    1ce6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ce8:	9c 81       	ldd	r25, Y+4	; 0x04
    1cea:	28 0f       	add	r18, r24
    1cec:	39 1f       	adc	r19, r25
    1cee:	80 91 2c 01 	lds	r24, 0x012C
    1cf2:	90 91 2d 01 	lds	r25, 0x012D
    1cf6:	82 17       	cp	r24, r18
    1cf8:	93 07       	cpc	r25, r19
    1cfa:	c0 f4       	brcc	.+48     	; 0x1d2c <pvPortMalloc+0x9e>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
    1cfc:	20 91 2e 01 	lds	r18, 0x012E
    1d00:	30 91 2f 01 	lds	r19, 0x012F
    1d04:	80 91 2c 01 	lds	r24, 0x012C
    1d08:	90 91 2d 01 	lds	r25, 0x012D
    1d0c:	82 0f       	add	r24, r18
    1d0e:	93 1f       	adc	r25, r19
    1d10:	9a 83       	std	Y+2, r25	; 0x02
    1d12:	89 83       	std	Y+1, r24	; 0x01
            xNextFreeByte += xWantedSize;
    1d14:	20 91 2c 01 	lds	r18, 0x012C
    1d18:	30 91 2d 01 	lds	r19, 0x012D
    1d1c:	8b 81       	ldd	r24, Y+3	; 0x03
    1d1e:	9c 81       	ldd	r25, Y+4	; 0x04
    1d20:	82 0f       	add	r24, r18
    1d22:	93 1f       	adc	r25, r19
    1d24:	90 93 2d 01 	sts	0x012D, r25
    1d28:	80 93 2c 01 	sts	0x012C, r24
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    1d2c:	0e 94 a8 25 	call	0x4b50	; 0x4b50 <xTaskResumeAll>
                vApplicationMallocFailedHook();
            }
        }
    #endif

    return pvReturn;
    1d30:	89 81       	ldd	r24, Y+1	; 0x01
    1d32:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1d34:	0f 90       	pop	r0
    1d36:	0f 90       	pop	r0
    1d38:	0f 90       	pop	r0
    1d3a:	0f 90       	pop	r0
    1d3c:	cf 91       	pop	r28
    1d3e:	df 91       	pop	r29
    1d40:	08 95       	ret

00001d42 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
    1d42:	df 93       	push	r29
    1d44:	cf 93       	push	r28
    1d46:	00 d0       	rcall	.+0      	; 0x1d48 <vPortFree+0x6>
    1d48:	cd b7       	in	r28, 0x3d	; 61
    1d4a:	de b7       	in	r29, 0x3e	; 62
    1d4c:	9a 83       	std	Y+2, r25	; 0x02
    1d4e:	89 83       	std	Y+1, r24	; 0x01
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
    1d50:	0f 90       	pop	r0
    1d52:	0f 90       	pop	r0
    1d54:	cf 91       	pop	r28
    1d56:	df 91       	pop	r29
    1d58:	08 95       	ret

00001d5a <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    1d5a:	df 93       	push	r29
    1d5c:	cf 93       	push	r28
    1d5e:	cd b7       	in	r28, 0x3d	; 61
    1d60:	de b7       	in	r29, 0x3e	; 62
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
    1d62:	10 92 2d 01 	sts	0x012D, r1
    1d66:	10 92 2c 01 	sts	0x012C, r1
}
    1d6a:	cf 91       	pop	r28
    1d6c:	df 91       	pop	r29
    1d6e:	08 95       	ret

00001d70 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1d70:	df 93       	push	r29
    1d72:	cf 93       	push	r28
    1d74:	cd b7       	in	r28, 0x3d	; 61
    1d76:	de b7       	in	r29, 0x3e	; 62
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    1d78:	20 91 2c 01 	lds	r18, 0x012C
    1d7c:	30 91 2d 01 	lds	r19, 0x012D
    1d80:	8b ed       	ldi	r24, 0xDB	; 219
    1d82:	95 e0       	ldi	r25, 0x05	; 5
    1d84:	82 1b       	sub	r24, r18
    1d86:	93 0b       	sbc	r25, r19
}
    1d88:	cf 91       	pop	r28
    1d8a:	df 91       	pop	r29
    1d8c:	08 95       	ret

00001d8e <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1d8e:	df 93       	push	r29
    1d90:	cf 93       	push	r28
    1d92:	cd b7       	in	r28, 0x3d	; 61
    1d94:	de b7       	in	r29, 0x3e	; 62
    1d96:	28 97       	sbiw	r28, 0x08	; 8
    1d98:	0f b6       	in	r0, 0x3f	; 63
    1d9a:	f8 94       	cli
    1d9c:	de bf       	out	0x3e, r29	; 62
    1d9e:	0f be       	out	0x3f, r0	; 63
    1da0:	cd bf       	out	0x3d, r28	; 61
    1da2:	9c 83       	std	Y+4, r25	; 0x04
    1da4:	8b 83       	std	Y+3, r24	; 0x03
    1da6:	7e 83       	std	Y+6, r23	; 0x06
    1da8:	6d 83       	std	Y+5, r22	; 0x05
    1daa:	58 87       	std	Y+8, r21	; 0x08
    1dac:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1dae:	eb 81       	ldd	r30, Y+3	; 0x03
    1db0:	fc 81       	ldd	r31, Y+4	; 0x04
    1db2:	81 e1       	ldi	r24, 0x11	; 17
    1db4:	80 83       	st	Z, r24
	pxTopOfStack--;
    1db6:	8b 81       	ldd	r24, Y+3	; 0x03
    1db8:	9c 81       	ldd	r25, Y+4	; 0x04
    1dba:	01 97       	sbiw	r24, 0x01	; 1
    1dbc:	9c 83       	std	Y+4, r25	; 0x04
    1dbe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1dc0:	eb 81       	ldd	r30, Y+3	; 0x03
    1dc2:	fc 81       	ldd	r31, Y+4	; 0x04
    1dc4:	82 e2       	ldi	r24, 0x22	; 34
    1dc6:	80 83       	st	Z, r24
	pxTopOfStack--;
    1dc8:	8b 81       	ldd	r24, Y+3	; 0x03
    1dca:	9c 81       	ldd	r25, Y+4	; 0x04
    1dcc:	01 97       	sbiw	r24, 0x01	; 1
    1dce:	9c 83       	std	Y+4, r25	; 0x04
    1dd0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1dd2:	eb 81       	ldd	r30, Y+3	; 0x03
    1dd4:	fc 81       	ldd	r31, Y+4	; 0x04
    1dd6:	83 e3       	ldi	r24, 0x33	; 51
    1dd8:	80 83       	st	Z, r24
	pxTopOfStack--;
    1dda:	8b 81       	ldd	r24, Y+3	; 0x03
    1ddc:	9c 81       	ldd	r25, Y+4	; 0x04
    1dde:	01 97       	sbiw	r24, 0x01	; 1
    1de0:	9c 83       	std	Y+4, r25	; 0x04
    1de2:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    1de4:	8d 81       	ldd	r24, Y+5	; 0x05
    1de6:	9e 81       	ldd	r25, Y+6	; 0x06
    1de8:	9a 83       	std	Y+2, r25	; 0x02
    1dea:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1dec:	89 81       	ldd	r24, Y+1	; 0x01
    1dee:	eb 81       	ldd	r30, Y+3	; 0x03
    1df0:	fc 81       	ldd	r31, Y+4	; 0x04
    1df2:	80 83       	st	Z, r24
	pxTopOfStack--;
    1df4:	8b 81       	ldd	r24, Y+3	; 0x03
    1df6:	9c 81       	ldd	r25, Y+4	; 0x04
    1df8:	01 97       	sbiw	r24, 0x01	; 1
    1dfa:	9c 83       	std	Y+4, r25	; 0x04
    1dfc:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1dfe:	89 81       	ldd	r24, Y+1	; 0x01
    1e00:	9a 81       	ldd	r25, Y+2	; 0x02
    1e02:	89 2f       	mov	r24, r25
    1e04:	99 27       	eor	r25, r25
    1e06:	9a 83       	std	Y+2, r25	; 0x02
    1e08:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1e0a:	89 81       	ldd	r24, Y+1	; 0x01
    1e0c:	eb 81       	ldd	r30, Y+3	; 0x03
    1e0e:	fc 81       	ldd	r31, Y+4	; 0x04
    1e10:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e12:	8b 81       	ldd	r24, Y+3	; 0x03
    1e14:	9c 81       	ldd	r25, Y+4	; 0x04
    1e16:	01 97       	sbiw	r24, 0x01	; 1
    1e18:	9c 83       	std	Y+4, r25	; 0x04
    1e1a:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    1e1c:	eb 81       	ldd	r30, Y+3	; 0x03
    1e1e:	fc 81       	ldd	r31, Y+4	; 0x04
    1e20:	10 82       	st	Z, r1
	pxTopOfStack--;
    1e22:	8b 81       	ldd	r24, Y+3	; 0x03
    1e24:	9c 81       	ldd	r25, Y+4	; 0x04
    1e26:	01 97       	sbiw	r24, 0x01	; 1
    1e28:	9c 83       	std	Y+4, r25	; 0x04
    1e2a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1e2c:	eb 81       	ldd	r30, Y+3	; 0x03
    1e2e:	fc 81       	ldd	r31, Y+4	; 0x04
    1e30:	80 e8       	ldi	r24, 0x80	; 128
    1e32:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e34:	8b 81       	ldd	r24, Y+3	; 0x03
    1e36:	9c 81       	ldd	r25, Y+4	; 0x04
    1e38:	01 97       	sbiw	r24, 0x01	; 1
    1e3a:	9c 83       	std	Y+4, r25	; 0x04
    1e3c:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1e3e:	eb 81       	ldd	r30, Y+3	; 0x03
    1e40:	fc 81       	ldd	r31, Y+4	; 0x04
    1e42:	10 82       	st	Z, r1
	pxTopOfStack--;
    1e44:	8b 81       	ldd	r24, Y+3	; 0x03
    1e46:	9c 81       	ldd	r25, Y+4	; 0x04
    1e48:	01 97       	sbiw	r24, 0x01	; 1
    1e4a:	9c 83       	std	Y+4, r25	; 0x04
    1e4c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1e4e:	eb 81       	ldd	r30, Y+3	; 0x03
    1e50:	fc 81       	ldd	r31, Y+4	; 0x04
    1e52:	82 e0       	ldi	r24, 0x02	; 2
    1e54:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e56:	8b 81       	ldd	r24, Y+3	; 0x03
    1e58:	9c 81       	ldd	r25, Y+4	; 0x04
    1e5a:	01 97       	sbiw	r24, 0x01	; 1
    1e5c:	9c 83       	std	Y+4, r25	; 0x04
    1e5e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1e60:	eb 81       	ldd	r30, Y+3	; 0x03
    1e62:	fc 81       	ldd	r31, Y+4	; 0x04
    1e64:	83 e0       	ldi	r24, 0x03	; 3
    1e66:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e68:	8b 81       	ldd	r24, Y+3	; 0x03
    1e6a:	9c 81       	ldd	r25, Y+4	; 0x04
    1e6c:	01 97       	sbiw	r24, 0x01	; 1
    1e6e:	9c 83       	std	Y+4, r25	; 0x04
    1e70:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    1e72:	eb 81       	ldd	r30, Y+3	; 0x03
    1e74:	fc 81       	ldd	r31, Y+4	; 0x04
    1e76:	84 e0       	ldi	r24, 0x04	; 4
    1e78:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e7a:	8b 81       	ldd	r24, Y+3	; 0x03
    1e7c:	9c 81       	ldd	r25, Y+4	; 0x04
    1e7e:	01 97       	sbiw	r24, 0x01	; 1
    1e80:	9c 83       	std	Y+4, r25	; 0x04
    1e82:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    1e84:	eb 81       	ldd	r30, Y+3	; 0x03
    1e86:	fc 81       	ldd	r31, Y+4	; 0x04
    1e88:	85 e0       	ldi	r24, 0x05	; 5
    1e8a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e8c:	8b 81       	ldd	r24, Y+3	; 0x03
    1e8e:	9c 81       	ldd	r25, Y+4	; 0x04
    1e90:	01 97       	sbiw	r24, 0x01	; 1
    1e92:	9c 83       	std	Y+4, r25	; 0x04
    1e94:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1e96:	eb 81       	ldd	r30, Y+3	; 0x03
    1e98:	fc 81       	ldd	r31, Y+4	; 0x04
    1e9a:	86 e0       	ldi	r24, 0x06	; 6
    1e9c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e9e:	8b 81       	ldd	r24, Y+3	; 0x03
    1ea0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ea2:	01 97       	sbiw	r24, 0x01	; 1
    1ea4:	9c 83       	std	Y+4, r25	; 0x04
    1ea6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1ea8:	eb 81       	ldd	r30, Y+3	; 0x03
    1eaa:	fc 81       	ldd	r31, Y+4	; 0x04
    1eac:	87 e0       	ldi	r24, 0x07	; 7
    1eae:	80 83       	st	Z, r24
	pxTopOfStack--;
    1eb0:	8b 81       	ldd	r24, Y+3	; 0x03
    1eb2:	9c 81       	ldd	r25, Y+4	; 0x04
    1eb4:	01 97       	sbiw	r24, 0x01	; 1
    1eb6:	9c 83       	std	Y+4, r25	; 0x04
    1eb8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    1eba:	eb 81       	ldd	r30, Y+3	; 0x03
    1ebc:	fc 81       	ldd	r31, Y+4	; 0x04
    1ebe:	88 e0       	ldi	r24, 0x08	; 8
    1ec0:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ec2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ec4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ec6:	01 97       	sbiw	r24, 0x01	; 1
    1ec8:	9c 83       	std	Y+4, r25	; 0x04
    1eca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1ecc:	eb 81       	ldd	r30, Y+3	; 0x03
    1ece:	fc 81       	ldd	r31, Y+4	; 0x04
    1ed0:	89 e0       	ldi	r24, 0x09	; 9
    1ed2:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ed4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ed6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ed8:	01 97       	sbiw	r24, 0x01	; 1
    1eda:	9c 83       	std	Y+4, r25	; 0x04
    1edc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1ede:	eb 81       	ldd	r30, Y+3	; 0x03
    1ee0:	fc 81       	ldd	r31, Y+4	; 0x04
    1ee2:	80 e1       	ldi	r24, 0x10	; 16
    1ee4:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ee6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ee8:	9c 81       	ldd	r25, Y+4	; 0x04
    1eea:	01 97       	sbiw	r24, 0x01	; 1
    1eec:	9c 83       	std	Y+4, r25	; 0x04
    1eee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1ef0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ef2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ef4:	81 e1       	ldi	r24, 0x11	; 17
    1ef6:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ef8:	8b 81       	ldd	r24, Y+3	; 0x03
    1efa:	9c 81       	ldd	r25, Y+4	; 0x04
    1efc:	01 97       	sbiw	r24, 0x01	; 1
    1efe:	9c 83       	std	Y+4, r25	; 0x04
    1f00:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1f02:	eb 81       	ldd	r30, Y+3	; 0x03
    1f04:	fc 81       	ldd	r31, Y+4	; 0x04
    1f06:	82 e1       	ldi	r24, 0x12	; 18
    1f08:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f0a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f0c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f0e:	01 97       	sbiw	r24, 0x01	; 1
    1f10:	9c 83       	std	Y+4, r25	; 0x04
    1f12:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1f14:	eb 81       	ldd	r30, Y+3	; 0x03
    1f16:	fc 81       	ldd	r31, Y+4	; 0x04
    1f18:	83 e1       	ldi	r24, 0x13	; 19
    1f1a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f1c:	8b 81       	ldd	r24, Y+3	; 0x03
    1f1e:	9c 81       	ldd	r25, Y+4	; 0x04
    1f20:	01 97       	sbiw	r24, 0x01	; 1
    1f22:	9c 83       	std	Y+4, r25	; 0x04
    1f24:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    1f26:	eb 81       	ldd	r30, Y+3	; 0x03
    1f28:	fc 81       	ldd	r31, Y+4	; 0x04
    1f2a:	84 e1       	ldi	r24, 0x14	; 20
    1f2c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f2e:	8b 81       	ldd	r24, Y+3	; 0x03
    1f30:	9c 81       	ldd	r25, Y+4	; 0x04
    1f32:	01 97       	sbiw	r24, 0x01	; 1
    1f34:	9c 83       	std	Y+4, r25	; 0x04
    1f36:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1f38:	eb 81       	ldd	r30, Y+3	; 0x03
    1f3a:	fc 81       	ldd	r31, Y+4	; 0x04
    1f3c:	85 e1       	ldi	r24, 0x15	; 21
    1f3e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f40:	8b 81       	ldd	r24, Y+3	; 0x03
    1f42:	9c 81       	ldd	r25, Y+4	; 0x04
    1f44:	01 97       	sbiw	r24, 0x01	; 1
    1f46:	9c 83       	std	Y+4, r25	; 0x04
    1f48:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    1f4a:	eb 81       	ldd	r30, Y+3	; 0x03
    1f4c:	fc 81       	ldd	r31, Y+4	; 0x04
    1f4e:	86 e1       	ldi	r24, 0x16	; 22
    1f50:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f52:	8b 81       	ldd	r24, Y+3	; 0x03
    1f54:	9c 81       	ldd	r25, Y+4	; 0x04
    1f56:	01 97       	sbiw	r24, 0x01	; 1
    1f58:	9c 83       	std	Y+4, r25	; 0x04
    1f5a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    1f5c:	eb 81       	ldd	r30, Y+3	; 0x03
    1f5e:	fc 81       	ldd	r31, Y+4	; 0x04
    1f60:	87 e1       	ldi	r24, 0x17	; 23
    1f62:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f64:	8b 81       	ldd	r24, Y+3	; 0x03
    1f66:	9c 81       	ldd	r25, Y+4	; 0x04
    1f68:	01 97       	sbiw	r24, 0x01	; 1
    1f6a:	9c 83       	std	Y+4, r25	; 0x04
    1f6c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    1f6e:	eb 81       	ldd	r30, Y+3	; 0x03
    1f70:	fc 81       	ldd	r31, Y+4	; 0x04
    1f72:	88 e1       	ldi	r24, 0x18	; 24
    1f74:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f76:	8b 81       	ldd	r24, Y+3	; 0x03
    1f78:	9c 81       	ldd	r25, Y+4	; 0x04
    1f7a:	01 97       	sbiw	r24, 0x01	; 1
    1f7c:	9c 83       	std	Y+4, r25	; 0x04
    1f7e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    1f80:	eb 81       	ldd	r30, Y+3	; 0x03
    1f82:	fc 81       	ldd	r31, Y+4	; 0x04
    1f84:	89 e1       	ldi	r24, 0x19	; 25
    1f86:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f88:	8b 81       	ldd	r24, Y+3	; 0x03
    1f8a:	9c 81       	ldd	r25, Y+4	; 0x04
    1f8c:	01 97       	sbiw	r24, 0x01	; 1
    1f8e:	9c 83       	std	Y+4, r25	; 0x04
    1f90:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    1f92:	eb 81       	ldd	r30, Y+3	; 0x03
    1f94:	fc 81       	ldd	r31, Y+4	; 0x04
    1f96:	80 e2       	ldi	r24, 0x20	; 32
    1f98:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f9a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f9c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f9e:	01 97       	sbiw	r24, 0x01	; 1
    1fa0:	9c 83       	std	Y+4, r25	; 0x04
    1fa2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    1fa4:	eb 81       	ldd	r30, Y+3	; 0x03
    1fa6:	fc 81       	ldd	r31, Y+4	; 0x04
    1fa8:	81 e2       	ldi	r24, 0x21	; 33
    1faa:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fac:	8b 81       	ldd	r24, Y+3	; 0x03
    1fae:	9c 81       	ldd	r25, Y+4	; 0x04
    1fb0:	01 97       	sbiw	r24, 0x01	; 1
    1fb2:	9c 83       	std	Y+4, r25	; 0x04
    1fb4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    1fb6:	eb 81       	ldd	r30, Y+3	; 0x03
    1fb8:	fc 81       	ldd	r31, Y+4	; 0x04
    1fba:	82 e2       	ldi	r24, 0x22	; 34
    1fbc:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fbe:	8b 81       	ldd	r24, Y+3	; 0x03
    1fc0:	9c 81       	ldd	r25, Y+4	; 0x04
    1fc2:	01 97       	sbiw	r24, 0x01	; 1
    1fc4:	9c 83       	std	Y+4, r25	; 0x04
    1fc6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    1fc8:	eb 81       	ldd	r30, Y+3	; 0x03
    1fca:	fc 81       	ldd	r31, Y+4	; 0x04
    1fcc:	83 e2       	ldi	r24, 0x23	; 35
    1fce:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fd0:	8b 81       	ldd	r24, Y+3	; 0x03
    1fd2:	9c 81       	ldd	r25, Y+4	; 0x04
    1fd4:	01 97       	sbiw	r24, 0x01	; 1
    1fd6:	9c 83       	std	Y+4, r25	; 0x04
    1fd8:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    1fda:	8f 81       	ldd	r24, Y+7	; 0x07
    1fdc:	98 85       	ldd	r25, Y+8	; 0x08
    1fde:	9a 83       	std	Y+2, r25	; 0x02
    1fe0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1fe2:	89 81       	ldd	r24, Y+1	; 0x01
    1fe4:	eb 81       	ldd	r30, Y+3	; 0x03
    1fe6:	fc 81       	ldd	r31, Y+4	; 0x04
    1fe8:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fea:	8b 81       	ldd	r24, Y+3	; 0x03
    1fec:	9c 81       	ldd	r25, Y+4	; 0x04
    1fee:	01 97       	sbiw	r24, 0x01	; 1
    1ff0:	9c 83       	std	Y+4, r25	; 0x04
    1ff2:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1ff4:	89 81       	ldd	r24, Y+1	; 0x01
    1ff6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ff8:	89 2f       	mov	r24, r25
    1ffa:	99 27       	eor	r25, r25
    1ffc:	9a 83       	std	Y+2, r25	; 0x02
    1ffe:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2000:	89 81       	ldd	r24, Y+1	; 0x01
    2002:	eb 81       	ldd	r30, Y+3	; 0x03
    2004:	fc 81       	ldd	r31, Y+4	; 0x04
    2006:	80 83       	st	Z, r24
	pxTopOfStack--;
    2008:	8b 81       	ldd	r24, Y+3	; 0x03
    200a:	9c 81       	ldd	r25, Y+4	; 0x04
    200c:	01 97       	sbiw	r24, 0x01	; 1
    200e:	9c 83       	std	Y+4, r25	; 0x04
    2010:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    2012:	eb 81       	ldd	r30, Y+3	; 0x03
    2014:	fc 81       	ldd	r31, Y+4	; 0x04
    2016:	86 e2       	ldi	r24, 0x26	; 38
    2018:	80 83       	st	Z, r24
	pxTopOfStack--;
    201a:	8b 81       	ldd	r24, Y+3	; 0x03
    201c:	9c 81       	ldd	r25, Y+4	; 0x04
    201e:	01 97       	sbiw	r24, 0x01	; 1
    2020:	9c 83       	std	Y+4, r25	; 0x04
    2022:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2024:	eb 81       	ldd	r30, Y+3	; 0x03
    2026:	fc 81       	ldd	r31, Y+4	; 0x04
    2028:	87 e2       	ldi	r24, 0x27	; 39
    202a:	80 83       	st	Z, r24
	pxTopOfStack--;
    202c:	8b 81       	ldd	r24, Y+3	; 0x03
    202e:	9c 81       	ldd	r25, Y+4	; 0x04
    2030:	01 97       	sbiw	r24, 0x01	; 1
    2032:	9c 83       	std	Y+4, r25	; 0x04
    2034:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2036:	eb 81       	ldd	r30, Y+3	; 0x03
    2038:	fc 81       	ldd	r31, Y+4	; 0x04
    203a:	88 e2       	ldi	r24, 0x28	; 40
    203c:	80 83       	st	Z, r24
	pxTopOfStack--;
    203e:	8b 81       	ldd	r24, Y+3	; 0x03
    2040:	9c 81       	ldd	r25, Y+4	; 0x04
    2042:	01 97       	sbiw	r24, 0x01	; 1
    2044:	9c 83       	std	Y+4, r25	; 0x04
    2046:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2048:	eb 81       	ldd	r30, Y+3	; 0x03
    204a:	fc 81       	ldd	r31, Y+4	; 0x04
    204c:	89 e2       	ldi	r24, 0x29	; 41
    204e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2050:	8b 81       	ldd	r24, Y+3	; 0x03
    2052:	9c 81       	ldd	r25, Y+4	; 0x04
    2054:	01 97       	sbiw	r24, 0x01	; 1
    2056:	9c 83       	std	Y+4, r25	; 0x04
    2058:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    205a:	eb 81       	ldd	r30, Y+3	; 0x03
    205c:	fc 81       	ldd	r31, Y+4	; 0x04
    205e:	80 e3       	ldi	r24, 0x30	; 48
    2060:	80 83       	st	Z, r24
	pxTopOfStack--;
    2062:	8b 81       	ldd	r24, Y+3	; 0x03
    2064:	9c 81       	ldd	r25, Y+4	; 0x04
    2066:	01 97       	sbiw	r24, 0x01	; 1
    2068:	9c 83       	std	Y+4, r25	; 0x04
    206a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    206c:	eb 81       	ldd	r30, Y+3	; 0x03
    206e:	fc 81       	ldd	r31, Y+4	; 0x04
    2070:	81 e3       	ldi	r24, 0x31	; 49
    2072:	80 83       	st	Z, r24
	pxTopOfStack--;
    2074:	8b 81       	ldd	r24, Y+3	; 0x03
    2076:	9c 81       	ldd	r25, Y+4	; 0x04
    2078:	01 97       	sbiw	r24, 0x01	; 1
    207a:	9c 83       	std	Y+4, r25	; 0x04
    207c:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    207e:	8b 81       	ldd	r24, Y+3	; 0x03
    2080:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2082:	28 96       	adiw	r28, 0x08	; 8
    2084:	0f b6       	in	r0, 0x3f	; 63
    2086:	f8 94       	cli
    2088:	de bf       	out	0x3e, r29	; 62
    208a:	0f be       	out	0x3f, r0	; 63
    208c:	cd bf       	out	0x3d, r28	; 61
    208e:	cf 91       	pop	r28
    2090:	df 91       	pop	r29
    2092:	08 95       	ret

00002094 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    2094:	df 93       	push	r29
    2096:	cf 93       	push	r28
    2098:	cd b7       	in	r28, 0x3d	; 61
    209a:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    209c:	0e 94 3c 11 	call	0x2278	; 0x2278 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    20a0:	a0 91 46 07 	lds	r26, 0x0746
    20a4:	b0 91 47 07 	lds	r27, 0x0747
    20a8:	cd 91       	ld	r28, X+
    20aa:	cd bf       	out	0x3d, r28	; 61
    20ac:	dd 91       	ld	r29, X+
    20ae:	de bf       	out	0x3e, r29	; 62
    20b0:	ff 91       	pop	r31
    20b2:	ef 91       	pop	r30
    20b4:	df 91       	pop	r29
    20b6:	cf 91       	pop	r28
    20b8:	bf 91       	pop	r27
    20ba:	af 91       	pop	r26
    20bc:	9f 91       	pop	r25
    20be:	8f 91       	pop	r24
    20c0:	7f 91       	pop	r23
    20c2:	6f 91       	pop	r22
    20c4:	5f 91       	pop	r21
    20c6:	4f 91       	pop	r20
    20c8:	3f 91       	pop	r19
    20ca:	2f 91       	pop	r18
    20cc:	1f 91       	pop	r17
    20ce:	0f 91       	pop	r16
    20d0:	ff 90       	pop	r15
    20d2:	ef 90       	pop	r14
    20d4:	df 90       	pop	r13
    20d6:	cf 90       	pop	r12
    20d8:	bf 90       	pop	r11
    20da:	af 90       	pop	r10
    20dc:	9f 90       	pop	r9
    20de:	8f 90       	pop	r8
    20e0:	7f 90       	pop	r7
    20e2:	6f 90       	pop	r6
    20e4:	5f 90       	pop	r5
    20e6:	4f 90       	pop	r4
    20e8:	3f 90       	pop	r3
    20ea:	2f 90       	pop	r2
    20ec:	1f 90       	pop	r1
    20ee:	0f 90       	pop	r0
    20f0:	0f be       	out	0x3f, r0	; 63
    20f2:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    20f4:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    20f6:	81 e0       	ldi	r24, 0x01	; 1
}
    20f8:	cf 91       	pop	r28
    20fa:	df 91       	pop	r29
    20fc:	08 95       	ret

000020fe <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    20fe:	df 93       	push	r29
    2100:	cf 93       	push	r28
    2102:	cd b7       	in	r28, 0x3d	; 61
    2104:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2106:	cf 91       	pop	r28
    2108:	df 91       	pop	r29
    210a:	08 95       	ret

0000210c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    210c:	0f 92       	push	r0
    210e:	0f b6       	in	r0, 0x3f	; 63
    2110:	f8 94       	cli
    2112:	0f 92       	push	r0
    2114:	1f 92       	push	r1
    2116:	11 24       	eor	r1, r1
    2118:	2f 92       	push	r2
    211a:	3f 92       	push	r3
    211c:	4f 92       	push	r4
    211e:	5f 92       	push	r5
    2120:	6f 92       	push	r6
    2122:	7f 92       	push	r7
    2124:	8f 92       	push	r8
    2126:	9f 92       	push	r9
    2128:	af 92       	push	r10
    212a:	bf 92       	push	r11
    212c:	cf 92       	push	r12
    212e:	df 92       	push	r13
    2130:	ef 92       	push	r14
    2132:	ff 92       	push	r15
    2134:	0f 93       	push	r16
    2136:	1f 93       	push	r17
    2138:	2f 93       	push	r18
    213a:	3f 93       	push	r19
    213c:	4f 93       	push	r20
    213e:	5f 93       	push	r21
    2140:	6f 93       	push	r22
    2142:	7f 93       	push	r23
    2144:	8f 93       	push	r24
    2146:	9f 93       	push	r25
    2148:	af 93       	push	r26
    214a:	bf 93       	push	r27
    214c:	cf 93       	push	r28
    214e:	df 93       	push	r29
    2150:	ef 93       	push	r30
    2152:	ff 93       	push	r31
    2154:	a0 91 46 07 	lds	r26, 0x0746
    2158:	b0 91 47 07 	lds	r27, 0x0747
    215c:	0d b6       	in	r0, 0x3d	; 61
    215e:	0d 92       	st	X+, r0
    2160:	0e b6       	in	r0, 0x3e	; 62
    2162:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2164:	0e 94 0c 29 	call	0x5218	; 0x5218 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2168:	a0 91 46 07 	lds	r26, 0x0746
    216c:	b0 91 47 07 	lds	r27, 0x0747
    2170:	cd 91       	ld	r28, X+
    2172:	cd bf       	out	0x3d, r28	; 61
    2174:	dd 91       	ld	r29, X+
    2176:	de bf       	out	0x3e, r29	; 62
    2178:	ff 91       	pop	r31
    217a:	ef 91       	pop	r30
    217c:	df 91       	pop	r29
    217e:	cf 91       	pop	r28
    2180:	bf 91       	pop	r27
    2182:	af 91       	pop	r26
    2184:	9f 91       	pop	r25
    2186:	8f 91       	pop	r24
    2188:	7f 91       	pop	r23
    218a:	6f 91       	pop	r22
    218c:	5f 91       	pop	r21
    218e:	4f 91       	pop	r20
    2190:	3f 91       	pop	r19
    2192:	2f 91       	pop	r18
    2194:	1f 91       	pop	r17
    2196:	0f 91       	pop	r16
    2198:	ff 90       	pop	r15
    219a:	ef 90       	pop	r14
    219c:	df 90       	pop	r13
    219e:	cf 90       	pop	r12
    21a0:	bf 90       	pop	r11
    21a2:	af 90       	pop	r10
    21a4:	9f 90       	pop	r9
    21a6:	8f 90       	pop	r8
    21a8:	7f 90       	pop	r7
    21aa:	6f 90       	pop	r6
    21ac:	5f 90       	pop	r5
    21ae:	4f 90       	pop	r4
    21b0:	3f 90       	pop	r3
    21b2:	2f 90       	pop	r2
    21b4:	1f 90       	pop	r1
    21b6:	0f 90       	pop	r0
    21b8:	0f be       	out	0x3f, r0	; 63
    21ba:	0f 90       	pop	r0

	asm volatile ( "ret" );
    21bc:	08 95       	ret

000021be <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    21be:	0f 92       	push	r0
    21c0:	0f b6       	in	r0, 0x3f	; 63
    21c2:	f8 94       	cli
    21c4:	0f 92       	push	r0
    21c6:	1f 92       	push	r1
    21c8:	11 24       	eor	r1, r1
    21ca:	2f 92       	push	r2
    21cc:	3f 92       	push	r3
    21ce:	4f 92       	push	r4
    21d0:	5f 92       	push	r5
    21d2:	6f 92       	push	r6
    21d4:	7f 92       	push	r7
    21d6:	8f 92       	push	r8
    21d8:	9f 92       	push	r9
    21da:	af 92       	push	r10
    21dc:	bf 92       	push	r11
    21de:	cf 92       	push	r12
    21e0:	df 92       	push	r13
    21e2:	ef 92       	push	r14
    21e4:	ff 92       	push	r15
    21e6:	0f 93       	push	r16
    21e8:	1f 93       	push	r17
    21ea:	2f 93       	push	r18
    21ec:	3f 93       	push	r19
    21ee:	4f 93       	push	r20
    21f0:	5f 93       	push	r21
    21f2:	6f 93       	push	r22
    21f4:	7f 93       	push	r23
    21f6:	8f 93       	push	r24
    21f8:	9f 93       	push	r25
    21fa:	af 93       	push	r26
    21fc:	bf 93       	push	r27
    21fe:	cf 93       	push	r28
    2200:	df 93       	push	r29
    2202:	ef 93       	push	r30
    2204:	ff 93       	push	r31
    2206:	a0 91 46 07 	lds	r26, 0x0746
    220a:	b0 91 47 07 	lds	r27, 0x0747
    220e:	0d b6       	in	r0, 0x3d	; 61
    2210:	0d 92       	st	X+, r0
    2212:	0e b6       	in	r0, 0x3e	; 62
    2214:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2216:	0e 94 75 27 	call	0x4eea	; 0x4eea <xTaskIncrementTick>
    221a:	88 23       	and	r24, r24
    221c:	11 f0       	breq	.+4      	; 0x2222 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    221e:	0e 94 0c 29 	call	0x5218	; 0x5218 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2222:	a0 91 46 07 	lds	r26, 0x0746
    2226:	b0 91 47 07 	lds	r27, 0x0747
    222a:	cd 91       	ld	r28, X+
    222c:	cd bf       	out	0x3d, r28	; 61
    222e:	dd 91       	ld	r29, X+
    2230:	de bf       	out	0x3e, r29	; 62
    2232:	ff 91       	pop	r31
    2234:	ef 91       	pop	r30
    2236:	df 91       	pop	r29
    2238:	cf 91       	pop	r28
    223a:	bf 91       	pop	r27
    223c:	af 91       	pop	r26
    223e:	9f 91       	pop	r25
    2240:	8f 91       	pop	r24
    2242:	7f 91       	pop	r23
    2244:	6f 91       	pop	r22
    2246:	5f 91       	pop	r21
    2248:	4f 91       	pop	r20
    224a:	3f 91       	pop	r19
    224c:	2f 91       	pop	r18
    224e:	1f 91       	pop	r17
    2250:	0f 91       	pop	r16
    2252:	ff 90       	pop	r15
    2254:	ef 90       	pop	r14
    2256:	df 90       	pop	r13
    2258:	cf 90       	pop	r12
    225a:	bf 90       	pop	r11
    225c:	af 90       	pop	r10
    225e:	9f 90       	pop	r9
    2260:	8f 90       	pop	r8
    2262:	7f 90       	pop	r7
    2264:	6f 90       	pop	r6
    2266:	5f 90       	pop	r5
    2268:	4f 90       	pop	r4
    226a:	3f 90       	pop	r3
    226c:	2f 90       	pop	r2
    226e:	1f 90       	pop	r1
    2270:	0f 90       	pop	r0
    2272:	0f be       	out	0x3f, r0	; 63
    2274:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2276:	08 95       	ret

00002278 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    2278:	df 93       	push	r29
    227a:	cf 93       	push	r28
    227c:	00 d0       	rcall	.+0      	; 0x227e <prvSetupTimerInterrupt+0x6>
    227e:	00 d0       	rcall	.+0      	; 0x2280 <prvSetupTimerInterrupt+0x8>
    2280:	00 d0       	rcall	.+0      	; 0x2282 <prvSetupTimerInterrupt+0xa>
    2282:	cd b7       	in	r28, 0x3d	; 61
    2284:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    2286:	80 e4       	ldi	r24, 0x40	; 64
    2288:	9f e1       	ldi	r25, 0x1F	; 31
    228a:	a0 e0       	ldi	r26, 0x00	; 0
    228c:	b0 e0       	ldi	r27, 0x00	; 0
    228e:	8b 83       	std	Y+3, r24	; 0x03
    2290:	9c 83       	std	Y+4, r25	; 0x04
    2292:	ad 83       	std	Y+5, r26	; 0x05
    2294:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    2296:	8b 81       	ldd	r24, Y+3	; 0x03
    2298:	9c 81       	ldd	r25, Y+4	; 0x04
    229a:	ad 81       	ldd	r26, Y+5	; 0x05
    229c:	be 81       	ldd	r27, Y+6	; 0x06
    229e:	68 94       	set
    22a0:	15 f8       	bld	r1, 5
    22a2:	b6 95       	lsr	r27
    22a4:	a7 95       	ror	r26
    22a6:	97 95       	ror	r25
    22a8:	87 95       	ror	r24
    22aa:	16 94       	lsr	r1
    22ac:	d1 f7       	brne	.-12     	; 0x22a2 <prvSetupTimerInterrupt+0x2a>
    22ae:	8b 83       	std	Y+3, r24	; 0x03
    22b0:	9c 83       	std	Y+4, r25	; 0x04
    22b2:	ad 83       	std	Y+5, r26	; 0x05
    22b4:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    22b6:	8b 81       	ldd	r24, Y+3	; 0x03
    22b8:	9c 81       	ldd	r25, Y+4	; 0x04
    22ba:	ad 81       	ldd	r26, Y+5	; 0x05
    22bc:	be 81       	ldd	r27, Y+6	; 0x06
    22be:	01 97       	sbiw	r24, 0x01	; 1
    22c0:	a1 09       	sbc	r26, r1
    22c2:	b1 09       	sbc	r27, r1
    22c4:	8b 83       	std	Y+3, r24	; 0x03
    22c6:	9c 83       	std	Y+4, r25	; 0x04
    22c8:	ad 83       	std	Y+5, r26	; 0x05
    22ca:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    22cc:	8b 81       	ldd	r24, Y+3	; 0x03
    22ce:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    22d0:	8b 81       	ldd	r24, Y+3	; 0x03
    22d2:	9c 81       	ldd	r25, Y+4	; 0x04
    22d4:	ad 81       	ldd	r26, Y+5	; 0x05
    22d6:	be 81       	ldd	r27, Y+6	; 0x06
    22d8:	89 2f       	mov	r24, r25
    22da:	9a 2f       	mov	r25, r26
    22dc:	ab 2f       	mov	r26, r27
    22de:	bb 27       	eor	r27, r27
    22e0:	8b 83       	std	Y+3, r24	; 0x03
    22e2:	9c 83       	std	Y+4, r25	; 0x04
    22e4:	ad 83       	std	Y+5, r26	; 0x05
    22e6:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    22e8:	8b 81       	ldd	r24, Y+3	; 0x03
    22ea:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    22ec:	eb e4       	ldi	r30, 0x4B	; 75
    22ee:	f0 e0       	ldi	r31, 0x00	; 0
    22f0:	8a 81       	ldd	r24, Y+2	; 0x02
    22f2:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    22f4:	ea e4       	ldi	r30, 0x4A	; 74
    22f6:	f0 e0       	ldi	r31, 0x00	; 0
    22f8:	89 81       	ldd	r24, Y+1	; 0x01
    22fa:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    22fc:	8b e0       	ldi	r24, 0x0B	; 11
    22fe:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    2300:	ee e4       	ldi	r30, 0x4E	; 78
    2302:	f0 e0       	ldi	r31, 0x00	; 0
    2304:	89 81       	ldd	r24, Y+1	; 0x01
    2306:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2308:	e9 e5       	ldi	r30, 0x59	; 89
    230a:	f0 e0       	ldi	r31, 0x00	; 0
    230c:	80 81       	ld	r24, Z
    230e:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2310:	89 81       	ldd	r24, Y+1	; 0x01
    2312:	80 61       	ori	r24, 0x10	; 16
    2314:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    2316:	e9 e5       	ldi	r30, 0x59	; 89
    2318:	f0 e0       	ldi	r31, 0x00	; 0
    231a:	89 81       	ldd	r24, Y+1	; 0x01
    231c:	80 83       	st	Z, r24
}
    231e:	26 96       	adiw	r28, 0x06	; 6
    2320:	0f b6       	in	r0, 0x3f	; 63
    2322:	f8 94       	cli
    2324:	de bf       	out	0x3e, r29	; 62
    2326:	0f be       	out	0x3f, r0	; 63
    2328:	cd bf       	out	0x3d, r28	; 61
    232a:	cf 91       	pop	r28
    232c:	df 91       	pop	r29
    232e:	08 95       	ret

00002330 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    2330:	0e 94 df 10 	call	0x21be	; 0x21be <vPortYieldFromTick>
		asm volatile ( "reti" );
    2334:	18 95       	reti

00002336 <xCoRoutineCreate>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode,
                                 UBaseType_t uxPriority,
                                 UBaseType_t uxIndex )
    {
    2336:	df 93       	push	r29
    2338:	cf 93       	push	r28
    233a:	cd b7       	in	r28, 0x3d	; 61
    233c:	de b7       	in	r29, 0x3e	; 62
    233e:	27 97       	sbiw	r28, 0x07	; 7
    2340:	0f b6       	in	r0, 0x3f	; 63
    2342:	f8 94       	cli
    2344:	de bf       	out	0x3e, r29	; 62
    2346:	0f be       	out	0x3f, r0	; 63
    2348:	cd bf       	out	0x3d, r28	; 61
    234a:	9d 83       	std	Y+5, r25	; 0x05
    234c:	8c 83       	std	Y+4, r24	; 0x04
    234e:	6e 83       	std	Y+6, r22	; 0x06
    2350:	4f 83       	std	Y+7, r20	; 0x07
        BaseType_t xReturn;
        CRCB_t * pxCoRoutine;

        /* Allocate the memory that will store the co-routine control block. */
        pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    2352:	8a e1       	ldi	r24, 0x1A	; 26
    2354:	90 e0       	ldi	r25, 0x00	; 0
    2356:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <pvPortMalloc>
    235a:	9a 83       	std	Y+2, r25	; 0x02
    235c:	89 83       	std	Y+1, r24	; 0x01

        if( pxCoRoutine )
    235e:	89 81       	ldd	r24, Y+1	; 0x01
    2360:	9a 81       	ldd	r25, Y+2	; 0x02
    2362:	00 97       	sbiw	r24, 0x00	; 0
    2364:	09 f4       	brne	.+2      	; 0x2368 <xCoRoutineCreate+0x32>
    2366:	6f c0       	rjmp	.+222    	; 0x2446 <xCoRoutineCreate+0x110>
        {
            /* If pxCurrentCoRoutine is NULL then this is the first co-routine to
            * be created and the co-routine data structures need initialising. */
            if( pxCurrentCoRoutine == NULL )
    2368:	80 91 10 07 	lds	r24, 0x0710
    236c:	90 91 11 07 	lds	r25, 0x0711
    2370:	00 97       	sbiw	r24, 0x00	; 0
    2372:	41 f4       	brne	.+16     	; 0x2384 <xCoRoutineCreate+0x4e>
            {
                pxCurrentCoRoutine = pxCoRoutine;
    2374:	89 81       	ldd	r24, Y+1	; 0x01
    2376:	9a 81       	ldd	r25, Y+2	; 0x02
    2378:	90 93 11 07 	sts	0x0711, r25
    237c:	80 93 10 07 	sts	0x0710, r24
                prvInitialiseCoRoutineLists();
    2380:	0e 94 09 14 	call	0x2812	; 0x2812 <prvInitialiseCoRoutineLists>
            }

            /* Check the priority is within limits. */
            if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    2384:	8e 81       	ldd	r24, Y+6	; 0x06
    2386:	82 30       	cpi	r24, 0x02	; 2
    2388:	10 f0       	brcs	.+4      	; 0x238e <xCoRoutineCreate+0x58>
            {
                uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    238a:	81 e0       	ldi	r24, 0x01	; 1
    238c:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Fill out the co-routine control block from the function parameters. */
            pxCoRoutine->uxState = corINITIAL_STATE;
    238e:	e9 81       	ldd	r30, Y+1	; 0x01
    2390:	fa 81       	ldd	r31, Y+2	; 0x02
    2392:	11 8e       	std	Z+25, r1	; 0x19
    2394:	10 8e       	std	Z+24, r1	; 0x18
            pxCoRoutine->uxPriority = uxPriority;
    2396:	e9 81       	ldd	r30, Y+1	; 0x01
    2398:	fa 81       	ldd	r31, Y+2	; 0x02
    239a:	8e 81       	ldd	r24, Y+6	; 0x06
    239c:	86 8b       	std	Z+22, r24	; 0x16
            pxCoRoutine->uxIndex = uxIndex;
    239e:	e9 81       	ldd	r30, Y+1	; 0x01
    23a0:	fa 81       	ldd	r31, Y+2	; 0x02
    23a2:	8f 81       	ldd	r24, Y+7	; 0x07
    23a4:	87 8b       	std	Z+23, r24	; 0x17
            pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    23a6:	e9 81       	ldd	r30, Y+1	; 0x01
    23a8:	fa 81       	ldd	r31, Y+2	; 0x02
    23aa:	8c 81       	ldd	r24, Y+4	; 0x04
    23ac:	9d 81       	ldd	r25, Y+5	; 0x05
    23ae:	91 83       	std	Z+1, r25	; 0x01
    23b0:	80 83       	st	Z, r24

            /* Initialise all the other co-routine control block parameters. */
            vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    23b2:	89 81       	ldd	r24, Y+1	; 0x01
    23b4:	9a 81       	ldd	r25, Y+2	; 0x02
    23b6:	02 96       	adiw	r24, 0x02	; 2
    23b8:	0e 94 e9 17 	call	0x2fd2	; 0x2fd2 <vListInitialiseItem>
            vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    23bc:	89 81       	ldd	r24, Y+1	; 0x01
    23be:	9a 81       	ldd	r25, Y+2	; 0x02
    23c0:	0c 96       	adiw	r24, 0x0c	; 12
    23c2:	0e 94 e9 17 	call	0x2fd2	; 0x2fd2 <vListInitialiseItem>

            /* Set the co-routine control block as a link back from the ListItem_t.
             * This is so we can get back to the containing CRCB from a generic item
             * in a list. */
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    23c6:	e9 81       	ldd	r30, Y+1	; 0x01
    23c8:	fa 81       	ldd	r31, Y+2	; 0x02
    23ca:	89 81       	ldd	r24, Y+1	; 0x01
    23cc:	9a 81       	ldd	r25, Y+2	; 0x02
    23ce:	91 87       	std	Z+9, r25	; 0x09
    23d0:	80 87       	std	Z+8, r24	; 0x08
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    23d2:	e9 81       	ldd	r30, Y+1	; 0x01
    23d4:	fa 81       	ldd	r31, Y+2	; 0x02
    23d6:	89 81       	ldd	r24, Y+1	; 0x01
    23d8:	9a 81       	ldd	r25, Y+2	; 0x02
    23da:	93 8b       	std	Z+19, r25	; 0x13
    23dc:	82 8b       	std	Z+18, r24	; 0x12

            /* Event lists are always in priority order. */
            listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    23de:	8e 81       	ldd	r24, Y+6	; 0x06
    23e0:	28 2f       	mov	r18, r24
    23e2:	30 e0       	ldi	r19, 0x00	; 0
    23e4:	82 e0       	ldi	r24, 0x02	; 2
    23e6:	90 e0       	ldi	r25, 0x00	; 0
    23e8:	82 1b       	sub	r24, r18
    23ea:	93 0b       	sbc	r25, r19
    23ec:	e9 81       	ldd	r30, Y+1	; 0x01
    23ee:	fa 81       	ldd	r31, Y+2	; 0x02
    23f0:	95 87       	std	Z+13, r25	; 0x0d
    23f2:	84 87       	std	Z+12, r24	; 0x0c

            /* Now the co-routine has been initialised it can be added to the ready
             * list at the correct priority. */
            prvAddCoRoutineToReadyQueue( pxCoRoutine );
    23f4:	e9 81       	ldd	r30, Y+1	; 0x01
    23f6:	fa 81       	ldd	r31, Y+2	; 0x02
    23f8:	96 89       	ldd	r25, Z+22	; 0x16
    23fa:	80 91 12 07 	lds	r24, 0x0712
    23fe:	89 17       	cp	r24, r25
    2400:	28 f4       	brcc	.+10     	; 0x240c <xCoRoutineCreate+0xd6>
    2402:	e9 81       	ldd	r30, Y+1	; 0x01
    2404:	fa 81       	ldd	r31, Y+2	; 0x02
    2406:	86 89       	ldd	r24, Z+22	; 0x16
    2408:	80 93 12 07 	sts	0x0712, r24
    240c:	e9 81       	ldd	r30, Y+1	; 0x01
    240e:	fa 81       	ldd	r31, Y+2	; 0x02
    2410:	86 89       	ldd	r24, Z+22	; 0x16
    2412:	28 2f       	mov	r18, r24
    2414:	30 e0       	ldi	r19, 0x00	; 0
    2416:	c9 01       	movw	r24, r18
    2418:	88 0f       	add	r24, r24
    241a:	99 1f       	adc	r25, r25
    241c:	88 0f       	add	r24, r24
    241e:	99 1f       	adc	r25, r25
    2420:	88 0f       	add	r24, r24
    2422:	99 1f       	adc	r25, r25
    2424:	82 0f       	add	r24, r18
    2426:	93 1f       	adc	r25, r19
    2428:	ac 01       	movw	r20, r24
    242a:	47 5e       	subi	r20, 0xE7	; 231
    242c:	58 4f       	sbci	r21, 0xF8	; 248
    242e:	89 81       	ldd	r24, Y+1	; 0x01
    2430:	9a 81       	ldd	r25, Y+2	; 0x02
    2432:	9c 01       	movw	r18, r24
    2434:	2e 5f       	subi	r18, 0xFE	; 254
    2436:	3f 4f       	sbci	r19, 0xFF	; 255
    2438:	ca 01       	movw	r24, r20
    243a:	b9 01       	movw	r22, r18
    243c:	0e 94 f9 17 	call	0x2ff2	; 0x2ff2 <vListInsertEnd>

            xReturn = pdPASS;
    2440:	81 e0       	ldi	r24, 0x01	; 1
    2442:	8b 83       	std	Y+3, r24	; 0x03
    2444:	02 c0       	rjmp	.+4      	; 0x244a <xCoRoutineCreate+0x114>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2446:	8f ef       	ldi	r24, 0xFF	; 255
    2448:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    244a:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    244c:	27 96       	adiw	r28, 0x07	; 7
    244e:	0f b6       	in	r0, 0x3f	; 63
    2450:	f8 94       	cli
    2452:	de bf       	out	0x3e, r29	; 62
    2454:	0f be       	out	0x3f, r0	; 63
    2456:	cd bf       	out	0x3d, r28	; 61
    2458:	cf 91       	pop	r28
    245a:	df 91       	pop	r29
    245c:	08 95       	ret

0000245e <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

    void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay,
                                     List_t * pxEventList )
    {
    245e:	df 93       	push	r29
    2460:	cf 93       	push	r28
    2462:	00 d0       	rcall	.+0      	; 0x2464 <vCoRoutineAddToDelayedList+0x6>
    2464:	00 d0       	rcall	.+0      	; 0x2466 <vCoRoutineAddToDelayedList+0x8>
    2466:	00 d0       	rcall	.+0      	; 0x2468 <vCoRoutineAddToDelayedList+0xa>
    2468:	cd b7       	in	r28, 0x3d	; 61
    246a:	de b7       	in	r29, 0x3e	; 62
    246c:	9c 83       	std	Y+4, r25	; 0x04
    246e:	8b 83       	std	Y+3, r24	; 0x03
    2470:	7e 83       	std	Y+6, r23	; 0x06
    2472:	6d 83       	std	Y+5, r22	; 0x05
        TickType_t xTimeToWake;

        /* Calculate the time to wake - this may overflow but this is
         * not a problem. */
        xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    2474:	20 91 13 07 	lds	r18, 0x0713
    2478:	30 91 14 07 	lds	r19, 0x0714
    247c:	8b 81       	ldd	r24, Y+3	; 0x03
    247e:	9c 81       	ldd	r25, Y+4	; 0x04
    2480:	82 0f       	add	r24, r18
    2482:	93 1f       	adc	r25, r19
    2484:	9a 83       	std	Y+2, r25	; 0x02
    2486:	89 83       	std	Y+1, r24	; 0x01

        /* We must remove ourselves from the ready list before adding
         * ourselves to the blocked list as the same list item is used for
         * both lists. */
        ( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2488:	80 91 10 07 	lds	r24, 0x0710
    248c:	90 91 11 07 	lds	r25, 0x0711
    2490:	02 96       	adiw	r24, 0x02	; 2
    2492:	0e 94 a9 18 	call	0x3152	; 0x3152 <uxListRemove>

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    2496:	e0 91 10 07 	lds	r30, 0x0710
    249a:	f0 91 11 07 	lds	r31, 0x0711
    249e:	89 81       	ldd	r24, Y+1	; 0x01
    24a0:	9a 81       	ldd	r25, Y+2	; 0x02
    24a2:	93 83       	std	Z+3, r25	; 0x03
    24a4:	82 83       	std	Z+2, r24	; 0x02

        if( xTimeToWake < xCoRoutineTickCount )
    24a6:	20 91 13 07 	lds	r18, 0x0713
    24aa:	30 91 14 07 	lds	r19, 0x0714
    24ae:	89 81       	ldd	r24, Y+1	; 0x01
    24b0:	9a 81       	ldd	r25, Y+2	; 0x02
    24b2:	82 17       	cp	r24, r18
    24b4:	93 07       	cpc	r25, r19
    24b6:	70 f4       	brcc	.+28     	; 0x24d4 <vCoRoutineAddToDelayedList+0x76>
        {
            /* Wake time has overflowed.  Place this item in the
             * overflow list. */
            vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    24b8:	80 91 0e 07 	lds	r24, 0x070E
    24bc:	90 91 0f 07 	lds	r25, 0x070F
    24c0:	20 91 10 07 	lds	r18, 0x0710
    24c4:	30 91 11 07 	lds	r19, 0x0711
    24c8:	2e 5f       	subi	r18, 0xFE	; 254
    24ca:	3f 4f       	sbci	r19, 0xFF	; 255
    24cc:	b9 01       	movw	r22, r18
    24ce:	0e 94 3d 18 	call	0x307a	; 0x307a <vListInsert>
    24d2:	0d c0       	rjmp	.+26     	; 0x24ee <vCoRoutineAddToDelayedList+0x90>
        }
        else
        {
            /* The wake time has not overflowed, so we can use the
             * current block list. */
            vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    24d4:	80 91 0c 07 	lds	r24, 0x070C
    24d8:	90 91 0d 07 	lds	r25, 0x070D
    24dc:	20 91 10 07 	lds	r18, 0x0710
    24e0:	30 91 11 07 	lds	r19, 0x0711
    24e4:	2e 5f       	subi	r18, 0xFE	; 254
    24e6:	3f 4f       	sbci	r19, 0xFF	; 255
    24e8:	b9 01       	movw	r22, r18
    24ea:	0e 94 3d 18 	call	0x307a	; 0x307a <vListInsert>
        }

        if( pxEventList )
    24ee:	8d 81       	ldd	r24, Y+5	; 0x05
    24f0:	9e 81       	ldd	r25, Y+6	; 0x06
    24f2:	00 97       	sbiw	r24, 0x00	; 0
    24f4:	61 f0       	breq	.+24     	; 0x250e <vCoRoutineAddToDelayedList+0xb0>
        {
            /* Also add the co-routine to an event list.  If this is done then the
             * function must be called with interrupts disabled. */
            vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    24f6:	80 91 10 07 	lds	r24, 0x0710
    24fa:	90 91 11 07 	lds	r25, 0x0711
    24fe:	9c 01       	movw	r18, r24
    2500:	24 5f       	subi	r18, 0xF4	; 244
    2502:	3f 4f       	sbci	r19, 0xFF	; 255
    2504:	8d 81       	ldd	r24, Y+5	; 0x05
    2506:	9e 81       	ldd	r25, Y+6	; 0x06
    2508:	b9 01       	movw	r22, r18
    250a:	0e 94 3d 18 	call	0x307a	; 0x307a <vListInsert>
        }
    }
    250e:	26 96       	adiw	r28, 0x06	; 6
    2510:	0f b6       	in	r0, 0x3f	; 63
    2512:	f8 94       	cli
    2514:	de bf       	out	0x3e, r29	; 62
    2516:	0f be       	out	0x3f, r0	; 63
    2518:	cd bf       	out	0x3d, r28	; 61
    251a:	cf 91       	pop	r28
    251c:	df 91       	pop	r29
    251e:	08 95       	ret

00002520 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

    static void prvCheckPendingReadyList( void )
    {
    2520:	df 93       	push	r29
    2522:	cf 93       	push	r28
    2524:	00 d0       	rcall	.+0      	; 0x2526 <prvCheckPendingReadyList+0x6>
    2526:	cd b7       	in	r28, 0x3d	; 61
    2528:	de b7       	in	r29, 0x3e	; 62
    252a:	3a c0       	rjmp	.+116    	; 0x25a0 <prvCheckPendingReadyList+0x80>
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
        {
            CRCB_t * pxUnblockedCRCB;

            /* The pending ready list can be accessed by an ISR. */
            portDISABLE_INTERRUPTS();
    252c:	f8 94       	cli
            {
                pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyCoRoutineList ) );
    252e:	e0 91 42 07 	lds	r30, 0x0742
    2532:	f0 91 43 07 	lds	r31, 0x0743
    2536:	86 81       	ldd	r24, Z+6	; 0x06
    2538:	97 81       	ldd	r25, Z+7	; 0x07
    253a:	9a 83       	std	Y+2, r25	; 0x02
    253c:	89 83       	std	Y+1, r24	; 0x01
                ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    253e:	89 81       	ldd	r24, Y+1	; 0x01
    2540:	9a 81       	ldd	r25, Y+2	; 0x02
    2542:	0c 96       	adiw	r24, 0x0c	; 12
    2544:	0e 94 a9 18 	call	0x3152	; 0x3152 <uxListRemove>
            }
            portENABLE_INTERRUPTS();
    2548:	78 94       	sei

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    254a:	89 81       	ldd	r24, Y+1	; 0x01
    254c:	9a 81       	ldd	r25, Y+2	; 0x02
    254e:	02 96       	adiw	r24, 0x02	; 2
    2550:	0e 94 a9 18 	call	0x3152	; 0x3152 <uxListRemove>
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    2554:	e9 81       	ldd	r30, Y+1	; 0x01
    2556:	fa 81       	ldd	r31, Y+2	; 0x02
    2558:	96 89       	ldd	r25, Z+22	; 0x16
    255a:	80 91 12 07 	lds	r24, 0x0712
    255e:	89 17       	cp	r24, r25
    2560:	28 f4       	brcc	.+10     	; 0x256c <prvCheckPendingReadyList+0x4c>
    2562:	e9 81       	ldd	r30, Y+1	; 0x01
    2564:	fa 81       	ldd	r31, Y+2	; 0x02
    2566:	86 89       	ldd	r24, Z+22	; 0x16
    2568:	80 93 12 07 	sts	0x0712, r24
    256c:	e9 81       	ldd	r30, Y+1	; 0x01
    256e:	fa 81       	ldd	r31, Y+2	; 0x02
    2570:	86 89       	ldd	r24, Z+22	; 0x16
    2572:	28 2f       	mov	r18, r24
    2574:	30 e0       	ldi	r19, 0x00	; 0
    2576:	c9 01       	movw	r24, r18
    2578:	88 0f       	add	r24, r24
    257a:	99 1f       	adc	r25, r25
    257c:	88 0f       	add	r24, r24
    257e:	99 1f       	adc	r25, r25
    2580:	88 0f       	add	r24, r24
    2582:	99 1f       	adc	r25, r25
    2584:	82 0f       	add	r24, r18
    2586:	93 1f       	adc	r25, r19
    2588:	ac 01       	movw	r20, r24
    258a:	47 5e       	subi	r20, 0xE7	; 231
    258c:	58 4f       	sbci	r21, 0xF8	; 248
    258e:	89 81       	ldd	r24, Y+1	; 0x01
    2590:	9a 81       	ldd	r25, Y+2	; 0x02
    2592:	9c 01       	movw	r18, r24
    2594:	2e 5f       	subi	r18, 0xFE	; 254
    2596:	3f 4f       	sbci	r19, 0xFF	; 255
    2598:	ca 01       	movw	r24, r20
    259a:	b9 01       	movw	r22, r18
    259c:	0e 94 f9 17 	call	0x2ff2	; 0x2ff2 <vListInsertEnd>
    static void prvCheckPendingReadyList( void )
    {
        /* Are there any co-routines waiting to get moved to the ready list?  These
         * are co-routines that have been readied by an ISR.  The ISR cannot access
         * the ready lists itself. */
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    25a0:	80 91 3d 07 	lds	r24, 0x073D
    25a4:	88 23       	and	r24, r24
    25a6:	09 f0       	breq	.+2      	; 0x25aa <prvCheckPendingReadyList+0x8a>
    25a8:	c1 cf       	rjmp	.-126    	; 0x252c <prvCheckPendingReadyList+0xc>
            portENABLE_INTERRUPTS();

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
        }
    }
    25aa:	0f 90       	pop	r0
    25ac:	0f 90       	pop	r0
    25ae:	cf 91       	pop	r28
    25b0:	df 91       	pop	r29
    25b2:	08 95       	ret

000025b4 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

    static void prvCheckDelayedList( void )
    {
    25b4:	df 93       	push	r29
    25b6:	cf 93       	push	r28
    25b8:	00 d0       	rcall	.+0      	; 0x25ba <prvCheckDelayedList+0x6>
    25ba:	00 d0       	rcall	.+0      	; 0x25bc <prvCheckDelayedList+0x8>
    25bc:	cd b7       	in	r28, 0x3d	; 61
    25be:	de b7       	in	r29, 0x3e	; 62
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    25c0:	0e 94 f8 26 	call	0x4df0	; 0x4df0 <xTaskGetTickCount>
    25c4:	20 91 15 07 	lds	r18, 0x0715
    25c8:	30 91 16 07 	lds	r19, 0x0716
    25cc:	82 1b       	sub	r24, r18
    25ce:	93 0b       	sbc	r25, r19
    25d0:	90 93 18 07 	sts	0x0718, r25
    25d4:	80 93 17 07 	sts	0x0717, r24
    25d8:	85 c0       	rjmp	.+266    	; 0x26e4 <prvCheckDelayedList+0x130>

        while( xPassedTicks )
        {
            xCoRoutineTickCount++;
    25da:	80 91 13 07 	lds	r24, 0x0713
    25de:	90 91 14 07 	lds	r25, 0x0714
    25e2:	01 96       	adiw	r24, 0x01	; 1
    25e4:	90 93 14 07 	sts	0x0714, r25
    25e8:	80 93 13 07 	sts	0x0713, r24
            xPassedTicks--;
    25ec:	80 91 17 07 	lds	r24, 0x0717
    25f0:	90 91 18 07 	lds	r25, 0x0718
    25f4:	01 97       	sbiw	r24, 0x01	; 1
    25f6:	90 93 18 07 	sts	0x0718, r25
    25fa:	80 93 17 07 	sts	0x0717, r24

            /* If the tick count has overflowed we need to swap the ready lists. */
            if( xCoRoutineTickCount == 0 )
    25fe:	80 91 13 07 	lds	r24, 0x0713
    2602:	90 91 14 07 	lds	r25, 0x0714
    2606:	00 97       	sbiw	r24, 0x00	; 0
    2608:	09 f0       	breq	.+2      	; 0x260c <prvCheckDelayedList+0x58>
    260a:	64 c0       	rjmp	.+200    	; 0x26d4 <prvCheckDelayedList+0x120>
            {
                List_t * pxTemp;

                /* Tick count has overflowed so we need to swap the delay lists.  If there are
                 * any items in pxDelayedCoRoutineList here then there is an error! */
                pxTemp = pxDelayedCoRoutineList;
    260c:	80 91 0c 07 	lds	r24, 0x070C
    2610:	90 91 0d 07 	lds	r25, 0x070D
    2614:	9a 83       	std	Y+2, r25	; 0x02
    2616:	89 83       	std	Y+1, r24	; 0x01
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2618:	80 91 0e 07 	lds	r24, 0x070E
    261c:	90 91 0f 07 	lds	r25, 0x070F
    2620:	90 93 0d 07 	sts	0x070D, r25
    2624:	80 93 0c 07 	sts	0x070C, r24
                pxOverflowDelayedCoRoutineList = pxTemp;
    2628:	89 81       	ldd	r24, Y+1	; 0x01
    262a:	9a 81       	ldd	r25, Y+2	; 0x02
    262c:	90 93 0f 07 	sts	0x070F, r25
    2630:	80 93 0e 07 	sts	0x070E, r24
    2634:	4f c0       	rjmp	.+158    	; 0x26d4 <prvCheckDelayedList+0x120>
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
            {
                pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    2636:	e0 91 0c 07 	lds	r30, 0x070C
    263a:	f0 91 0d 07 	lds	r31, 0x070D
    263e:	05 80       	ldd	r0, Z+5	; 0x05
    2640:	f6 81       	ldd	r31, Z+6	; 0x06
    2642:	e0 2d       	mov	r30, r0
    2644:	86 81       	ldd	r24, Z+6	; 0x06
    2646:	97 81       	ldd	r25, Z+7	; 0x07
    2648:	9c 83       	std	Y+4, r25	; 0x04
    264a:	8b 83       	std	Y+3, r24	; 0x03

                if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    264c:	eb 81       	ldd	r30, Y+3	; 0x03
    264e:	fc 81       	ldd	r31, Y+4	; 0x04
    2650:	22 81       	ldd	r18, Z+2	; 0x02
    2652:	33 81       	ldd	r19, Z+3	; 0x03
    2654:	80 91 13 07 	lds	r24, 0x0713
    2658:	90 91 14 07 	lds	r25, 0x0714
    265c:	82 17       	cp	r24, r18
    265e:	93 07       	cpc	r25, r19
    2660:	08 f4       	brcc	.+2      	; 0x2664 <prvCheckDelayedList+0xb0>
    2662:	40 c0       	rjmp	.+128    	; 0x26e4 <prvCheckDelayedList+0x130>
                {
                    /* Timeout not yet expired. */
                    break;
                }

                portDISABLE_INTERRUPTS();
    2664:	f8 94       	cli
                    /* The event could have occurred just before this critical
                     *  section.  If this is the case then the generic list item will
                     *  have been moved to the pending ready list and the following
                     *  line is still valid.  Also the pvContainer parameter will have
                     *  been set to NULL so the following lines are also valid. */
                    ( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    2666:	8b 81       	ldd	r24, Y+3	; 0x03
    2668:	9c 81       	ldd	r25, Y+4	; 0x04
    266a:	02 96       	adiw	r24, 0x02	; 2
    266c:	0e 94 a9 18 	call	0x3152	; 0x3152 <uxListRemove>

                    /* Is the co-routine waiting on an event also? */
                    if( pxCRCB->xEventListItem.pxContainer )
    2670:	eb 81       	ldd	r30, Y+3	; 0x03
    2672:	fc 81       	ldd	r31, Y+4	; 0x04
    2674:	84 89       	ldd	r24, Z+20	; 0x14
    2676:	95 89       	ldd	r25, Z+21	; 0x15
    2678:	00 97       	sbiw	r24, 0x00	; 0
    267a:	29 f0       	breq	.+10     	; 0x2686 <prvCheckDelayedList+0xd2>
                    {
                        ( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    267c:	8b 81       	ldd	r24, Y+3	; 0x03
    267e:	9c 81       	ldd	r25, Y+4	; 0x04
    2680:	0c 96       	adiw	r24, 0x0c	; 12
    2682:	0e 94 a9 18 	call	0x3152	; 0x3152 <uxListRemove>
                    }
                }
                portENABLE_INTERRUPTS();
    2686:	78 94       	sei

                prvAddCoRoutineToReadyQueue( pxCRCB );
    2688:	eb 81       	ldd	r30, Y+3	; 0x03
    268a:	fc 81       	ldd	r31, Y+4	; 0x04
    268c:	96 89       	ldd	r25, Z+22	; 0x16
    268e:	80 91 12 07 	lds	r24, 0x0712
    2692:	89 17       	cp	r24, r25
    2694:	28 f4       	brcc	.+10     	; 0x26a0 <prvCheckDelayedList+0xec>
    2696:	eb 81       	ldd	r30, Y+3	; 0x03
    2698:	fc 81       	ldd	r31, Y+4	; 0x04
    269a:	86 89       	ldd	r24, Z+22	; 0x16
    269c:	80 93 12 07 	sts	0x0712, r24
    26a0:	eb 81       	ldd	r30, Y+3	; 0x03
    26a2:	fc 81       	ldd	r31, Y+4	; 0x04
    26a4:	86 89       	ldd	r24, Z+22	; 0x16
    26a6:	28 2f       	mov	r18, r24
    26a8:	30 e0       	ldi	r19, 0x00	; 0
    26aa:	c9 01       	movw	r24, r18
    26ac:	88 0f       	add	r24, r24
    26ae:	99 1f       	adc	r25, r25
    26b0:	88 0f       	add	r24, r24
    26b2:	99 1f       	adc	r25, r25
    26b4:	88 0f       	add	r24, r24
    26b6:	99 1f       	adc	r25, r25
    26b8:	82 0f       	add	r24, r18
    26ba:	93 1f       	adc	r25, r19
    26bc:	ac 01       	movw	r20, r24
    26be:	47 5e       	subi	r20, 0xE7	; 231
    26c0:	58 4f       	sbci	r21, 0xF8	; 248
    26c2:	8b 81       	ldd	r24, Y+3	; 0x03
    26c4:	9c 81       	ldd	r25, Y+4	; 0x04
    26c6:	9c 01       	movw	r18, r24
    26c8:	2e 5f       	subi	r18, 0xFE	; 254
    26ca:	3f 4f       	sbci	r19, 0xFF	; 255
    26cc:	ca 01       	movw	r24, r20
    26ce:	b9 01       	movw	r22, r18
    26d0:	0e 94 f9 17 	call	0x2ff2	; 0x2ff2 <vListInsertEnd>
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
                pxOverflowDelayedCoRoutineList = pxTemp;
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    26d4:	e0 91 0c 07 	lds	r30, 0x070C
    26d8:	f0 91 0d 07 	lds	r31, 0x070D
    26dc:	80 81       	ld	r24, Z
    26de:	88 23       	and	r24, r24
    26e0:	09 f0       	breq	.+2      	; 0x26e4 <prvCheckDelayedList+0x130>
    26e2:	a9 cf       	rjmp	.-174    	; 0x2636 <prvCheckDelayedList+0x82>
    {
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;

        while( xPassedTicks )
    26e4:	80 91 17 07 	lds	r24, 0x0717
    26e8:	90 91 18 07 	lds	r25, 0x0718
    26ec:	00 97       	sbiw	r24, 0x00	; 0
    26ee:	09 f0       	breq	.+2      	; 0x26f2 <prvCheckDelayedList+0x13e>
    26f0:	74 cf       	rjmp	.-280    	; 0x25da <prvCheckDelayedList+0x26>

                prvAddCoRoutineToReadyQueue( pxCRCB );
            }
        }

        xLastTickCount = xCoRoutineTickCount;
    26f2:	80 91 13 07 	lds	r24, 0x0713
    26f6:	90 91 14 07 	lds	r25, 0x0714
    26fa:	90 93 16 07 	sts	0x0716, r25
    26fe:	80 93 15 07 	sts	0x0715, r24
    }
    2702:	0f 90       	pop	r0
    2704:	0f 90       	pop	r0
    2706:	0f 90       	pop	r0
    2708:	0f 90       	pop	r0
    270a:	cf 91       	pop	r28
    270c:	df 91       	pop	r29
    270e:	08 95       	ret

00002710 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

    void vCoRoutineSchedule( void )
    {
    2710:	df 93       	push	r29
    2712:	cf 93       	push	r28
    2714:	00 d0       	rcall	.+0      	; 0x2716 <vCoRoutineSchedule+0x6>
    2716:	cd b7       	in	r28, 0x3d	; 61
    2718:	de b7       	in	r29, 0x3e	; 62
        /* Only run a co-routine after prvInitialiseCoRoutineLists() has been
         * called.  prvInitialiseCoRoutineLists() is called automatically when a
         * co-routine is created. */
        if( pxDelayedCoRoutineList != NULL )
    271a:	80 91 0c 07 	lds	r24, 0x070C
    271e:	90 91 0d 07 	lds	r25, 0x070D
    2722:	00 97       	sbiw	r24, 0x00	; 0
    2724:	09 f4       	brne	.+2      	; 0x2728 <vCoRoutineSchedule+0x18>
    2726:	70 c0       	rjmp	.+224    	; 0x2808 <vCoRoutineSchedule+0xf8>
        {
            /* See if any co-routines readied by events need moving to the ready lists. */
            prvCheckPendingReadyList();
    2728:	0e 94 90 12 	call	0x2520	; 0x2520 <prvCheckPendingReadyList>

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();
    272c:	0e 94 da 12 	call	0x25b4	; 0x25b4 <prvCheckDelayedList>
    2730:	0a c0       	rjmp	.+20     	; 0x2746 <vCoRoutineSchedule+0x36>

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
            {
                if( uxTopCoRoutineReadyPriority == 0 )
    2732:	80 91 12 07 	lds	r24, 0x0712
    2736:	88 23       	and	r24, r24
    2738:	09 f4       	brne	.+2      	; 0x273c <vCoRoutineSchedule+0x2c>
    273a:	66 c0       	rjmp	.+204    	; 0x2808 <vCoRoutineSchedule+0xf8>
                {
                    /* No more co-routines to check. */
                    return;
                }

                --uxTopCoRoutineReadyPriority;
    273c:	80 91 12 07 	lds	r24, 0x0712
    2740:	81 50       	subi	r24, 0x01	; 1
    2742:	80 93 12 07 	sts	0x0712, r24

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2746:	80 91 12 07 	lds	r24, 0x0712
    274a:	28 2f       	mov	r18, r24
    274c:	30 e0       	ldi	r19, 0x00	; 0
    274e:	c9 01       	movw	r24, r18
    2750:	88 0f       	add	r24, r24
    2752:	99 1f       	adc	r25, r25
    2754:	88 0f       	add	r24, r24
    2756:	99 1f       	adc	r25, r25
    2758:	88 0f       	add	r24, r24
    275a:	99 1f       	adc	r25, r25
    275c:	82 0f       	add	r24, r18
    275e:	93 1f       	adc	r25, r19
    2760:	fc 01       	movw	r30, r24
    2762:	e7 5e       	subi	r30, 0xE7	; 231
    2764:	f8 4f       	sbci	r31, 0xF8	; 248
    2766:	80 81       	ld	r24, Z
    2768:	88 23       	and	r24, r24
    276a:	19 f3       	breq	.-58     	; 0x2732 <vCoRoutineSchedule+0x22>
                --uxTopCoRoutineReadyPriority;
            }

            /* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
             * of the same priority get an equal share of the processor time. */
            listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    276c:	80 91 12 07 	lds	r24, 0x0712
    2770:	28 2f       	mov	r18, r24
    2772:	30 e0       	ldi	r19, 0x00	; 0
    2774:	c9 01       	movw	r24, r18
    2776:	88 0f       	add	r24, r24
    2778:	99 1f       	adc	r25, r25
    277a:	88 0f       	add	r24, r24
    277c:	99 1f       	adc	r25, r25
    277e:	88 0f       	add	r24, r24
    2780:	99 1f       	adc	r25, r25
    2782:	82 0f       	add	r24, r18
    2784:	93 1f       	adc	r25, r19
    2786:	87 5e       	subi	r24, 0xE7	; 231
    2788:	98 4f       	sbci	r25, 0xF8	; 248
    278a:	9a 83       	std	Y+2, r25	; 0x02
    278c:	89 83       	std	Y+1, r24	; 0x01
    278e:	e9 81       	ldd	r30, Y+1	; 0x01
    2790:	fa 81       	ldd	r31, Y+2	; 0x02
    2792:	01 80       	ldd	r0, Z+1	; 0x01
    2794:	f2 81       	ldd	r31, Z+2	; 0x02
    2796:	e0 2d       	mov	r30, r0
    2798:	82 81       	ldd	r24, Z+2	; 0x02
    279a:	93 81       	ldd	r25, Z+3	; 0x03
    279c:	e9 81       	ldd	r30, Y+1	; 0x01
    279e:	fa 81       	ldd	r31, Y+2	; 0x02
    27a0:	92 83       	std	Z+2, r25	; 0x02
    27a2:	81 83       	std	Z+1, r24	; 0x01
    27a4:	e9 81       	ldd	r30, Y+1	; 0x01
    27a6:	fa 81       	ldd	r31, Y+2	; 0x02
    27a8:	21 81       	ldd	r18, Z+1	; 0x01
    27aa:	32 81       	ldd	r19, Z+2	; 0x02
    27ac:	89 81       	ldd	r24, Y+1	; 0x01
    27ae:	9a 81       	ldd	r25, Y+2	; 0x02
    27b0:	03 96       	adiw	r24, 0x03	; 3
    27b2:	28 17       	cp	r18, r24
    27b4:	39 07       	cpc	r19, r25
    27b6:	59 f4       	brne	.+22     	; 0x27ce <vCoRoutineSchedule+0xbe>
    27b8:	e9 81       	ldd	r30, Y+1	; 0x01
    27ba:	fa 81       	ldd	r31, Y+2	; 0x02
    27bc:	01 80       	ldd	r0, Z+1	; 0x01
    27be:	f2 81       	ldd	r31, Z+2	; 0x02
    27c0:	e0 2d       	mov	r30, r0
    27c2:	82 81       	ldd	r24, Z+2	; 0x02
    27c4:	93 81       	ldd	r25, Z+3	; 0x03
    27c6:	e9 81       	ldd	r30, Y+1	; 0x01
    27c8:	fa 81       	ldd	r31, Y+2	; 0x02
    27ca:	92 83       	std	Z+2, r25	; 0x02
    27cc:	81 83       	std	Z+1, r24	; 0x01
    27ce:	e9 81       	ldd	r30, Y+1	; 0x01
    27d0:	fa 81       	ldd	r31, Y+2	; 0x02
    27d2:	01 80       	ldd	r0, Z+1	; 0x01
    27d4:	f2 81       	ldd	r31, Z+2	; 0x02
    27d6:	e0 2d       	mov	r30, r0
    27d8:	86 81       	ldd	r24, Z+6	; 0x06
    27da:	97 81       	ldd	r25, Z+7	; 0x07
    27dc:	90 93 11 07 	sts	0x0711, r25
    27e0:	80 93 10 07 	sts	0x0710, r24

            /* Call the co-routine. */
            ( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    27e4:	e0 91 10 07 	lds	r30, 0x0710
    27e8:	f0 91 11 07 	lds	r31, 0x0711
    27ec:	40 81       	ld	r20, Z
    27ee:	51 81       	ldd	r21, Z+1	; 0x01
    27f0:	80 91 10 07 	lds	r24, 0x0710
    27f4:	90 91 11 07 	lds	r25, 0x0711
    27f8:	e0 91 10 07 	lds	r30, 0x0710
    27fc:	f0 91 11 07 	lds	r31, 0x0711
    2800:	27 89       	ldd	r18, Z+23	; 0x17
    2802:	62 2f       	mov	r22, r18
    2804:	fa 01       	movw	r30, r20
    2806:	09 95       	icall
        }
    }
    2808:	0f 90       	pop	r0
    280a:	0f 90       	pop	r0
    280c:	cf 91       	pop	r28
    280e:	df 91       	pop	r29
    2810:	08 95       	ret

00002812 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

    static void prvInitialiseCoRoutineLists( void )
    {
    2812:	df 93       	push	r29
    2814:	cf 93       	push	r28
    2816:	0f 92       	push	r0
    2818:	cd b7       	in	r28, 0x3d	; 61
    281a:	de b7       	in	r29, 0x3e	; 62
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    281c:	19 82       	std	Y+1, r1	; 0x01
    281e:	13 c0       	rjmp	.+38     	; 0x2846 <prvInitialiseCoRoutineLists+0x34>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    2820:	89 81       	ldd	r24, Y+1	; 0x01
    2822:	28 2f       	mov	r18, r24
    2824:	30 e0       	ldi	r19, 0x00	; 0
    2826:	c9 01       	movw	r24, r18
    2828:	88 0f       	add	r24, r24
    282a:	99 1f       	adc	r25, r25
    282c:	88 0f       	add	r24, r24
    282e:	99 1f       	adc	r25, r25
    2830:	88 0f       	add	r24, r24
    2832:	99 1f       	adc	r25, r25
    2834:	82 0f       	add	r24, r18
    2836:	93 1f       	adc	r25, r19
    2838:	87 5e       	subi	r24, 0xE7	; 231
    283a:	98 4f       	sbci	r25, 0xF8	; 248
    283c:	0e 94 bf 17 	call	0x2f7e	; 0x2f7e <vListInitialise>

    static void prvInitialiseCoRoutineLists( void )
    {
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2840:	89 81       	ldd	r24, Y+1	; 0x01
    2842:	8f 5f       	subi	r24, 0xFF	; 255
    2844:	89 83       	std	Y+1, r24	; 0x01
    2846:	89 81       	ldd	r24, Y+1	; 0x01
    2848:	82 30       	cpi	r24, 0x02	; 2
    284a:	50 f3       	brcs	.-44     	; 0x2820 <prvInitialiseCoRoutineLists+0xe>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
        }

        vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    284c:	8b e2       	ldi	r24, 0x2B	; 43
    284e:	97 e0       	ldi	r25, 0x07	; 7
    2850:	0e 94 bf 17 	call	0x2f7e	; 0x2f7e <vListInitialise>
        vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    2854:	84 e3       	ldi	r24, 0x34	; 52
    2856:	97 e0       	ldi	r25, 0x07	; 7
    2858:	0e 94 bf 17 	call	0x2f7e	; 0x2f7e <vListInitialise>
        vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    285c:	8d e3       	ldi	r24, 0x3D	; 61
    285e:	97 e0       	ldi	r25, 0x07	; 7
    2860:	0e 94 bf 17 	call	0x2f7e	; 0x2f7e <vListInitialise>

        /* Start with pxDelayedCoRoutineList using list1 and the
         * pxOverflowDelayedCoRoutineList using list2. */
        pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2864:	8b e2       	ldi	r24, 0x2B	; 43
    2866:	97 e0       	ldi	r25, 0x07	; 7
    2868:	90 93 0d 07 	sts	0x070D, r25
    286c:	80 93 0c 07 	sts	0x070C, r24
        pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    2870:	84 e3       	ldi	r24, 0x34	; 52
    2872:	97 e0       	ldi	r25, 0x07	; 7
    2874:	90 93 0f 07 	sts	0x070F, r25
    2878:	80 93 0e 07 	sts	0x070E, r24
    }
    287c:	0f 90       	pop	r0
    287e:	cf 91       	pop	r28
    2880:	df 91       	pop	r29
    2882:	08 95       	ret

00002884 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineRemoveFromEventList( const List_t * pxEventList )
    {
    2884:	df 93       	push	r29
    2886:	cf 93       	push	r28
    2888:	00 d0       	rcall	.+0      	; 0x288a <xCoRoutineRemoveFromEventList+0x6>
    288a:	00 d0       	rcall	.+0      	; 0x288c <xCoRoutineRemoveFromEventList+0x8>
    288c:	0f 92       	push	r0
    288e:	cd b7       	in	r28, 0x3d	; 61
    2890:	de b7       	in	r29, 0x3e	; 62
    2892:	9d 83       	std	Y+5, r25	; 0x05
    2894:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;

        /* This function is called from within an interrupt.  It can only access
         * event lists and the pending ready list.  This function assumes that a
         * check has already been made to ensure pxEventList is not empty. */
        pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2896:	ec 81       	ldd	r30, Y+4	; 0x04
    2898:	fd 81       	ldd	r31, Y+5	; 0x05
    289a:	05 80       	ldd	r0, Z+5	; 0x05
    289c:	f6 81       	ldd	r31, Z+6	; 0x06
    289e:	e0 2d       	mov	r30, r0
    28a0:	86 81       	ldd	r24, Z+6	; 0x06
    28a2:	97 81       	ldd	r25, Z+7	; 0x07
    28a4:	9b 83       	std	Y+3, r25	; 0x03
    28a6:	8a 83       	std	Y+2, r24	; 0x02
        ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    28a8:	8a 81       	ldd	r24, Y+2	; 0x02
    28aa:	9b 81       	ldd	r25, Y+3	; 0x03
    28ac:	0c 96       	adiw	r24, 0x0c	; 12
    28ae:	0e 94 a9 18 	call	0x3152	; 0x3152 <uxListRemove>
        vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    28b2:	8a 81       	ldd	r24, Y+2	; 0x02
    28b4:	9b 81       	ldd	r25, Y+3	; 0x03
    28b6:	9c 01       	movw	r18, r24
    28b8:	24 5f       	subi	r18, 0xF4	; 244
    28ba:	3f 4f       	sbci	r19, 0xFF	; 255
    28bc:	8d e3       	ldi	r24, 0x3D	; 61
    28be:	97 e0       	ldi	r25, 0x07	; 7
    28c0:	b9 01       	movw	r22, r18
    28c2:	0e 94 f9 17 	call	0x2ff2	; 0x2ff2 <vListInsertEnd>

        if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    28c6:	ea 81       	ldd	r30, Y+2	; 0x02
    28c8:	fb 81       	ldd	r31, Y+3	; 0x03
    28ca:	96 89       	ldd	r25, Z+22	; 0x16
    28cc:	e0 91 10 07 	lds	r30, 0x0710
    28d0:	f0 91 11 07 	lds	r31, 0x0711
    28d4:	86 89       	ldd	r24, Z+22	; 0x16
    28d6:	98 17       	cp	r25, r24
    28d8:	18 f0       	brcs	.+6      	; 0x28e0 <xCoRoutineRemoveFromEventList+0x5c>
        {
            xReturn = pdTRUE;
    28da:	81 e0       	ldi	r24, 0x01	; 1
    28dc:	89 83       	std	Y+1, r24	; 0x01
    28de:	01 c0       	rjmp	.+2      	; 0x28e2 <xCoRoutineRemoveFromEventList+0x5e>
        }
        else
        {
            xReturn = pdFALSE;
    28e0:	19 82       	std	Y+1, r1	; 0x01
        }

        return xReturn;
    28e2:	89 81       	ldd	r24, Y+1	; 0x01
    }
    28e4:	0f 90       	pop	r0
    28e6:	0f 90       	pop	r0
    28e8:	0f 90       	pop	r0
    28ea:	0f 90       	pop	r0
    28ec:	0f 90       	pop	r0
    28ee:	cf 91       	pop	r28
    28f0:	df 91       	pop	r29
    28f2:	08 95       	ret

000028f4 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
    28f4:	df 93       	push	r29
    28f6:	cf 93       	push	r28
    28f8:	00 d0       	rcall	.+0      	; 0x28fa <xEventGroupCreate+0x6>
    28fa:	cd b7       	in	r28, 0x3d	; 61
    28fc:	de b7       	in	r29, 0x3e	; 62
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    28fe:	8b e0       	ldi	r24, 0x0B	; 11
    2900:	90 e0       	ldi	r25, 0x00	; 0
    2902:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <pvPortMalloc>
    2906:	9a 83       	std	Y+2, r25	; 0x02
    2908:	89 83       	std	Y+1, r24	; 0x01

        if( pxEventBits != NULL )
    290a:	89 81       	ldd	r24, Y+1	; 0x01
    290c:	9a 81       	ldd	r25, Y+2	; 0x02
    290e:	00 97       	sbiw	r24, 0x00	; 0
    2910:	49 f0       	breq	.+18     	; 0x2924 <xEventGroupCreate+0x30>
        {
            pxEventBits->uxEventBits = 0;
    2912:	e9 81       	ldd	r30, Y+1	; 0x01
    2914:	fa 81       	ldd	r31, Y+2	; 0x02
    2916:	11 82       	std	Z+1, r1	; 0x01
    2918:	10 82       	st	Z, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    291a:	89 81       	ldd	r24, Y+1	; 0x01
    291c:	9a 81       	ldd	r25, Y+2	; 0x02
    291e:	02 96       	adiw	r24, 0x02	; 2
    2920:	0e 94 bf 17 	call	0x2f7e	; 0x2f7e <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
    2924:	89 81       	ldd	r24, Y+1	; 0x01
    2926:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    2928:	0f 90       	pop	r0
    292a:	0f 90       	pop	r0
    292c:	cf 91       	pop	r28
    292e:	df 91       	pop	r29
    2930:	08 95       	ret

00002932 <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
    2932:	df 93       	push	r29
    2934:	cf 93       	push	r28
    2936:	cd b7       	in	r28, 0x3d	; 61
    2938:	de b7       	in	r29, 0x3e	; 62
    293a:	60 97       	sbiw	r28, 0x10	; 16
    293c:	0f b6       	in	r0, 0x3f	; 63
    293e:	f8 94       	cli
    2940:	de bf       	out	0x3e, r29	; 62
    2942:	0f be       	out	0x3f, r0	; 63
    2944:	cd bf       	out	0x3d, r28	; 61
    2946:	9a 87       	std	Y+10, r25	; 0x0a
    2948:	89 87       	std	Y+9, r24	; 0x09
    294a:	7c 87       	std	Y+12, r23	; 0x0c
    294c:	6b 87       	std	Y+11, r22	; 0x0b
    294e:	5e 87       	std	Y+14, r21	; 0x0e
    2950:	4d 87       	std	Y+13, r20	; 0x0d
    2952:	38 8b       	std	Y+16, r19	; 0x10
    2954:	2f 87       	std	Y+15, r18	; 0x0f
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
    2956:	89 85       	ldd	r24, Y+9	; 0x09
    2958:	9a 85       	ldd	r25, Y+10	; 0x0a
    295a:	9c 83       	std	Y+4, r25	; 0x04
    295c:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    295e:	19 82       	std	Y+1, r1	; 0x01
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    2960:	0e 94 9c 25 	call	0x4b38	; 0x4b38 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
    2964:	eb 81       	ldd	r30, Y+3	; 0x03
    2966:	fc 81       	ldd	r31, Y+4	; 0x04
    2968:	80 81       	ld	r24, Z
    296a:	91 81       	ldd	r25, Z+1	; 0x01
    296c:	98 87       	std	Y+8, r25	; 0x08
    296e:	8f 83       	std	Y+7, r24	; 0x07

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    2970:	89 85       	ldd	r24, Y+9	; 0x09
    2972:	9a 85       	ldd	r25, Y+10	; 0x0a
    2974:	2b 85       	ldd	r18, Y+11	; 0x0b
    2976:	3c 85       	ldd	r19, Y+12	; 0x0c
    2978:	b9 01       	movw	r22, r18
    297a:	0e 94 70 16 	call	0x2ce0	; 0x2ce0 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    297e:	2f 81       	ldd	r18, Y+7	; 0x07
    2980:	38 85       	ldd	r19, Y+8	; 0x08
    2982:	8b 85       	ldd	r24, Y+11	; 0x0b
    2984:	9c 85       	ldd	r25, Y+12	; 0x0c
    2986:	28 2b       	or	r18, r24
    2988:	39 2b       	or	r19, r25
    298a:	8d 85       	ldd	r24, Y+13	; 0x0d
    298c:	9e 85       	ldd	r25, Y+14	; 0x0e
    298e:	28 23       	and	r18, r24
    2990:	39 23       	and	r19, r25
    2992:	8d 85       	ldd	r24, Y+13	; 0x0d
    2994:	9e 85       	ldd	r25, Y+14	; 0x0e
    2996:	28 17       	cp	r18, r24
    2998:	39 07       	cpc	r19, r25
    299a:	c9 f4       	brne	.+50     	; 0x29ce <xEventGroupSync+0x9c>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    299c:	2f 81       	ldd	r18, Y+7	; 0x07
    299e:	38 85       	ldd	r19, Y+8	; 0x08
    29a0:	8b 85       	ldd	r24, Y+11	; 0x0b
    29a2:	9c 85       	ldd	r25, Y+12	; 0x0c
    29a4:	82 2b       	or	r24, r18
    29a6:	93 2b       	or	r25, r19
    29a8:	9e 83       	std	Y+6, r25	; 0x06
    29aa:	8d 83       	std	Y+5, r24	; 0x05

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    29ac:	eb 81       	ldd	r30, Y+3	; 0x03
    29ae:	fc 81       	ldd	r31, Y+4	; 0x04
    29b0:	20 81       	ld	r18, Z
    29b2:	31 81       	ldd	r19, Z+1	; 0x01
    29b4:	8d 85       	ldd	r24, Y+13	; 0x0d
    29b6:	9e 85       	ldd	r25, Y+14	; 0x0e
    29b8:	80 95       	com	r24
    29ba:	90 95       	com	r25
    29bc:	82 23       	and	r24, r18
    29be:	93 23       	and	r25, r19
    29c0:	eb 81       	ldd	r30, Y+3	; 0x03
    29c2:	fc 81       	ldd	r31, Y+4	; 0x04
    29c4:	91 83       	std	Z+1, r25	; 0x01
    29c6:	80 83       	st	Z, r24

            xTicksToWait = 0;
    29c8:	18 8a       	std	Y+16, r1	; 0x10
    29ca:	1f 86       	std	Y+15, r1	; 0x0f
    29cc:	1e c0       	rjmp	.+60     	; 0x2a0a <xEventGroupSync+0xd8>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
    29ce:	8f 85       	ldd	r24, Y+15	; 0x0f
    29d0:	98 89       	ldd	r25, Y+16	; 0x10
    29d2:	00 97       	sbiw	r24, 0x00	; 0
    29d4:	91 f0       	breq	.+36     	; 0x29fa <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    29d6:	8b 81       	ldd	r24, Y+3	; 0x03
    29d8:	9c 81       	ldd	r25, Y+4	; 0x04
    29da:	bc 01       	movw	r22, r24
    29dc:	6e 5f       	subi	r22, 0xFE	; 254
    29de:	7f 4f       	sbci	r23, 0xFF	; 255
    29e0:	8d 85       	ldd	r24, Y+13	; 0x0d
    29e2:	9e 85       	ldd	r25, Y+14	; 0x0e
    29e4:	9c 01       	movw	r18, r24
    29e6:	35 60       	ori	r19, 0x05	; 5
    29e8:	4f 85       	ldd	r20, Y+15	; 0x0f
    29ea:	58 89       	ldd	r21, Y+16	; 0x10
    29ec:	cb 01       	movw	r24, r22
    29ee:	b9 01       	movw	r22, r18
    29f0:	0e 94 9b 29 	call	0x5336	; 0x5336 <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
    29f4:	1e 82       	std	Y+6, r1	; 0x06
    29f6:	1d 82       	std	Y+5, r1	; 0x05
    29f8:	08 c0       	rjmp	.+16     	; 0x2a0a <xEventGroupSync+0xd8>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    29fa:	eb 81       	ldd	r30, Y+3	; 0x03
    29fc:	fc 81       	ldd	r31, Y+4	; 0x04
    29fe:	80 81       	ld	r24, Z
    2a00:	91 81       	ldd	r25, Z+1	; 0x01
    2a02:	9e 83       	std	Y+6, r25	; 0x06
    2a04:	8d 83       	std	Y+5, r24	; 0x05
                xTimeoutOccurred = pdTRUE;
    2a06:	81 e0       	ldi	r24, 0x01	; 1
    2a08:	89 83       	std	Y+1, r24	; 0x01
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    2a0a:	0e 94 a8 25 	call	0x4b50	; 0x4b50 <xTaskResumeAll>
    2a0e:	8a 83       	std	Y+2, r24	; 0x02

    if( xTicksToWait != ( TickType_t ) 0 )
    2a10:	8f 85       	ldd	r24, Y+15	; 0x0f
    2a12:	98 89       	ldd	r25, Y+16	; 0x10
    2a14:	00 97       	sbiw	r24, 0x00	; 0
    2a16:	09 f4       	brne	.+2      	; 0x2a1a <xEventGroupSync+0xe8>
    2a18:	3a c0       	rjmp	.+116    	; 0x2a8e <xEventGroupSync+0x15c>
    {
        if( xAlreadyYielded == pdFALSE )
    2a1a:	8a 81       	ldd	r24, Y+2	; 0x02
    2a1c:	88 23       	and	r24, r24
    2a1e:	11 f4       	brne	.+4      	; 0x2a24 <xEventGroupSync+0xf2>
        {
            portYIELD_WITHIN_API();
    2a20:	0e 94 86 10 	call	0x210c	; 0x210c <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    2a24:	0e 94 29 2e 	call	0x5c52	; 0x5c52 <uxTaskResetEventItemValue>
    2a28:	9e 83       	std	Y+6, r25	; 0x06
    2a2a:	8d 83       	std	Y+5, r24	; 0x05

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    2a2c:	8d 81       	ldd	r24, Y+5	; 0x05
    2a2e:	9e 81       	ldd	r25, Y+6	; 0x06
    2a30:	80 70       	andi	r24, 0x00	; 0
    2a32:	92 70       	andi	r25, 0x02	; 2
    2a34:	00 97       	sbiw	r24, 0x00	; 0
    2a36:	31 f5       	brne	.+76     	; 0x2a84 <xEventGroupSync+0x152>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
    2a38:	0f b6       	in	r0, 0x3f	; 63
    2a3a:	f8 94       	cli
    2a3c:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
    2a3e:	eb 81       	ldd	r30, Y+3	; 0x03
    2a40:	fc 81       	ldd	r31, Y+4	; 0x04
    2a42:	80 81       	ld	r24, Z
    2a44:	91 81       	ldd	r25, Z+1	; 0x01
    2a46:	9e 83       	std	Y+6, r25	; 0x06
    2a48:	8d 83       	std	Y+5, r24	; 0x05

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2a4a:	2d 81       	ldd	r18, Y+5	; 0x05
    2a4c:	3e 81       	ldd	r19, Y+6	; 0x06
    2a4e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2a50:	9e 85       	ldd	r25, Y+14	; 0x0e
    2a52:	28 23       	and	r18, r24
    2a54:	39 23       	and	r19, r25
    2a56:	8d 85       	ldd	r24, Y+13	; 0x0d
    2a58:	9e 85       	ldd	r25, Y+14	; 0x0e
    2a5a:	28 17       	cp	r18, r24
    2a5c:	39 07       	cpc	r19, r25
    2a5e:	71 f4       	brne	.+28     	; 0x2a7c <xEventGroupSync+0x14a>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2a60:	eb 81       	ldd	r30, Y+3	; 0x03
    2a62:	fc 81       	ldd	r31, Y+4	; 0x04
    2a64:	20 81       	ld	r18, Z
    2a66:	31 81       	ldd	r19, Z+1	; 0x01
    2a68:	8d 85       	ldd	r24, Y+13	; 0x0d
    2a6a:	9e 85       	ldd	r25, Y+14	; 0x0e
    2a6c:	80 95       	com	r24
    2a6e:	90 95       	com	r25
    2a70:	82 23       	and	r24, r18
    2a72:	93 23       	and	r25, r19
    2a74:	eb 81       	ldd	r30, Y+3	; 0x03
    2a76:	fc 81       	ldd	r31, Y+4	; 0x04
    2a78:	91 83       	std	Z+1, r25	; 0x01
    2a7a:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    2a7c:	0f 90       	pop	r0
    2a7e:	0f be       	out	0x3f, r0	; 63

            xTimeoutOccurred = pdTRUE;
    2a80:	81 e0       	ldi	r24, 0x01	; 1
    2a82:	89 83       	std	Y+1, r24	; 0x01
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    2a84:	8d 81       	ldd	r24, Y+5	; 0x05
    2a86:	9e 81       	ldd	r25, Y+6	; 0x06
    2a88:	90 70       	andi	r25, 0x00	; 0
    2a8a:	9e 83       	std	Y+6, r25	; 0x06
    2a8c:	8d 83       	std	Y+5, r24	; 0x05
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    2a8e:	8d 81       	ldd	r24, Y+5	; 0x05
    2a90:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2a92:	60 96       	adiw	r28, 0x10	; 16
    2a94:	0f b6       	in	r0, 0x3f	; 63
    2a96:	f8 94       	cli
    2a98:	de bf       	out	0x3e, r29	; 62
    2a9a:	0f be       	out	0x3f, r0	; 63
    2a9c:	cd bf       	out	0x3d, r28	; 61
    2a9e:	cf 91       	pop	r28
    2aa0:	df 91       	pop	r29
    2aa2:	08 95       	ret

00002aa4 <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
    2aa4:	0f 93       	push	r16
    2aa6:	1f 93       	push	r17
    2aa8:	df 93       	push	r29
    2aaa:	cf 93       	push	r28
    2aac:	cd b7       	in	r28, 0x3d	; 61
    2aae:	de b7       	in	r29, 0x3e	; 62
    2ab0:	63 97       	sbiw	r28, 0x13	; 19
    2ab2:	0f b6       	in	r0, 0x3f	; 63
    2ab4:	f8 94       	cli
    2ab6:	de bf       	out	0x3e, r29	; 62
    2ab8:	0f be       	out	0x3f, r0	; 63
    2aba:	cd bf       	out	0x3d, r28	; 61
    2abc:	9d 87       	std	Y+13, r25	; 0x0d
    2abe:	8c 87       	std	Y+12, r24	; 0x0c
    2ac0:	7f 87       	std	Y+15, r23	; 0x0f
    2ac2:	6e 87       	std	Y+14, r22	; 0x0e
    2ac4:	48 8b       	std	Y+16, r20	; 0x10
    2ac6:	29 8b       	std	Y+17, r18	; 0x11
    2ac8:	1b 8b       	std	Y+19, r17	; 0x13
    2aca:	0a 8b       	std	Y+18, r16	; 0x12
    EventGroup_t * pxEventBits = xEventGroup;
    2acc:	8c 85       	ldd	r24, Y+12	; 0x0c
    2ace:	9d 85       	ldd	r25, Y+13	; 0x0d
    2ad0:	9b 87       	std	Y+11, r25	; 0x0b
    2ad2:	8a 87       	std	Y+10, r24	; 0x0a
    EventBits_t uxReturn, uxControlBits = 0;
    2ad4:	1f 82       	std	Y+7, r1	; 0x07
    2ad6:	1e 82       	std	Y+6, r1	; 0x06
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    2ad8:	1b 82       	std	Y+3, r1	; 0x03
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    2ada:	0e 94 9c 25 	call	0x4b38	; 0x4b38 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    2ade:	ea 85       	ldd	r30, Y+10	; 0x0a
    2ae0:	fb 85       	ldd	r31, Y+11	; 0x0b
    2ae2:	80 81       	ld	r24, Z
    2ae4:	91 81       	ldd	r25, Z+1	; 0x01
    2ae6:	9a 83       	std	Y+2, r25	; 0x02
    2ae8:	89 83       	std	Y+1, r24	; 0x01

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    2aea:	89 81       	ldd	r24, Y+1	; 0x01
    2aec:	9a 81       	ldd	r25, Y+2	; 0x02
    2aee:	2e 85       	ldd	r18, Y+14	; 0x0e
    2af0:	3f 85       	ldd	r19, Y+15	; 0x0f
    2af2:	b9 01       	movw	r22, r18
    2af4:	49 89       	ldd	r20, Y+17	; 0x11
    2af6:	0e 94 8d 17 	call	0x2f1a	; 0x2f1a <prvTestWaitCondition>
    2afa:	8d 83       	std	Y+5, r24	; 0x05

        if( xWaitConditionMet != pdFALSE )
    2afc:	8d 81       	ldd	r24, Y+5	; 0x05
    2afe:	88 23       	and	r24, r24
    2b00:	c1 f0       	breq	.+48     	; 0x2b32 <xEventGroupWaitBits+0x8e>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
    2b02:	89 81       	ldd	r24, Y+1	; 0x01
    2b04:	9a 81       	ldd	r25, Y+2	; 0x02
    2b06:	99 87       	std	Y+9, r25	; 0x09
    2b08:	88 87       	std	Y+8, r24	; 0x08
            xTicksToWait = ( TickType_t ) 0;
    2b0a:	1b 8a       	std	Y+19, r1	; 0x13
    2b0c:	1a 8a       	std	Y+18, r1	; 0x12

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
    2b0e:	88 89       	ldd	r24, Y+16	; 0x10
    2b10:	88 23       	and	r24, r24
    2b12:	e9 f1       	breq	.+122    	; 0x2b8e <xEventGroupWaitBits+0xea>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2b14:	ea 85       	ldd	r30, Y+10	; 0x0a
    2b16:	fb 85       	ldd	r31, Y+11	; 0x0b
    2b18:	20 81       	ld	r18, Z
    2b1a:	31 81       	ldd	r19, Z+1	; 0x01
    2b1c:	8e 85       	ldd	r24, Y+14	; 0x0e
    2b1e:	9f 85       	ldd	r25, Y+15	; 0x0f
    2b20:	80 95       	com	r24
    2b22:	90 95       	com	r25
    2b24:	82 23       	and	r24, r18
    2b26:	93 23       	and	r25, r19
    2b28:	ea 85       	ldd	r30, Y+10	; 0x0a
    2b2a:	fb 85       	ldd	r31, Y+11	; 0x0b
    2b2c:	91 83       	std	Z+1, r25	; 0x01
    2b2e:	80 83       	st	Z, r24
    2b30:	2e c0       	rjmp	.+92     	; 0x2b8e <xEventGroupWaitBits+0xea>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
    2b32:	8a 89       	ldd	r24, Y+18	; 0x12
    2b34:	9b 89       	ldd	r25, Y+19	; 0x13
    2b36:	00 97       	sbiw	r24, 0x00	; 0
    2b38:	39 f4       	brne	.+14     	; 0x2b48 <xEventGroupWaitBits+0xa4>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
    2b3a:	89 81       	ldd	r24, Y+1	; 0x01
    2b3c:	9a 81       	ldd	r25, Y+2	; 0x02
    2b3e:	99 87       	std	Y+9, r25	; 0x09
    2b40:	88 87       	std	Y+8, r24	; 0x08
            xTimeoutOccurred = pdTRUE;
    2b42:	81 e0       	ldi	r24, 0x01	; 1
    2b44:	8b 83       	std	Y+3, r24	; 0x03
    2b46:	23 c0       	rjmp	.+70     	; 0x2b8e <xEventGroupWaitBits+0xea>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
    2b48:	88 89       	ldd	r24, Y+16	; 0x10
    2b4a:	88 23       	and	r24, r24
    2b4c:	29 f0       	breq	.+10     	; 0x2b58 <xEventGroupWaitBits+0xb4>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    2b4e:	8e 81       	ldd	r24, Y+6	; 0x06
    2b50:	9f 81       	ldd	r25, Y+7	; 0x07
    2b52:	91 60       	ori	r25, 0x01	; 1
    2b54:	9f 83       	std	Y+7, r25	; 0x07
    2b56:	8e 83       	std	Y+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
    2b58:	89 89       	ldd	r24, Y+17	; 0x11
    2b5a:	88 23       	and	r24, r24
    2b5c:	29 f0       	breq	.+10     	; 0x2b68 <xEventGroupWaitBits+0xc4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
    2b5e:	8e 81       	ldd	r24, Y+6	; 0x06
    2b60:	9f 81       	ldd	r25, Y+7	; 0x07
    2b62:	94 60       	ori	r25, 0x04	; 4
    2b64:	9f 83       	std	Y+7, r25	; 0x07
    2b66:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    2b68:	8a 85       	ldd	r24, Y+10	; 0x0a
    2b6a:	9b 85       	ldd	r25, Y+11	; 0x0b
    2b6c:	bc 01       	movw	r22, r24
    2b6e:	6e 5f       	subi	r22, 0xFE	; 254
    2b70:	7f 4f       	sbci	r23, 0xFF	; 255
    2b72:	2e 85       	ldd	r18, Y+14	; 0x0e
    2b74:	3f 85       	ldd	r19, Y+15	; 0x0f
    2b76:	8e 81       	ldd	r24, Y+6	; 0x06
    2b78:	9f 81       	ldd	r25, Y+7	; 0x07
    2b7a:	28 2b       	or	r18, r24
    2b7c:	39 2b       	or	r19, r25
    2b7e:	4a 89       	ldd	r20, Y+18	; 0x12
    2b80:	5b 89       	ldd	r21, Y+19	; 0x13
    2b82:	cb 01       	movw	r24, r22
    2b84:	b9 01       	movw	r22, r18
    2b86:	0e 94 9b 29 	call	0x5336	; 0x5336 <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
    2b8a:	19 86       	std	Y+9, r1	; 0x09
    2b8c:	18 86       	std	Y+8, r1	; 0x08

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    2b8e:	0e 94 a8 25 	call	0x4b50	; 0x4b50 <xTaskResumeAll>
    2b92:	8c 83       	std	Y+4, r24	; 0x04

    if( xTicksToWait != ( TickType_t ) 0 )
    2b94:	8a 89       	ldd	r24, Y+18	; 0x12
    2b96:	9b 89       	ldd	r25, Y+19	; 0x13
    2b98:	00 97       	sbiw	r24, 0x00	; 0
    2b9a:	09 f4       	brne	.+2      	; 0x2b9e <xEventGroupWaitBits+0xfa>
    2b9c:	3c c0       	rjmp	.+120    	; 0x2c16 <xEventGroupWaitBits+0x172>
    {
        if( xAlreadyYielded == pdFALSE )
    2b9e:	8c 81       	ldd	r24, Y+4	; 0x04
    2ba0:	88 23       	and	r24, r24
    2ba2:	11 f4       	brne	.+4      	; 0x2ba8 <xEventGroupWaitBits+0x104>
        {
            portYIELD_WITHIN_API();
    2ba4:	0e 94 86 10 	call	0x210c	; 0x210c <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    2ba8:	0e 94 29 2e 	call	0x5c52	; 0x5c52 <uxTaskResetEventItemValue>
    2bac:	99 87       	std	Y+9, r25	; 0x09
    2bae:	88 87       	std	Y+8, r24	; 0x08

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    2bb0:	88 85       	ldd	r24, Y+8	; 0x08
    2bb2:	99 85       	ldd	r25, Y+9	; 0x09
    2bb4:	80 70       	andi	r24, 0x00	; 0
    2bb6:	92 70       	andi	r25, 0x02	; 2
    2bb8:	00 97       	sbiw	r24, 0x00	; 0
    2bba:	41 f5       	brne	.+80     	; 0x2c0c <xEventGroupWaitBits+0x168>
        {
            taskENTER_CRITICAL();
    2bbc:	0f b6       	in	r0, 0x3f	; 63
    2bbe:	f8 94       	cli
    2bc0:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    2bc2:	ea 85       	ldd	r30, Y+10	; 0x0a
    2bc4:	fb 85       	ldd	r31, Y+11	; 0x0b
    2bc6:	80 81       	ld	r24, Z
    2bc8:	91 81       	ldd	r25, Z+1	; 0x01
    2bca:	99 87       	std	Y+9, r25	; 0x09
    2bcc:	88 87       	std	Y+8, r24	; 0x08

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    2bce:	88 85       	ldd	r24, Y+8	; 0x08
    2bd0:	99 85       	ldd	r25, Y+9	; 0x09
    2bd2:	2e 85       	ldd	r18, Y+14	; 0x0e
    2bd4:	3f 85       	ldd	r19, Y+15	; 0x0f
    2bd6:	b9 01       	movw	r22, r18
    2bd8:	49 89       	ldd	r20, Y+17	; 0x11
    2bda:	0e 94 8d 17 	call	0x2f1a	; 0x2f1a <prvTestWaitCondition>
    2bde:	88 23       	and	r24, r24
    2be0:	89 f0       	breq	.+34     	; 0x2c04 <xEventGroupWaitBits+0x160>
                {
                    if( xClearOnExit != pdFALSE )
    2be2:	88 89       	ldd	r24, Y+16	; 0x10
    2be4:	88 23       	and	r24, r24
    2be6:	71 f0       	breq	.+28     	; 0x2c04 <xEventGroupWaitBits+0x160>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2be8:	ea 85       	ldd	r30, Y+10	; 0x0a
    2bea:	fb 85       	ldd	r31, Y+11	; 0x0b
    2bec:	20 81       	ld	r18, Z
    2bee:	31 81       	ldd	r19, Z+1	; 0x01
    2bf0:	8e 85       	ldd	r24, Y+14	; 0x0e
    2bf2:	9f 85       	ldd	r25, Y+15	; 0x0f
    2bf4:	80 95       	com	r24
    2bf6:	90 95       	com	r25
    2bf8:	82 23       	and	r24, r18
    2bfa:	93 23       	and	r25, r19
    2bfc:	ea 85       	ldd	r30, Y+10	; 0x0a
    2bfe:	fb 85       	ldd	r31, Y+11	; 0x0b
    2c00:	91 83       	std	Z+1, r25	; 0x01
    2c02:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
    2c04:	81 e0       	ldi	r24, 0x01	; 1
    2c06:	8b 83       	std	Y+3, r24	; 0x03
            }
            taskEXIT_CRITICAL();
    2c08:	0f 90       	pop	r0
    2c0a:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    2c0c:	88 85       	ldd	r24, Y+8	; 0x08
    2c0e:	99 85       	ldd	r25, Y+9	; 0x09
    2c10:	90 70       	andi	r25, 0x00	; 0
    2c12:	99 87       	std	Y+9, r25	; 0x09
    2c14:	88 87       	std	Y+8, r24	; 0x08
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    2c16:	88 85       	ldd	r24, Y+8	; 0x08
    2c18:	99 85       	ldd	r25, Y+9	; 0x09
}
    2c1a:	63 96       	adiw	r28, 0x13	; 19
    2c1c:	0f b6       	in	r0, 0x3f	; 63
    2c1e:	f8 94       	cli
    2c20:	de bf       	out	0x3e, r29	; 62
    2c22:	0f be       	out	0x3f, r0	; 63
    2c24:	cd bf       	out	0x3d, r28	; 61
    2c26:	cf 91       	pop	r28
    2c28:	df 91       	pop	r29
    2c2a:	1f 91       	pop	r17
    2c2c:	0f 91       	pop	r16
    2c2e:	08 95       	ret

00002c30 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
    2c30:	df 93       	push	r29
    2c32:	cf 93       	push	r28
    2c34:	cd b7       	in	r28, 0x3d	; 61
    2c36:	de b7       	in	r29, 0x3e	; 62
    2c38:	28 97       	sbiw	r28, 0x08	; 8
    2c3a:	0f b6       	in	r0, 0x3f	; 63
    2c3c:	f8 94       	cli
    2c3e:	de bf       	out	0x3e, r29	; 62
    2c40:	0f be       	out	0x3f, r0	; 63
    2c42:	cd bf       	out	0x3d, r28	; 61
    2c44:	9e 83       	std	Y+6, r25	; 0x06
    2c46:	8d 83       	std	Y+5, r24	; 0x05
    2c48:	78 87       	std	Y+8, r23	; 0x08
    2c4a:	6f 83       	std	Y+7, r22	; 0x07
    EventGroup_t * pxEventBits = xEventGroup;
    2c4c:	8d 81       	ldd	r24, Y+5	; 0x05
    2c4e:	9e 81       	ldd	r25, Y+6	; 0x06
    2c50:	9c 83       	std	Y+4, r25	; 0x04
    2c52:	8b 83       	std	Y+3, r24	; 0x03
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
    2c54:	0f b6       	in	r0, 0x3f	; 63
    2c56:	f8 94       	cli
    2c58:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
    2c5a:	eb 81       	ldd	r30, Y+3	; 0x03
    2c5c:	fc 81       	ldd	r31, Y+4	; 0x04
    2c5e:	80 81       	ld	r24, Z
    2c60:	91 81       	ldd	r25, Z+1	; 0x01
    2c62:	9a 83       	std	Y+2, r25	; 0x02
    2c64:	89 83       	std	Y+1, r24	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    2c66:	eb 81       	ldd	r30, Y+3	; 0x03
    2c68:	fc 81       	ldd	r31, Y+4	; 0x04
    2c6a:	20 81       	ld	r18, Z
    2c6c:	31 81       	ldd	r19, Z+1	; 0x01
    2c6e:	8f 81       	ldd	r24, Y+7	; 0x07
    2c70:	98 85       	ldd	r25, Y+8	; 0x08
    2c72:	80 95       	com	r24
    2c74:	90 95       	com	r25
    2c76:	82 23       	and	r24, r18
    2c78:	93 23       	and	r25, r19
    2c7a:	eb 81       	ldd	r30, Y+3	; 0x03
    2c7c:	fc 81       	ldd	r31, Y+4	; 0x04
    2c7e:	91 83       	std	Z+1, r25	; 0x01
    2c80:	80 83       	st	Z, r24
    }
    taskEXIT_CRITICAL();
    2c82:	0f 90       	pop	r0
    2c84:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    2c86:	89 81       	ldd	r24, Y+1	; 0x01
    2c88:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2c8a:	28 96       	adiw	r28, 0x08	; 8
    2c8c:	0f b6       	in	r0, 0x3f	; 63
    2c8e:	f8 94       	cli
    2c90:	de bf       	out	0x3e, r29	; 62
    2c92:	0f be       	out	0x3f, r0	; 63
    2c94:	cd bf       	out	0x3d, r28	; 61
    2c96:	cf 91       	pop	r28
    2c98:	df 91       	pop	r29
    2c9a:	08 95       	ret

00002c9c <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    2c9c:	df 93       	push	r29
    2c9e:	cf 93       	push	r28
    2ca0:	cd b7       	in	r28, 0x3d	; 61
    2ca2:	de b7       	in	r29, 0x3e	; 62
    2ca4:	27 97       	sbiw	r28, 0x07	; 7
    2ca6:	0f b6       	in	r0, 0x3f	; 63
    2ca8:	f8 94       	cli
    2caa:	de bf       	out	0x3e, r29	; 62
    2cac:	0f be       	out	0x3f, r0	; 63
    2cae:	cd bf       	out	0x3d, r28	; 61
    2cb0:	9f 83       	std	Y+7, r25	; 0x07
    2cb2:	8e 83       	std	Y+6, r24	; 0x06
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
    2cb4:	8e 81       	ldd	r24, Y+6	; 0x06
    2cb6:	9f 81       	ldd	r25, Y+7	; 0x07
    2cb8:	9c 83       	std	Y+4, r25	; 0x04
    2cba:	8b 83       	std	Y+3, r24	; 0x03
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2cbc:	1d 82       	std	Y+5, r1	; 0x05
    {
        uxReturn = pxEventBits->uxEventBits;
    2cbe:	eb 81       	ldd	r30, Y+3	; 0x03
    2cc0:	fc 81       	ldd	r31, Y+4	; 0x04
    2cc2:	80 81       	ld	r24, Z
    2cc4:	91 81       	ldd	r25, Z+1	; 0x01
    2cc6:	9a 83       	std	Y+2, r25	; 0x02
    2cc8:	89 83       	std	Y+1, r24	; 0x01
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
    2cca:	89 81       	ldd	r24, Y+1	; 0x01
    2ccc:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    2cce:	27 96       	adiw	r28, 0x07	; 7
    2cd0:	0f b6       	in	r0, 0x3f	; 63
    2cd2:	f8 94       	cli
    2cd4:	de bf       	out	0x3e, r29	; 62
    2cd6:	0f be       	out	0x3f, r0	; 63
    2cd8:	cd bf       	out	0x3d, r28	; 61
    2cda:	cf 91       	pop	r28
    2cdc:	df 91       	pop	r29
    2cde:	08 95       	ret

00002ce0 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    2ce0:	df 93       	push	r29
    2ce2:	cf 93       	push	r28
    2ce4:	cd b7       	in	r28, 0x3d	; 61
    2ce6:	de b7       	in	r29, 0x3e	; 62
    2ce8:	65 97       	sbiw	r28, 0x15	; 21
    2cea:	0f b6       	in	r0, 0x3f	; 63
    2cec:	f8 94       	cli
    2cee:	de bf       	out	0x3e, r29	; 62
    2cf0:	0f be       	out	0x3f, r0	; 63
    2cf2:	cd bf       	out	0x3d, r28	; 61
    2cf4:	9b 8b       	std	Y+19, r25	; 0x13
    2cf6:	8a 8b       	std	Y+18, r24	; 0x12
    2cf8:	7d 8b       	std	Y+21, r23	; 0x15
    2cfa:	6c 8b       	std	Y+20, r22	; 0x14
    ListItem_t * pxListItem, * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    2cfc:	19 86       	std	Y+9, r1	; 0x09
    2cfe:	18 86       	std	Y+8, r1	; 0x08
    EventGroup_t * pxEventBits = xEventGroup;
    2d00:	8a 89       	ldd	r24, Y+18	; 0x12
    2d02:	9b 89       	ldd	r25, Y+19	; 0x13
    2d04:	9b 83       	std	Y+3, r25	; 0x03
    2d06:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xMatchFound = pdFALSE;
    2d08:	19 82       	std	Y+1, r1	; 0x01
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
    2d0a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d0c:	9b 81       	ldd	r25, Y+3	; 0x03
    2d0e:	02 96       	adiw	r24, 0x02	; 2
    2d10:	9b 87       	std	Y+11, r25	; 0x0b
    2d12:	8a 87       	std	Y+10, r24	; 0x0a
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2d14:	8a 85       	ldd	r24, Y+10	; 0x0a
    2d16:	9b 85       	ldd	r25, Y+11	; 0x0b
    2d18:	03 96       	adiw	r24, 0x03	; 3
    2d1a:	9d 87       	std	Y+13, r25	; 0x0d
    2d1c:	8c 87       	std	Y+12, r24	; 0x0c
    vTaskSuspendAll();
    2d1e:	0e 94 9c 25 	call	0x4b38	; 0x4b38 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    2d22:	ea 85       	ldd	r30, Y+10	; 0x0a
    2d24:	fb 85       	ldd	r31, Y+11	; 0x0b
    2d26:	85 81       	ldd	r24, Z+5	; 0x05
    2d28:	96 81       	ldd	r25, Z+6	; 0x06
    2d2a:	99 8b       	std	Y+17, r25	; 0x11
    2d2c:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    2d2e:	ea 81       	ldd	r30, Y+2	; 0x02
    2d30:	fb 81       	ldd	r31, Y+3	; 0x03
    2d32:	20 81       	ld	r18, Z
    2d34:	31 81       	ldd	r19, Z+1	; 0x01
    2d36:	8c 89       	ldd	r24, Y+20	; 0x14
    2d38:	9d 89       	ldd	r25, Y+21	; 0x15
    2d3a:	82 2b       	or	r24, r18
    2d3c:	93 2b       	or	r25, r19
    2d3e:	ea 81       	ldd	r30, Y+2	; 0x02
    2d40:	fb 81       	ldd	r31, Y+3	; 0x03
    2d42:	91 83       	std	Z+1, r25	; 0x01
    2d44:	80 83       	st	Z, r24
    2d46:	59 c0       	rjmp	.+178    	; 0x2dfa <xEventGroupSetBits+0x11a>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
    2d48:	e8 89       	ldd	r30, Y+16	; 0x10
    2d4a:	f9 89       	ldd	r31, Y+17	; 0x11
    2d4c:	82 81       	ldd	r24, Z+2	; 0x02
    2d4e:	93 81       	ldd	r25, Z+3	; 0x03
    2d50:	9f 87       	std	Y+15, r25	; 0x0f
    2d52:	8e 87       	std	Y+14, r24	; 0x0e
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    2d54:	e8 89       	ldd	r30, Y+16	; 0x10
    2d56:	f9 89       	ldd	r31, Y+17	; 0x11
    2d58:	80 81       	ld	r24, Z
    2d5a:	91 81       	ldd	r25, Z+1	; 0x01
    2d5c:	9f 83       	std	Y+7, r25	; 0x07
    2d5e:	8e 83       	std	Y+6, r24	; 0x06
            xMatchFound = pdFALSE;
    2d60:	19 82       	std	Y+1, r1	; 0x01

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    2d62:	8e 81       	ldd	r24, Y+6	; 0x06
    2d64:	9f 81       	ldd	r25, Y+7	; 0x07
    2d66:	80 70       	andi	r24, 0x00	; 0
    2d68:	9d 83       	std	Y+5, r25	; 0x05
    2d6a:	8c 83       	std	Y+4, r24	; 0x04
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    2d6c:	8e 81       	ldd	r24, Y+6	; 0x06
    2d6e:	9f 81       	ldd	r25, Y+7	; 0x07
    2d70:	90 70       	andi	r25, 0x00	; 0
    2d72:	9f 83       	std	Y+7, r25	; 0x07
    2d74:	8e 83       	std	Y+6, r24	; 0x06

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    2d76:	8c 81       	ldd	r24, Y+4	; 0x04
    2d78:	9d 81       	ldd	r25, Y+5	; 0x05
    2d7a:	80 70       	andi	r24, 0x00	; 0
    2d7c:	94 70       	andi	r25, 0x04	; 4
    2d7e:	00 97       	sbiw	r24, 0x00	; 0
    2d80:	69 f4       	brne	.+26     	; 0x2d9c <xEventGroupSetBits+0xbc>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    2d82:	ea 81       	ldd	r30, Y+2	; 0x02
    2d84:	fb 81       	ldd	r31, Y+3	; 0x03
    2d86:	20 81       	ld	r18, Z
    2d88:	31 81       	ldd	r19, Z+1	; 0x01
    2d8a:	8e 81       	ldd	r24, Y+6	; 0x06
    2d8c:	9f 81       	ldd	r25, Y+7	; 0x07
    2d8e:	82 23       	and	r24, r18
    2d90:	93 23       	and	r25, r19
    2d92:	00 97       	sbiw	r24, 0x00	; 0
    2d94:	91 f0       	breq	.+36     	; 0x2dba <xEventGroupSetBits+0xda>
                {
                    xMatchFound = pdTRUE;
    2d96:	81 e0       	ldi	r24, 0x01	; 1
    2d98:	89 83       	std	Y+1, r24	; 0x01
    2d9a:	0f c0       	rjmp	.+30     	; 0x2dba <xEventGroupSetBits+0xda>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    2d9c:	ea 81       	ldd	r30, Y+2	; 0x02
    2d9e:	fb 81       	ldd	r31, Y+3	; 0x03
    2da0:	20 81       	ld	r18, Z
    2da2:	31 81       	ldd	r19, Z+1	; 0x01
    2da4:	8e 81       	ldd	r24, Y+6	; 0x06
    2da6:	9f 81       	ldd	r25, Y+7	; 0x07
    2da8:	28 23       	and	r18, r24
    2daa:	39 23       	and	r19, r25
    2dac:	8e 81       	ldd	r24, Y+6	; 0x06
    2dae:	9f 81       	ldd	r25, Y+7	; 0x07
    2db0:	28 17       	cp	r18, r24
    2db2:	39 07       	cpc	r19, r25
    2db4:	11 f4       	brne	.+4      	; 0x2dba <xEventGroupSetBits+0xda>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
    2db6:	81 e0       	ldi	r24, 0x01	; 1
    2db8:	89 83       	std	Y+1, r24	; 0x01
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
    2dba:	89 81       	ldd	r24, Y+1	; 0x01
    2dbc:	88 23       	and	r24, r24
    2dbe:	c9 f0       	breq	.+50     	; 0x2df2 <xEventGroupSetBits+0x112>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    2dc0:	8c 81       	ldd	r24, Y+4	; 0x04
    2dc2:	9d 81       	ldd	r25, Y+5	; 0x05
    2dc4:	80 70       	andi	r24, 0x00	; 0
    2dc6:	91 70       	andi	r25, 0x01	; 1
    2dc8:	00 97       	sbiw	r24, 0x00	; 0
    2dca:	41 f0       	breq	.+16     	; 0x2ddc <xEventGroupSetBits+0xfc>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    2dcc:	88 85       	ldd	r24, Y+8	; 0x08
    2dce:	99 85       	ldd	r25, Y+9	; 0x09
    2dd0:	2e 81       	ldd	r18, Y+6	; 0x06
    2dd2:	3f 81       	ldd	r19, Y+7	; 0x07
    2dd4:	82 2b       	or	r24, r18
    2dd6:	93 2b       	or	r25, r19
    2dd8:	99 87       	std	Y+9, r25	; 0x09
    2dda:	88 87       	std	Y+8, r24	; 0x08
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    2ddc:	ea 81       	ldd	r30, Y+2	; 0x02
    2dde:	fb 81       	ldd	r31, Y+3	; 0x03
    2de0:	80 81       	ld	r24, Z
    2de2:	91 81       	ldd	r25, Z+1	; 0x01
    2de4:	9c 01       	movw	r18, r24
    2de6:	32 60       	ori	r19, 0x02	; 2
    2de8:	88 89       	ldd	r24, Y+16	; 0x10
    2dea:	99 89       	ldd	r25, Y+17	; 0x11
    2dec:	b9 01       	movw	r22, r18
    2dee:	0e 94 a6 2b 	call	0x574c	; 0x574c <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
    2df2:	8e 85       	ldd	r24, Y+14	; 0x0e
    2df4:	9f 85       	ldd	r25, Y+15	; 0x0f
    2df6:	99 8b       	std	Y+17, r25	; 0x11
    2df8:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    2dfa:	28 89       	ldd	r18, Y+16	; 0x10
    2dfc:	39 89       	ldd	r19, Y+17	; 0x11
    2dfe:	8c 85       	ldd	r24, Y+12	; 0x0c
    2e00:	9d 85       	ldd	r25, Y+13	; 0x0d
    2e02:	28 17       	cp	r18, r24
    2e04:	39 07       	cpc	r19, r25
    2e06:	09 f0       	breq	.+2      	; 0x2e0a <xEventGroupSetBits+0x12a>
    2e08:	9f cf       	rjmp	.-194    	; 0x2d48 <xEventGroupSetBits+0x68>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    2e0a:	ea 81       	ldd	r30, Y+2	; 0x02
    2e0c:	fb 81       	ldd	r31, Y+3	; 0x03
    2e0e:	20 81       	ld	r18, Z
    2e10:	31 81       	ldd	r19, Z+1	; 0x01
    2e12:	88 85       	ldd	r24, Y+8	; 0x08
    2e14:	99 85       	ldd	r25, Y+9	; 0x09
    2e16:	80 95       	com	r24
    2e18:	90 95       	com	r25
    2e1a:	82 23       	and	r24, r18
    2e1c:	93 23       	and	r25, r19
    2e1e:	ea 81       	ldd	r30, Y+2	; 0x02
    2e20:	fb 81       	ldd	r31, Y+3	; 0x03
    2e22:	91 83       	std	Z+1, r25	; 0x01
    2e24:	80 83       	st	Z, r24
    }
    ( void ) xTaskResumeAll();
    2e26:	0e 94 a8 25 	call	0x4b50	; 0x4b50 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
    2e2a:	ea 81       	ldd	r30, Y+2	; 0x02
    2e2c:	fb 81       	ldd	r31, Y+3	; 0x03
    2e2e:	80 81       	ld	r24, Z
    2e30:	91 81       	ldd	r25, Z+1	; 0x01
}
    2e32:	65 96       	adiw	r28, 0x15	; 21
    2e34:	0f b6       	in	r0, 0x3f	; 63
    2e36:	f8 94       	cli
    2e38:	de bf       	out	0x3e, r29	; 62
    2e3a:	0f be       	out	0x3f, r0	; 63
    2e3c:	cd bf       	out	0x3d, r28	; 61
    2e3e:	cf 91       	pop	r28
    2e40:	df 91       	pop	r29
    2e42:	08 95       	ret

00002e44 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    2e44:	df 93       	push	r29
    2e46:	cf 93       	push	r28
    2e48:	00 d0       	rcall	.+0      	; 0x2e4a <vEventGroupDelete+0x6>
    2e4a:	00 d0       	rcall	.+0      	; 0x2e4c <vEventGroupDelete+0x8>
    2e4c:	00 d0       	rcall	.+0      	; 0x2e4e <vEventGroupDelete+0xa>
    2e4e:	cd b7       	in	r28, 0x3d	; 61
    2e50:	de b7       	in	r29, 0x3e	; 62
    2e52:	9e 83       	std	Y+6, r25	; 0x06
    2e54:	8d 83       	std	Y+5, r24	; 0x05
    EventGroup_t * pxEventBits = xEventGroup;
    2e56:	8d 81       	ldd	r24, Y+5	; 0x05
    2e58:	9e 81       	ldd	r25, Y+6	; 0x06
    2e5a:	9c 83       	std	Y+4, r25	; 0x04
    2e5c:	8b 83       	std	Y+3, r24	; 0x03
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    2e5e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e60:	9c 81       	ldd	r25, Y+4	; 0x04
    2e62:	02 96       	adiw	r24, 0x02	; 2
    2e64:	9a 83       	std	Y+2, r25	; 0x02
    2e66:	89 83       	std	Y+1, r24	; 0x01

    vTaskSuspendAll();
    2e68:	0e 94 9c 25 	call	0x4b38	; 0x4b38 <vTaskSuspendAll>
    2e6c:	08 c0       	rjmp	.+16     	; 0x2e7e <vEventGroupDelete+0x3a>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    2e6e:	e9 81       	ldd	r30, Y+1	; 0x01
    2e70:	fa 81       	ldd	r31, Y+2	; 0x02
    2e72:	85 81       	ldd	r24, Z+5	; 0x05
    2e74:	96 81       	ldd	r25, Z+6	; 0x06
    2e76:	60 e0       	ldi	r22, 0x00	; 0
    2e78:	72 e0       	ldi	r23, 0x02	; 2
    2e7a:	0e 94 a6 2b 	call	0x574c	; 0x574c <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    2e7e:	e9 81       	ldd	r30, Y+1	; 0x01
    2e80:	fa 81       	ldd	r31, Y+2	; 0x02
    2e82:	80 81       	ld	r24, Z
    2e84:	88 23       	and	r24, r24
    2e86:	99 f7       	brne	.-26     	; 0x2e6e <vEventGroupDelete+0x2a>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
            {
                /* The event group can only have been allocated dynamically - free
                 * it again. */
                vPortFree( pxEventBits );
    2e88:	8b 81       	ldd	r24, Y+3	; 0x03
    2e8a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e8c:	0e 94 a1 0e 	call	0x1d42	; 0x1d42 <vPortFree>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    ( void ) xTaskResumeAll();
    2e90:	0e 94 a8 25 	call	0x4b50	; 0x4b50 <xTaskResumeAll>
}
    2e94:	26 96       	adiw	r28, 0x06	; 6
    2e96:	0f b6       	in	r0, 0x3f	; 63
    2e98:	f8 94       	cli
    2e9a:	de bf       	out	0x3e, r29	; 62
    2e9c:	0f be       	out	0x3f, r0	; 63
    2e9e:	cd bf       	out	0x3d, r28	; 61
    2ea0:	cf 91       	pop	r28
    2ea2:	df 91       	pop	r29
    2ea4:	08 95       	ret

00002ea6 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    2ea6:	df 93       	push	r29
    2ea8:	cf 93       	push	r28
    2eaa:	00 d0       	rcall	.+0      	; 0x2eac <vEventGroupSetBitsCallback+0x6>
    2eac:	00 d0       	rcall	.+0      	; 0x2eae <vEventGroupSetBitsCallback+0x8>
    2eae:	00 d0       	rcall	.+0      	; 0x2eb0 <vEventGroupSetBitsCallback+0xa>
    2eb0:	cd b7       	in	r28, 0x3d	; 61
    2eb2:	de b7       	in	r29, 0x3e	; 62
    2eb4:	9a 83       	std	Y+2, r25	; 0x02
    2eb6:	89 83       	std	Y+1, r24	; 0x01
    2eb8:	4b 83       	std	Y+3, r20	; 0x03
    2eba:	5c 83       	std	Y+4, r21	; 0x04
    2ebc:	6d 83       	std	Y+5, r22	; 0x05
    2ebe:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    2ec0:	89 81       	ldd	r24, Y+1	; 0x01
    2ec2:	9a 81       	ldd	r25, Y+2	; 0x02
    2ec4:	2b 81       	ldd	r18, Y+3	; 0x03
    2ec6:	3c 81       	ldd	r19, Y+4	; 0x04
    2ec8:	b9 01       	movw	r22, r18
    2eca:	0e 94 70 16 	call	0x2ce0	; 0x2ce0 <xEventGroupSetBits>
}
    2ece:	26 96       	adiw	r28, 0x06	; 6
    2ed0:	0f b6       	in	r0, 0x3f	; 63
    2ed2:	f8 94       	cli
    2ed4:	de bf       	out	0x3e, r29	; 62
    2ed6:	0f be       	out	0x3f, r0	; 63
    2ed8:	cd bf       	out	0x3d, r28	; 61
    2eda:	cf 91       	pop	r28
    2edc:	df 91       	pop	r29
    2ede:	08 95       	ret

00002ee0 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    2ee0:	df 93       	push	r29
    2ee2:	cf 93       	push	r28
    2ee4:	00 d0       	rcall	.+0      	; 0x2ee6 <vEventGroupClearBitsCallback+0x6>
    2ee6:	00 d0       	rcall	.+0      	; 0x2ee8 <vEventGroupClearBitsCallback+0x8>
    2ee8:	00 d0       	rcall	.+0      	; 0x2eea <vEventGroupClearBitsCallback+0xa>
    2eea:	cd b7       	in	r28, 0x3d	; 61
    2eec:	de b7       	in	r29, 0x3e	; 62
    2eee:	9a 83       	std	Y+2, r25	; 0x02
    2ef0:	89 83       	std	Y+1, r24	; 0x01
    2ef2:	4b 83       	std	Y+3, r20	; 0x03
    2ef4:	5c 83       	std	Y+4, r21	; 0x04
    2ef6:	6d 83       	std	Y+5, r22	; 0x05
    2ef8:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    2efa:	89 81       	ldd	r24, Y+1	; 0x01
    2efc:	9a 81       	ldd	r25, Y+2	; 0x02
    2efe:	2b 81       	ldd	r18, Y+3	; 0x03
    2f00:	3c 81       	ldd	r19, Y+4	; 0x04
    2f02:	b9 01       	movw	r22, r18
    2f04:	0e 94 18 16 	call	0x2c30	; 0x2c30 <xEventGroupClearBits>
}
    2f08:	26 96       	adiw	r28, 0x06	; 6
    2f0a:	0f b6       	in	r0, 0x3f	; 63
    2f0c:	f8 94       	cli
    2f0e:	de bf       	out	0x3e, r29	; 62
    2f10:	0f be       	out	0x3f, r0	; 63
    2f12:	cd bf       	out	0x3d, r28	; 61
    2f14:	cf 91       	pop	r28
    2f16:	df 91       	pop	r29
    2f18:	08 95       	ret

00002f1a <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    2f1a:	df 93       	push	r29
    2f1c:	cf 93       	push	r28
    2f1e:	00 d0       	rcall	.+0      	; 0x2f20 <prvTestWaitCondition+0x6>
    2f20:	00 d0       	rcall	.+0      	; 0x2f22 <prvTestWaitCondition+0x8>
    2f22:	00 d0       	rcall	.+0      	; 0x2f24 <prvTestWaitCondition+0xa>
    2f24:	cd b7       	in	r28, 0x3d	; 61
    2f26:	de b7       	in	r29, 0x3e	; 62
    2f28:	9b 83       	std	Y+3, r25	; 0x03
    2f2a:	8a 83       	std	Y+2, r24	; 0x02
    2f2c:	7d 83       	std	Y+5, r23	; 0x05
    2f2e:	6c 83       	std	Y+4, r22	; 0x04
    2f30:	4e 83       	std	Y+6, r20	; 0x06
    BaseType_t xWaitConditionMet = pdFALSE;
    2f32:	19 82       	std	Y+1, r1	; 0x01

    if( xWaitForAllBits == pdFALSE )
    2f34:	8e 81       	ldd	r24, Y+6	; 0x06
    2f36:	88 23       	and	r24, r24
    2f38:	59 f4       	brne	.+22     	; 0x2f50 <prvTestWaitCondition+0x36>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    2f3a:	8a 81       	ldd	r24, Y+2	; 0x02
    2f3c:	9b 81       	ldd	r25, Y+3	; 0x03
    2f3e:	2c 81       	ldd	r18, Y+4	; 0x04
    2f40:	3d 81       	ldd	r19, Y+5	; 0x05
    2f42:	82 23       	and	r24, r18
    2f44:	93 23       	and	r25, r19
    2f46:	00 97       	sbiw	r24, 0x00	; 0
    2f48:	81 f0       	breq	.+32     	; 0x2f6a <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    2f4a:	81 e0       	ldi	r24, 0x01	; 1
    2f4c:	89 83       	std	Y+1, r24	; 0x01
    2f4e:	0d c0       	rjmp	.+26     	; 0x2f6a <prvTestWaitCondition+0x50>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2f50:	2a 81       	ldd	r18, Y+2	; 0x02
    2f52:	3b 81       	ldd	r19, Y+3	; 0x03
    2f54:	8c 81       	ldd	r24, Y+4	; 0x04
    2f56:	9d 81       	ldd	r25, Y+5	; 0x05
    2f58:	28 23       	and	r18, r24
    2f5a:	39 23       	and	r19, r25
    2f5c:	8c 81       	ldd	r24, Y+4	; 0x04
    2f5e:	9d 81       	ldd	r25, Y+5	; 0x05
    2f60:	28 17       	cp	r18, r24
    2f62:	39 07       	cpc	r19, r25
    2f64:	11 f4       	brne	.+4      	; 0x2f6a <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    2f66:	81 e0       	ldi	r24, 0x01	; 1
    2f68:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
    2f6a:	89 81       	ldd	r24, Y+1	; 0x01
}
    2f6c:	26 96       	adiw	r28, 0x06	; 6
    2f6e:	0f b6       	in	r0, 0x3f	; 63
    2f70:	f8 94       	cli
    2f72:	de bf       	out	0x3e, r29	; 62
    2f74:	0f be       	out	0x3f, r0	; 63
    2f76:	cd bf       	out	0x3d, r28	; 61
    2f78:	cf 91       	pop	r28
    2f7a:	df 91       	pop	r29
    2f7c:	08 95       	ret

00002f7e <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2f7e:	df 93       	push	r29
    2f80:	cf 93       	push	r28
    2f82:	00 d0       	rcall	.+0      	; 0x2f84 <vListInitialise+0x6>
    2f84:	cd b7       	in	r28, 0x3d	; 61
    2f86:	de b7       	in	r29, 0x3e	; 62
    2f88:	9a 83       	std	Y+2, r25	; 0x02
    2f8a:	89 83       	std	Y+1, r24	; 0x01
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2f8c:	89 81       	ldd	r24, Y+1	; 0x01
    2f8e:	9a 81       	ldd	r25, Y+2	; 0x02
    2f90:	03 96       	adiw	r24, 0x03	; 3
    2f92:	e9 81       	ldd	r30, Y+1	; 0x01
    2f94:	fa 81       	ldd	r31, Y+2	; 0x02
    2f96:	92 83       	std	Z+2, r25	; 0x02
    2f98:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    2f9a:	e9 81       	ldd	r30, Y+1	; 0x01
    2f9c:	fa 81       	ldd	r31, Y+2	; 0x02
    2f9e:	8f ef       	ldi	r24, 0xFF	; 255
    2fa0:	9f ef       	ldi	r25, 0xFF	; 255
    2fa2:	94 83       	std	Z+4, r25	; 0x04
    2fa4:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2fa6:	89 81       	ldd	r24, Y+1	; 0x01
    2fa8:	9a 81       	ldd	r25, Y+2	; 0x02
    2faa:	03 96       	adiw	r24, 0x03	; 3
    2fac:	e9 81       	ldd	r30, Y+1	; 0x01
    2fae:	fa 81       	ldd	r31, Y+2	; 0x02
    2fb0:	96 83       	std	Z+6, r25	; 0x06
    2fb2:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2fb4:	89 81       	ldd	r24, Y+1	; 0x01
    2fb6:	9a 81       	ldd	r25, Y+2	; 0x02
    2fb8:	03 96       	adiw	r24, 0x03	; 3
    2fba:	e9 81       	ldd	r30, Y+1	; 0x01
    2fbc:	fa 81       	ldd	r31, Y+2	; 0x02
    2fbe:	90 87       	std	Z+8, r25	; 0x08
    2fc0:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2fc2:	e9 81       	ldd	r30, Y+1	; 0x01
    2fc4:	fa 81       	ldd	r31, Y+2	; 0x02
    2fc6:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    2fc8:	0f 90       	pop	r0
    2fca:	0f 90       	pop	r0
    2fcc:	cf 91       	pop	r28
    2fce:	df 91       	pop	r29
    2fd0:	08 95       	ret

00002fd2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    2fd2:	df 93       	push	r29
    2fd4:	cf 93       	push	r28
    2fd6:	00 d0       	rcall	.+0      	; 0x2fd8 <vListInitialiseItem+0x6>
    2fd8:	cd b7       	in	r28, 0x3d	; 61
    2fda:	de b7       	in	r29, 0x3e	; 62
    2fdc:	9a 83       	std	Y+2, r25	; 0x02
    2fde:	89 83       	std	Y+1, r24	; 0x01
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    2fe0:	e9 81       	ldd	r30, Y+1	; 0x01
    2fe2:	fa 81       	ldd	r31, Y+2	; 0x02
    2fe4:	11 86       	std	Z+9, r1	; 0x09
    2fe6:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    2fe8:	0f 90       	pop	r0
    2fea:	0f 90       	pop	r0
    2fec:	cf 91       	pop	r28
    2fee:	df 91       	pop	r29
    2ff0:	08 95       	ret

00002ff2 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    2ff2:	df 93       	push	r29
    2ff4:	cf 93       	push	r28
    2ff6:	00 d0       	rcall	.+0      	; 0x2ff8 <vListInsertEnd+0x6>
    2ff8:	00 d0       	rcall	.+0      	; 0x2ffa <vListInsertEnd+0x8>
    2ffa:	00 d0       	rcall	.+0      	; 0x2ffc <vListInsertEnd+0xa>
    2ffc:	cd b7       	in	r28, 0x3d	; 61
    2ffe:	de b7       	in	r29, 0x3e	; 62
    3000:	9c 83       	std	Y+4, r25	; 0x04
    3002:	8b 83       	std	Y+3, r24	; 0x03
    3004:	7e 83       	std	Y+6, r23	; 0x06
    3006:	6d 83       	std	Y+5, r22	; 0x05
    ListItem_t * const pxIndex = pxList->pxIndex;
    3008:	eb 81       	ldd	r30, Y+3	; 0x03
    300a:	fc 81       	ldd	r31, Y+4	; 0x04
    300c:	81 81       	ldd	r24, Z+1	; 0x01
    300e:	92 81       	ldd	r25, Z+2	; 0x02
    3010:	9a 83       	std	Y+2, r25	; 0x02
    3012:	89 83       	std	Y+1, r24	; 0x01
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    3014:	ed 81       	ldd	r30, Y+5	; 0x05
    3016:	fe 81       	ldd	r31, Y+6	; 0x06
    3018:	89 81       	ldd	r24, Y+1	; 0x01
    301a:	9a 81       	ldd	r25, Y+2	; 0x02
    301c:	93 83       	std	Z+3, r25	; 0x03
    301e:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    3020:	e9 81       	ldd	r30, Y+1	; 0x01
    3022:	fa 81       	ldd	r31, Y+2	; 0x02
    3024:	84 81       	ldd	r24, Z+4	; 0x04
    3026:	95 81       	ldd	r25, Z+5	; 0x05
    3028:	ed 81       	ldd	r30, Y+5	; 0x05
    302a:	fe 81       	ldd	r31, Y+6	; 0x06
    302c:	95 83       	std	Z+5, r25	; 0x05
    302e:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    3030:	e9 81       	ldd	r30, Y+1	; 0x01
    3032:	fa 81       	ldd	r31, Y+2	; 0x02
    3034:	04 80       	ldd	r0, Z+4	; 0x04
    3036:	f5 81       	ldd	r31, Z+5	; 0x05
    3038:	e0 2d       	mov	r30, r0
    303a:	8d 81       	ldd	r24, Y+5	; 0x05
    303c:	9e 81       	ldd	r25, Y+6	; 0x06
    303e:	93 83       	std	Z+3, r25	; 0x03
    3040:	82 83       	std	Z+2, r24	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    3042:	e9 81       	ldd	r30, Y+1	; 0x01
    3044:	fa 81       	ldd	r31, Y+2	; 0x02
    3046:	8d 81       	ldd	r24, Y+5	; 0x05
    3048:	9e 81       	ldd	r25, Y+6	; 0x06
    304a:	95 83       	std	Z+5, r25	; 0x05
    304c:	84 83       	std	Z+4, r24	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    304e:	ed 81       	ldd	r30, Y+5	; 0x05
    3050:	fe 81       	ldd	r31, Y+6	; 0x06
    3052:	8b 81       	ldd	r24, Y+3	; 0x03
    3054:	9c 81       	ldd	r25, Y+4	; 0x04
    3056:	91 87       	std	Z+9, r25	; 0x09
    3058:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    305a:	eb 81       	ldd	r30, Y+3	; 0x03
    305c:	fc 81       	ldd	r31, Y+4	; 0x04
    305e:	80 81       	ld	r24, Z
    3060:	8f 5f       	subi	r24, 0xFF	; 255
    3062:	eb 81       	ldd	r30, Y+3	; 0x03
    3064:	fc 81       	ldd	r31, Y+4	; 0x04
    3066:	80 83       	st	Z, r24
}
    3068:	26 96       	adiw	r28, 0x06	; 6
    306a:	0f b6       	in	r0, 0x3f	; 63
    306c:	f8 94       	cli
    306e:	de bf       	out	0x3e, r29	; 62
    3070:	0f be       	out	0x3f, r0	; 63
    3072:	cd bf       	out	0x3d, r28	; 61
    3074:	cf 91       	pop	r28
    3076:	df 91       	pop	r29
    3078:	08 95       	ret

0000307a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    307a:	df 93       	push	r29
    307c:	cf 93       	push	r28
    307e:	cd b7       	in	r28, 0x3d	; 61
    3080:	de b7       	in	r29, 0x3e	; 62
    3082:	28 97       	sbiw	r28, 0x08	; 8
    3084:	0f b6       	in	r0, 0x3f	; 63
    3086:	f8 94       	cli
    3088:	de bf       	out	0x3e, r29	; 62
    308a:	0f be       	out	0x3f, r0	; 63
    308c:	cd bf       	out	0x3d, r28	; 61
    308e:	9e 83       	std	Y+6, r25	; 0x06
    3090:	8d 83       	std	Y+5, r24	; 0x05
    3092:	78 87       	std	Y+8, r23	; 0x08
    3094:	6f 83       	std	Y+7, r22	; 0x07
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    3096:	ef 81       	ldd	r30, Y+7	; 0x07
    3098:	f8 85       	ldd	r31, Y+8	; 0x08
    309a:	80 81       	ld	r24, Z
    309c:	91 81       	ldd	r25, Z+1	; 0x01
    309e:	9a 83       	std	Y+2, r25	; 0x02
    30a0:	89 83       	std	Y+1, r24	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    30a2:	89 81       	ldd	r24, Y+1	; 0x01
    30a4:	9a 81       	ldd	r25, Y+2	; 0x02
    30a6:	2f ef       	ldi	r18, 0xFF	; 255
    30a8:	8f 3f       	cpi	r24, 0xFF	; 255
    30aa:	92 07       	cpc	r25, r18
    30ac:	39 f4       	brne	.+14     	; 0x30bc <vListInsert+0x42>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    30ae:	ed 81       	ldd	r30, Y+5	; 0x05
    30b0:	fe 81       	ldd	r31, Y+6	; 0x06
    30b2:	87 81       	ldd	r24, Z+7	; 0x07
    30b4:	90 85       	ldd	r25, Z+8	; 0x08
    30b6:	9c 83       	std	Y+4, r25	; 0x04
    30b8:	8b 83       	std	Y+3, r24	; 0x03
    30ba:	18 c0       	rjmp	.+48     	; 0x30ec <vListInsert+0x72>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    30bc:	8d 81       	ldd	r24, Y+5	; 0x05
    30be:	9e 81       	ldd	r25, Y+6	; 0x06
    30c0:	03 96       	adiw	r24, 0x03	; 3
    30c2:	9c 83       	std	Y+4, r25	; 0x04
    30c4:	8b 83       	std	Y+3, r24	; 0x03
    30c6:	06 c0       	rjmp	.+12     	; 0x30d4 <vListInsert+0x5a>
    30c8:	eb 81       	ldd	r30, Y+3	; 0x03
    30ca:	fc 81       	ldd	r31, Y+4	; 0x04
    30cc:	82 81       	ldd	r24, Z+2	; 0x02
    30ce:	93 81       	ldd	r25, Z+3	; 0x03
    30d0:	9c 83       	std	Y+4, r25	; 0x04
    30d2:	8b 83       	std	Y+3, r24	; 0x03
    30d4:	eb 81       	ldd	r30, Y+3	; 0x03
    30d6:	fc 81       	ldd	r31, Y+4	; 0x04
    30d8:	02 80       	ldd	r0, Z+2	; 0x02
    30da:	f3 81       	ldd	r31, Z+3	; 0x03
    30dc:	e0 2d       	mov	r30, r0
    30de:	20 81       	ld	r18, Z
    30e0:	31 81       	ldd	r19, Z+1	; 0x01
    30e2:	89 81       	ldd	r24, Y+1	; 0x01
    30e4:	9a 81       	ldd	r25, Y+2	; 0x02
    30e6:	82 17       	cp	r24, r18
    30e8:	93 07       	cpc	r25, r19
    30ea:	70 f7       	brcc	.-36     	; 0x30c8 <vListInsert+0x4e>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    30ec:	eb 81       	ldd	r30, Y+3	; 0x03
    30ee:	fc 81       	ldd	r31, Y+4	; 0x04
    30f0:	82 81       	ldd	r24, Z+2	; 0x02
    30f2:	93 81       	ldd	r25, Z+3	; 0x03
    30f4:	ef 81       	ldd	r30, Y+7	; 0x07
    30f6:	f8 85       	ldd	r31, Y+8	; 0x08
    30f8:	93 83       	std	Z+3, r25	; 0x03
    30fa:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    30fc:	ef 81       	ldd	r30, Y+7	; 0x07
    30fe:	f8 85       	ldd	r31, Y+8	; 0x08
    3100:	02 80       	ldd	r0, Z+2	; 0x02
    3102:	f3 81       	ldd	r31, Z+3	; 0x03
    3104:	e0 2d       	mov	r30, r0
    3106:	8f 81       	ldd	r24, Y+7	; 0x07
    3108:	98 85       	ldd	r25, Y+8	; 0x08
    310a:	95 83       	std	Z+5, r25	; 0x05
    310c:	84 83       	std	Z+4, r24	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    310e:	ef 81       	ldd	r30, Y+7	; 0x07
    3110:	f8 85       	ldd	r31, Y+8	; 0x08
    3112:	8b 81       	ldd	r24, Y+3	; 0x03
    3114:	9c 81       	ldd	r25, Y+4	; 0x04
    3116:	95 83       	std	Z+5, r25	; 0x05
    3118:	84 83       	std	Z+4, r24	; 0x04
    pxIterator->pxNext = pxNewListItem;
    311a:	eb 81       	ldd	r30, Y+3	; 0x03
    311c:	fc 81       	ldd	r31, Y+4	; 0x04
    311e:	8f 81       	ldd	r24, Y+7	; 0x07
    3120:	98 85       	ldd	r25, Y+8	; 0x08
    3122:	93 83       	std	Z+3, r25	; 0x03
    3124:	82 83       	std	Z+2, r24	; 0x02

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    3126:	ef 81       	ldd	r30, Y+7	; 0x07
    3128:	f8 85       	ldd	r31, Y+8	; 0x08
    312a:	8d 81       	ldd	r24, Y+5	; 0x05
    312c:	9e 81       	ldd	r25, Y+6	; 0x06
    312e:	91 87       	std	Z+9, r25	; 0x09
    3130:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    3132:	ed 81       	ldd	r30, Y+5	; 0x05
    3134:	fe 81       	ldd	r31, Y+6	; 0x06
    3136:	80 81       	ld	r24, Z
    3138:	8f 5f       	subi	r24, 0xFF	; 255
    313a:	ed 81       	ldd	r30, Y+5	; 0x05
    313c:	fe 81       	ldd	r31, Y+6	; 0x06
    313e:	80 83       	st	Z, r24
}
    3140:	28 96       	adiw	r28, 0x08	; 8
    3142:	0f b6       	in	r0, 0x3f	; 63
    3144:	f8 94       	cli
    3146:	de bf       	out	0x3e, r29	; 62
    3148:	0f be       	out	0x3f, r0	; 63
    314a:	cd bf       	out	0x3d, r28	; 61
    314c:	cf 91       	pop	r28
    314e:	df 91       	pop	r29
    3150:	08 95       	ret

00003152 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    3152:	df 93       	push	r29
    3154:	cf 93       	push	r28
    3156:	00 d0       	rcall	.+0      	; 0x3158 <uxListRemove+0x6>
    3158:	00 d0       	rcall	.+0      	; 0x315a <uxListRemove+0x8>
    315a:	cd b7       	in	r28, 0x3d	; 61
    315c:	de b7       	in	r29, 0x3e	; 62
    315e:	9c 83       	std	Y+4, r25	; 0x04
    3160:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    3162:	eb 81       	ldd	r30, Y+3	; 0x03
    3164:	fc 81       	ldd	r31, Y+4	; 0x04
    3166:	80 85       	ldd	r24, Z+8	; 0x08
    3168:	91 85       	ldd	r25, Z+9	; 0x09
    316a:	9a 83       	std	Y+2, r25	; 0x02
    316c:	89 83       	std	Y+1, r24	; 0x01

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    316e:	eb 81       	ldd	r30, Y+3	; 0x03
    3170:	fc 81       	ldd	r31, Y+4	; 0x04
    3172:	a2 81       	ldd	r26, Z+2	; 0x02
    3174:	b3 81       	ldd	r27, Z+3	; 0x03
    3176:	eb 81       	ldd	r30, Y+3	; 0x03
    3178:	fc 81       	ldd	r31, Y+4	; 0x04
    317a:	84 81       	ldd	r24, Z+4	; 0x04
    317c:	95 81       	ldd	r25, Z+5	; 0x05
    317e:	15 96       	adiw	r26, 0x05	; 5
    3180:	9c 93       	st	X, r25
    3182:	8e 93       	st	-X, r24
    3184:	14 97       	sbiw	r26, 0x04	; 4
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    3186:	eb 81       	ldd	r30, Y+3	; 0x03
    3188:	fc 81       	ldd	r31, Y+4	; 0x04
    318a:	a4 81       	ldd	r26, Z+4	; 0x04
    318c:	b5 81       	ldd	r27, Z+5	; 0x05
    318e:	eb 81       	ldd	r30, Y+3	; 0x03
    3190:	fc 81       	ldd	r31, Y+4	; 0x04
    3192:	82 81       	ldd	r24, Z+2	; 0x02
    3194:	93 81       	ldd	r25, Z+3	; 0x03
    3196:	13 96       	adiw	r26, 0x03	; 3
    3198:	9c 93       	st	X, r25
    319a:	8e 93       	st	-X, r24
    319c:	12 97       	sbiw	r26, 0x02	; 2

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    319e:	e9 81       	ldd	r30, Y+1	; 0x01
    31a0:	fa 81       	ldd	r31, Y+2	; 0x02
    31a2:	21 81       	ldd	r18, Z+1	; 0x01
    31a4:	32 81       	ldd	r19, Z+2	; 0x02
    31a6:	8b 81       	ldd	r24, Y+3	; 0x03
    31a8:	9c 81       	ldd	r25, Y+4	; 0x04
    31aa:	28 17       	cp	r18, r24
    31ac:	39 07       	cpc	r19, r25
    31ae:	41 f4       	brne	.+16     	; 0x31c0 <uxListRemove+0x6e>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    31b0:	eb 81       	ldd	r30, Y+3	; 0x03
    31b2:	fc 81       	ldd	r31, Y+4	; 0x04
    31b4:	84 81       	ldd	r24, Z+4	; 0x04
    31b6:	95 81       	ldd	r25, Z+5	; 0x05
    31b8:	e9 81       	ldd	r30, Y+1	; 0x01
    31ba:	fa 81       	ldd	r31, Y+2	; 0x02
    31bc:	92 83       	std	Z+2, r25	; 0x02
    31be:	81 83       	std	Z+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    31c0:	eb 81       	ldd	r30, Y+3	; 0x03
    31c2:	fc 81       	ldd	r31, Y+4	; 0x04
    31c4:	11 86       	std	Z+9, r1	; 0x09
    31c6:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    31c8:	e9 81       	ldd	r30, Y+1	; 0x01
    31ca:	fa 81       	ldd	r31, Y+2	; 0x02
    31cc:	80 81       	ld	r24, Z
    31ce:	81 50       	subi	r24, 0x01	; 1
    31d0:	e9 81       	ldd	r30, Y+1	; 0x01
    31d2:	fa 81       	ldd	r31, Y+2	; 0x02
    31d4:	80 83       	st	Z, r24

    return pxList->uxNumberOfItems;
    31d6:	e9 81       	ldd	r30, Y+1	; 0x01
    31d8:	fa 81       	ldd	r31, Y+2	; 0x02
    31da:	80 81       	ld	r24, Z
}
    31dc:	0f 90       	pop	r0
    31de:	0f 90       	pop	r0
    31e0:	0f 90       	pop	r0
    31e2:	0f 90       	pop	r0
    31e4:	cf 91       	pop	r28
    31e6:	df 91       	pop	r29
    31e8:	08 95       	ret

000031ea <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    31ea:	df 93       	push	r29
    31ec:	cf 93       	push	r28
    31ee:	00 d0       	rcall	.+0      	; 0x31f0 <xQueueGenericReset+0x6>
    31f0:	00 d0       	rcall	.+0      	; 0x31f2 <xQueueGenericReset+0x8>
    31f2:	00 d0       	rcall	.+0      	; 0x31f4 <xQueueGenericReset+0xa>
    31f4:	cd b7       	in	r28, 0x3d	; 61
    31f6:	de b7       	in	r29, 0x3e	; 62
    31f8:	9d 83       	std	Y+5, r25	; 0x05
    31fa:	8c 83       	std	Y+4, r24	; 0x04
    31fc:	6e 83       	std	Y+6, r22	; 0x06
    BaseType_t xReturn = pdPASS;
    31fe:	81 e0       	ldi	r24, 0x01	; 1
    3200:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    3202:	8c 81       	ldd	r24, Y+4	; 0x04
    3204:	9d 81       	ldd	r25, Y+5	; 0x05
    3206:	9a 83       	std	Y+2, r25	; 0x02
    3208:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    320a:	89 81       	ldd	r24, Y+1	; 0x01
    320c:	9a 81       	ldd	r25, Y+2	; 0x02
    320e:	00 97       	sbiw	r24, 0x00	; 0
    3210:	09 f4       	brne	.+2      	; 0x3214 <xQueueGenericReset+0x2a>
    3212:	8b c0       	rjmp	.+278    	; 0x332a <xQueueGenericReset+0x140>
    3214:	e9 81       	ldd	r30, Y+1	; 0x01
    3216:	fa 81       	ldd	r31, Y+2	; 0x02
    3218:	83 8d       	ldd	r24, Z+27	; 0x1b
    321a:	88 23       	and	r24, r24
    321c:	09 f4       	brne	.+2      	; 0x3220 <xQueueGenericReset+0x36>
    321e:	85 c0       	rjmp	.+266    	; 0x332a <xQueueGenericReset+0x140>
    3220:	e9 81       	ldd	r30, Y+1	; 0x01
    3222:	fa 81       	ldd	r31, Y+2	; 0x02
    3224:	83 8d       	ldd	r24, Z+27	; 0x1b
    3226:	28 2f       	mov	r18, r24
    3228:	30 e0       	ldi	r19, 0x00	; 0
    322a:	8f ef       	ldi	r24, 0xFF	; 255
    322c:	9f e7       	ldi	r25, 0x7F	; 127
    322e:	b9 01       	movw	r22, r18
    3230:	0e 94 97 3b 	call	0x772e	; 0x772e <__udivmodhi4>
    3234:	cb 01       	movw	r24, r22
    3236:	9c 01       	movw	r18, r24
    3238:	e9 81       	ldd	r30, Y+1	; 0x01
    323a:	fa 81       	ldd	r31, Y+2	; 0x02
    323c:	84 8d       	ldd	r24, Z+28	; 0x1c
    323e:	88 2f       	mov	r24, r24
    3240:	90 e0       	ldi	r25, 0x00	; 0
    3242:	28 17       	cp	r18, r24
    3244:	39 07       	cpc	r19, r25
    3246:	08 f4       	brcc	.+2      	; 0x324a <xQueueGenericReset+0x60>
    3248:	70 c0       	rjmp	.+224    	; 0x332a <xQueueGenericReset+0x140>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    324a:	0f b6       	in	r0, 0x3f	; 63
    324c:	f8 94       	cli
    324e:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    3250:	e9 81       	ldd	r30, Y+1	; 0x01
    3252:	fa 81       	ldd	r31, Y+2	; 0x02
    3254:	40 81       	ld	r20, Z
    3256:	51 81       	ldd	r21, Z+1	; 0x01
    3258:	e9 81       	ldd	r30, Y+1	; 0x01
    325a:	fa 81       	ldd	r31, Y+2	; 0x02
    325c:	83 8d       	ldd	r24, Z+27	; 0x1b
    325e:	28 2f       	mov	r18, r24
    3260:	30 e0       	ldi	r19, 0x00	; 0
    3262:	e9 81       	ldd	r30, Y+1	; 0x01
    3264:	fa 81       	ldd	r31, Y+2	; 0x02
    3266:	84 8d       	ldd	r24, Z+28	; 0x1c
    3268:	88 2f       	mov	r24, r24
    326a:	90 e0       	ldi	r25, 0x00	; 0
    326c:	bc 01       	movw	r22, r24
    326e:	26 9f       	mul	r18, r22
    3270:	c0 01       	movw	r24, r0
    3272:	27 9f       	mul	r18, r23
    3274:	90 0d       	add	r25, r0
    3276:	36 9f       	mul	r19, r22
    3278:	90 0d       	add	r25, r0
    327a:	11 24       	eor	r1, r1
    327c:	84 0f       	add	r24, r20
    327e:	95 1f       	adc	r25, r21
    3280:	e9 81       	ldd	r30, Y+1	; 0x01
    3282:	fa 81       	ldd	r31, Y+2	; 0x02
    3284:	95 83       	std	Z+5, r25	; 0x05
    3286:	84 83       	std	Z+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    3288:	e9 81       	ldd	r30, Y+1	; 0x01
    328a:	fa 81       	ldd	r31, Y+2	; 0x02
    328c:	12 8e       	std	Z+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    328e:	e9 81       	ldd	r30, Y+1	; 0x01
    3290:	fa 81       	ldd	r31, Y+2	; 0x02
    3292:	80 81       	ld	r24, Z
    3294:	91 81       	ldd	r25, Z+1	; 0x01
    3296:	e9 81       	ldd	r30, Y+1	; 0x01
    3298:	fa 81       	ldd	r31, Y+2	; 0x02
    329a:	93 83       	std	Z+3, r25	; 0x03
    329c:	82 83       	std	Z+2, r24	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    329e:	e9 81       	ldd	r30, Y+1	; 0x01
    32a0:	fa 81       	ldd	r31, Y+2	; 0x02
    32a2:	40 81       	ld	r20, Z
    32a4:	51 81       	ldd	r21, Z+1	; 0x01
    32a6:	e9 81       	ldd	r30, Y+1	; 0x01
    32a8:	fa 81       	ldd	r31, Y+2	; 0x02
    32aa:	83 8d       	ldd	r24, Z+27	; 0x1b
    32ac:	88 2f       	mov	r24, r24
    32ae:	90 e0       	ldi	r25, 0x00	; 0
    32b0:	9c 01       	movw	r18, r24
    32b2:	21 50       	subi	r18, 0x01	; 1
    32b4:	30 40       	sbci	r19, 0x00	; 0
    32b6:	e9 81       	ldd	r30, Y+1	; 0x01
    32b8:	fa 81       	ldd	r31, Y+2	; 0x02
    32ba:	84 8d       	ldd	r24, Z+28	; 0x1c
    32bc:	88 2f       	mov	r24, r24
    32be:	90 e0       	ldi	r25, 0x00	; 0
    32c0:	bc 01       	movw	r22, r24
    32c2:	26 9f       	mul	r18, r22
    32c4:	c0 01       	movw	r24, r0
    32c6:	27 9f       	mul	r18, r23
    32c8:	90 0d       	add	r25, r0
    32ca:	36 9f       	mul	r19, r22
    32cc:	90 0d       	add	r25, r0
    32ce:	11 24       	eor	r1, r1
    32d0:	84 0f       	add	r24, r20
    32d2:	95 1f       	adc	r25, r21
    32d4:	e9 81       	ldd	r30, Y+1	; 0x01
    32d6:	fa 81       	ldd	r31, Y+2	; 0x02
    32d8:	97 83       	std	Z+7, r25	; 0x07
    32da:	86 83       	std	Z+6, r24	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    32dc:	e9 81       	ldd	r30, Y+1	; 0x01
    32de:	fa 81       	ldd	r31, Y+2	; 0x02
    32e0:	8f ef       	ldi	r24, 0xFF	; 255
    32e2:	85 8f       	std	Z+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    32e4:	e9 81       	ldd	r30, Y+1	; 0x01
    32e6:	fa 81       	ldd	r31, Y+2	; 0x02
    32e8:	8f ef       	ldi	r24, 0xFF	; 255
    32ea:	86 8f       	std	Z+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    32ec:	8e 81       	ldd	r24, Y+6	; 0x06
    32ee:	88 23       	and	r24, r24
    32f0:	79 f4       	brne	.+30     	; 0x3310 <xQueueGenericReset+0x126>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    32f2:	e9 81       	ldd	r30, Y+1	; 0x01
    32f4:	fa 81       	ldd	r31, Y+2	; 0x02
    32f6:	80 85       	ldd	r24, Z+8	; 0x08
    32f8:	88 23       	and	r24, r24
    32fa:	a1 f0       	breq	.+40     	; 0x3324 <xQueueGenericReset+0x13a>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    32fc:	89 81       	ldd	r24, Y+1	; 0x01
    32fe:	9a 81       	ldd	r25, Y+2	; 0x02
    3300:	08 96       	adiw	r24, 0x08	; 8
    3302:	0e 94 62 2a 	call	0x54c4	; 0x54c4 <xTaskRemoveFromEventList>
    3306:	88 23       	and	r24, r24
    3308:	69 f0       	breq	.+26     	; 0x3324 <xQueueGenericReset+0x13a>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    330a:	0e 94 86 10 	call	0x210c	; 0x210c <vPortYield>
    330e:	0a c0       	rjmp	.+20     	; 0x3324 <xQueueGenericReset+0x13a>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    3310:	89 81       	ldd	r24, Y+1	; 0x01
    3312:	9a 81       	ldd	r25, Y+2	; 0x02
    3314:	08 96       	adiw	r24, 0x08	; 8
    3316:	0e 94 bf 17 	call	0x2f7e	; 0x2f7e <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    331a:	89 81       	ldd	r24, Y+1	; 0x01
    331c:	9a 81       	ldd	r25, Y+2	; 0x02
    331e:	41 96       	adiw	r24, 0x11	; 17
    3320:	0e 94 bf 17 	call	0x2f7e	; 0x2f7e <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    3324:	0f 90       	pop	r0
    3326:	0f be       	out	0x3f, r0	; 63
    3328:	01 c0       	rjmp	.+2      	; 0x332c <xQueueGenericReset+0x142>
    }
    else
    {
        xReturn = pdFAIL;
    332a:	1b 82       	std	Y+3, r1	; 0x03

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
    332c:	8b 81       	ldd	r24, Y+3	; 0x03
}
    332e:	26 96       	adiw	r28, 0x06	; 6
    3330:	0f b6       	in	r0, 0x3f	; 63
    3332:	f8 94       	cli
    3334:	de bf       	out	0x3e, r29	; 62
    3336:	0f be       	out	0x3f, r0	; 63
    3338:	cd bf       	out	0x3d, r28	; 61
    333a:	cf 91       	pop	r28
    333c:	df 91       	pop	r29
    333e:	08 95       	ret

00003340 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    3340:	0f 93       	push	r16
    3342:	1f 93       	push	r17
    3344:	df 93       	push	r29
    3346:	cf 93       	push	r28
    3348:	cd b7       	in	r28, 0x3d	; 61
    334a:	de b7       	in	r29, 0x3e	; 62
    334c:	29 97       	sbiw	r28, 0x09	; 9
    334e:	0f b6       	in	r0, 0x3f	; 63
    3350:	f8 94       	cli
    3352:	de bf       	out	0x3e, r29	; 62
    3354:	0f be       	out	0x3f, r0	; 63
    3356:	cd bf       	out	0x3d, r28	; 61
    3358:	8f 83       	std	Y+7, r24	; 0x07
    335a:	68 87       	std	Y+8, r22	; 0x08
    335c:	49 87       	std	Y+9, r20	; 0x09
        Queue_t * pxNewQueue = NULL;
    335e:	1e 82       	std	Y+6, r1	; 0x06
    3360:	1d 82       	std	Y+5, r1	; 0x05
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    3362:	8f 81       	ldd	r24, Y+7	; 0x07
    3364:	88 23       	and	r24, r24
    3366:	09 f4       	brne	.+2      	; 0x336a <xQueueGenericCreate+0x2a>
    3368:	52 c0       	rjmp	.+164    	; 0x340e <xQueueGenericCreate+0xce>
    336a:	8f 81       	ldd	r24, Y+7	; 0x07
    336c:	28 2f       	mov	r18, r24
    336e:	30 e0       	ldi	r19, 0x00	; 0
    3370:	8f ef       	ldi	r24, 0xFF	; 255
    3372:	9f e7       	ldi	r25, 0x7F	; 127
    3374:	b9 01       	movw	r22, r18
    3376:	0e 94 97 3b 	call	0x772e	; 0x772e <__udivmodhi4>
    337a:	cb 01       	movw	r24, r22
    337c:	9c 01       	movw	r18, r24
    337e:	88 85       	ldd	r24, Y+8	; 0x08
    3380:	88 2f       	mov	r24, r24
    3382:	90 e0       	ldi	r25, 0x00	; 0
    3384:	28 17       	cp	r18, r24
    3386:	39 07       	cpc	r19, r25
    3388:	08 f4       	brcc	.+2      	; 0x338c <xQueueGenericCreate+0x4c>
    338a:	41 c0       	rjmp	.+130    	; 0x340e <xQueueGenericCreate+0xce>
    338c:	8f 81       	ldd	r24, Y+7	; 0x07
    338e:	28 2f       	mov	r18, r24
    3390:	30 e0       	ldi	r19, 0x00	; 0
    3392:	88 85       	ldd	r24, Y+8	; 0x08
    3394:	88 2f       	mov	r24, r24
    3396:	90 e0       	ldi	r25, 0x00	; 0
    3398:	ac 01       	movw	r20, r24
    339a:	24 9f       	mul	r18, r20
    339c:	c0 01       	movw	r24, r0
    339e:	25 9f       	mul	r18, r21
    33a0:	90 0d       	add	r25, r0
    33a2:	34 9f       	mul	r19, r20
    33a4:	90 0d       	add	r25, r0
    33a6:	11 24       	eor	r1, r1
    33a8:	5f e7       	ldi	r21, 0x7F	; 127
    33aa:	81 3e       	cpi	r24, 0xE1	; 225
    33ac:	95 07       	cpc	r25, r21
    33ae:	78 f5       	brcc	.+94     	; 0x340e <xQueueGenericCreate+0xce>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    33b0:	8f 81       	ldd	r24, Y+7	; 0x07
    33b2:	28 2f       	mov	r18, r24
    33b4:	30 e0       	ldi	r19, 0x00	; 0
    33b6:	88 85       	ldd	r24, Y+8	; 0x08
    33b8:	88 2f       	mov	r24, r24
    33ba:	90 e0       	ldi	r25, 0x00	; 0
    33bc:	ac 01       	movw	r20, r24
    33be:	24 9f       	mul	r18, r20
    33c0:	c0 01       	movw	r24, r0
    33c2:	25 9f       	mul	r18, r21
    33c4:	90 0d       	add	r25, r0
    33c6:	34 9f       	mul	r19, r20
    33c8:	90 0d       	add	r25, r0
    33ca:	11 24       	eor	r1, r1
    33cc:	9c 83       	std	Y+4, r25	; 0x04
    33ce:	8b 83       	std	Y+3, r24	; 0x03
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    33d0:	8b 81       	ldd	r24, Y+3	; 0x03
    33d2:	9c 81       	ldd	r25, Y+4	; 0x04
    33d4:	4f 96       	adiw	r24, 0x1f	; 31
    33d6:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <pvPortMalloc>
    33da:	9e 83       	std	Y+6, r25	; 0x06
    33dc:	8d 83       	std	Y+5, r24	; 0x05

            if( pxNewQueue != NULL )
    33de:	8d 81       	ldd	r24, Y+5	; 0x05
    33e0:	9e 81       	ldd	r25, Y+6	; 0x06
    33e2:	00 97       	sbiw	r24, 0x00	; 0
    33e4:	a1 f0       	breq	.+40     	; 0x340e <xQueueGenericCreate+0xce>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
    33e6:	8d 81       	ldd	r24, Y+5	; 0x05
    33e8:	9e 81       	ldd	r25, Y+6	; 0x06
    33ea:	9a 83       	std	Y+2, r25	; 0x02
    33ec:	89 83       	std	Y+1, r24	; 0x01
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    33ee:	89 81       	ldd	r24, Y+1	; 0x01
    33f0:	9a 81       	ldd	r25, Y+2	; 0x02
    33f2:	4f 96       	adiw	r24, 0x1f	; 31
    33f4:	9a 83       	std	Y+2, r25	; 0x02
    33f6:	89 83       	std	Y+1, r24	; 0x01
                         * deleted. */
                        pxNewQueue->ucStaticallyAllocated = pdFALSE;
                    }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    33f8:	29 81       	ldd	r18, Y+1	; 0x01
    33fa:	3a 81       	ldd	r19, Y+2	; 0x02
    33fc:	ed 81       	ldd	r30, Y+5	; 0x05
    33fe:	fe 81       	ldd	r31, Y+6	; 0x06
    3400:	8f 81       	ldd	r24, Y+7	; 0x07
    3402:	68 85       	ldd	r22, Y+8	; 0x08
    3404:	a9 01       	movw	r20, r18
    3406:	29 85       	ldd	r18, Y+9	; 0x09
    3408:	8f 01       	movw	r16, r30
    340a:	0e 94 14 1a 	call	0x3428	; 0x3428 <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    340e:	8d 81       	ldd	r24, Y+5	; 0x05
    3410:	9e 81       	ldd	r25, Y+6	; 0x06
    }
    3412:	29 96       	adiw	r28, 0x09	; 9
    3414:	0f b6       	in	r0, 0x3f	; 63
    3416:	f8 94       	cli
    3418:	de bf       	out	0x3e, r29	; 62
    341a:	0f be       	out	0x3f, r0	; 63
    341c:	cd bf       	out	0x3d, r28	; 61
    341e:	cf 91       	pop	r28
    3420:	df 91       	pop	r29
    3422:	1f 91       	pop	r17
    3424:	0f 91       	pop	r16
    3426:	08 95       	ret

00003428 <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    3428:	0f 93       	push	r16
    342a:	1f 93       	push	r17
    342c:	df 93       	push	r29
    342e:	cf 93       	push	r28
    3430:	cd b7       	in	r28, 0x3d	; 61
    3432:	de b7       	in	r29, 0x3e	; 62
    3434:	27 97       	sbiw	r28, 0x07	; 7
    3436:	0f b6       	in	r0, 0x3f	; 63
    3438:	f8 94       	cli
    343a:	de bf       	out	0x3e, r29	; 62
    343c:	0f be       	out	0x3f, r0	; 63
    343e:	cd bf       	out	0x3d, r28	; 61
    3440:	89 83       	std	Y+1, r24	; 0x01
    3442:	6a 83       	std	Y+2, r22	; 0x02
    3444:	5c 83       	std	Y+4, r21	; 0x04
    3446:	4b 83       	std	Y+3, r20	; 0x03
    3448:	2d 83       	std	Y+5, r18	; 0x05
    344a:	1f 83       	std	Y+7, r17	; 0x07
    344c:	0e 83       	std	Y+6, r16	; 0x06
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    344e:	8a 81       	ldd	r24, Y+2	; 0x02
    3450:	88 23       	and	r24, r24
    3452:	39 f4       	brne	.+14     	; 0x3462 <prvInitialiseNewQueue+0x3a>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    3454:	8e 81       	ldd	r24, Y+6	; 0x06
    3456:	9f 81       	ldd	r25, Y+7	; 0x07
    3458:	ee 81       	ldd	r30, Y+6	; 0x06
    345a:	ff 81       	ldd	r31, Y+7	; 0x07
    345c:	91 83       	std	Z+1, r25	; 0x01
    345e:	80 83       	st	Z, r24
    3460:	06 c0       	rjmp	.+12     	; 0x346e <prvInitialiseNewQueue+0x46>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    3462:	8b 81       	ldd	r24, Y+3	; 0x03
    3464:	9c 81       	ldd	r25, Y+4	; 0x04
    3466:	ee 81       	ldd	r30, Y+6	; 0x06
    3468:	ff 81       	ldd	r31, Y+7	; 0x07
    346a:	91 83       	std	Z+1, r25	; 0x01
    346c:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    346e:	ee 81       	ldd	r30, Y+6	; 0x06
    3470:	ff 81       	ldd	r31, Y+7	; 0x07
    3472:	89 81       	ldd	r24, Y+1	; 0x01
    3474:	83 8f       	std	Z+27, r24	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    3476:	ee 81       	ldd	r30, Y+6	; 0x06
    3478:	ff 81       	ldd	r31, Y+7	; 0x07
    347a:	8a 81       	ldd	r24, Y+2	; 0x02
    347c:	84 8f       	std	Z+28, r24	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    347e:	8e 81       	ldd	r24, Y+6	; 0x06
    3480:	9f 81       	ldd	r25, Y+7	; 0x07
    3482:	61 e0       	ldi	r22, 0x01	; 1
    3484:	0e 94 f5 18 	call	0x31ea	; 0x31ea <xQueueGenericReset>
            pxNewQueue->pxQueueSetContainer = NULL;
        }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    3488:	27 96       	adiw	r28, 0x07	; 7
    348a:	0f b6       	in	r0, 0x3f	; 63
    348c:	f8 94       	cli
    348e:	de bf       	out	0x3e, r29	; 62
    3490:	0f be       	out	0x3f, r0	; 63
    3492:	cd bf       	out	0x3d, r28	; 61
    3494:	cf 91       	pop	r28
    3496:	df 91       	pop	r29
    3498:	1f 91       	pop	r17
    349a:	0f 91       	pop	r16
    349c:	08 95       	ret

0000349e <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    349e:	df 93       	push	r29
    34a0:	cf 93       	push	r28
    34a2:	cd b7       	in	r28, 0x3d	; 61
    34a4:	de b7       	in	r29, 0x3e	; 62
    34a6:	2f 97       	sbiw	r28, 0x0f	; 15
    34a8:	0f b6       	in	r0, 0x3f	; 63
    34aa:	f8 94       	cli
    34ac:	de bf       	out	0x3e, r29	; 62
    34ae:	0f be       	out	0x3f, r0	; 63
    34b0:	cd bf       	out	0x3d, r28	; 61
    34b2:	99 87       	std	Y+9, r25	; 0x09
    34b4:	88 87       	std	Y+8, r24	; 0x08
    34b6:	7b 87       	std	Y+11, r23	; 0x0b
    34b8:	6a 87       	std	Y+10, r22	; 0x0a
    34ba:	5d 87       	std	Y+13, r21	; 0x0d
    34bc:	4c 87       	std	Y+12, r20	; 0x0c
    34be:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    34c0:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    34c2:	88 85       	ldd	r24, Y+8	; 0x08
    34c4:	99 85       	ldd	r25, Y+9	; 0x09
    34c6:	9a 83       	std	Y+2, r25	; 0x02
    34c8:	89 83       	std	Y+1, r24	; 0x01
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    34ca:	0f b6       	in	r0, 0x3f	; 63
    34cc:	f8 94       	cli
    34ce:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    34d0:	e9 81       	ldd	r30, Y+1	; 0x01
    34d2:	fa 81       	ldd	r31, Y+2	; 0x02
    34d4:	92 8d       	ldd	r25, Z+26	; 0x1a
    34d6:	e9 81       	ldd	r30, Y+1	; 0x01
    34d8:	fa 81       	ldd	r31, Y+2	; 0x02
    34da:	83 8d       	ldd	r24, Z+27	; 0x1b
    34dc:	98 17       	cp	r25, r24
    34de:	18 f0       	brcs	.+6      	; 0x34e6 <xQueueGenericSend+0x48>
    34e0:	8e 85       	ldd	r24, Y+14	; 0x0e
    34e2:	82 30       	cpi	r24, 0x02	; 2
    34e4:	11 f5       	brne	.+68     	; 0x352a <xQueueGenericSend+0x8c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    34e6:	89 81       	ldd	r24, Y+1	; 0x01
    34e8:	9a 81       	ldd	r25, Y+2	; 0x02
    34ea:	2a 85       	ldd	r18, Y+10	; 0x0a
    34ec:	3b 85       	ldd	r19, Y+11	; 0x0b
    34ee:	b9 01       	movw	r22, r18
    34f0:	4e 85       	ldd	r20, Y+14	; 0x0e
    34f2:	0e 94 a5 1e 	call	0x3d4a	; 0x3d4a <prvCopyDataToQueue>
    34f6:	8b 83       	std	Y+3, r24	; 0x03

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    34f8:	e9 81       	ldd	r30, Y+1	; 0x01
    34fa:	fa 81       	ldd	r31, Y+2	; 0x02
    34fc:	81 89       	ldd	r24, Z+17	; 0x11
    34fe:	88 23       	and	r24, r24
    3500:	51 f0       	breq	.+20     	; 0x3516 <xQueueGenericSend+0x78>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3502:	89 81       	ldd	r24, Y+1	; 0x01
    3504:	9a 81       	ldd	r25, Y+2	; 0x02
    3506:	41 96       	adiw	r24, 0x11	; 17
    3508:	0e 94 62 2a 	call	0x54c4	; 0x54c4 <xTaskRemoveFromEventList>
    350c:	88 23       	and	r24, r24
    350e:	41 f0       	breq	.+16     	; 0x3520 <xQueueGenericSend+0x82>
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
    3510:	0e 94 86 10 	call	0x210c	; 0x210c <vPortYield>
    3514:	05 c0       	rjmp	.+10     	; 0x3520 <xQueueGenericSend+0x82>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
    3516:	8b 81       	ldd	r24, Y+3	; 0x03
    3518:	88 23       	and	r24, r24
    351a:	11 f0       	breq	.+4      	; 0x3520 <xQueueGenericSend+0x82>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
    351c:	0e 94 86 10 	call	0x210c	; 0x210c <vPortYield>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    3520:	0f 90       	pop	r0
    3522:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    3524:	81 e0       	ldi	r24, 0x01	; 1
    3526:	8f 87       	std	Y+15, r24	; 0x0f
    3528:	5c c0       	rjmp	.+184    	; 0x35e2 <xQueueGenericSend+0x144>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    352a:	8c 85       	ldd	r24, Y+12	; 0x0c
    352c:	9d 85       	ldd	r25, Y+13	; 0x0d
    352e:	00 97       	sbiw	r24, 0x00	; 0
    3530:	21 f4       	brne	.+8      	; 0x353a <xQueueGenericSend+0x9c>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    3532:	0f 90       	pop	r0
    3534:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    3536:	1f 86       	std	Y+15, r1	; 0x0f
    3538:	54 c0       	rjmp	.+168    	; 0x35e2 <xQueueGenericSend+0x144>
                }
                else if( xEntryTimeSet == pdFALSE )
    353a:	8c 81       	ldd	r24, Y+4	; 0x04
    353c:	88 23       	and	r24, r24
    353e:	31 f4       	brne	.+12     	; 0x354c <xQueueGenericSend+0xae>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3540:	ce 01       	movw	r24, r28
    3542:	05 96       	adiw	r24, 0x05	; 5
    3544:	0e 94 d2 2c 	call	0x59a4	; 0x59a4 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    3548:	81 e0       	ldi	r24, 0x01	; 1
    354a:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    354c:	0f 90       	pop	r0
    354e:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    3550:	0e 94 9c 25 	call	0x4b38	; 0x4b38 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    3554:	0f b6       	in	r0, 0x3f	; 63
    3556:	f8 94       	cli
    3558:	0f 92       	push	r0
    355a:	e9 81       	ldd	r30, Y+1	; 0x01
    355c:	fa 81       	ldd	r31, Y+2	; 0x02
    355e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3560:	8f 3f       	cpi	r24, 0xFF	; 255
    3562:	19 f4       	brne	.+6      	; 0x356a <xQueueGenericSend+0xcc>
    3564:	e9 81       	ldd	r30, Y+1	; 0x01
    3566:	fa 81       	ldd	r31, Y+2	; 0x02
    3568:	15 8e       	std	Z+29, r1	; 0x1d
    356a:	e9 81       	ldd	r30, Y+1	; 0x01
    356c:	fa 81       	ldd	r31, Y+2	; 0x02
    356e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3570:	8f 3f       	cpi	r24, 0xFF	; 255
    3572:	19 f4       	brne	.+6      	; 0x357a <xQueueGenericSend+0xdc>
    3574:	e9 81       	ldd	r30, Y+1	; 0x01
    3576:	fa 81       	ldd	r31, Y+2	; 0x02
    3578:	16 8e       	std	Z+30, r1	; 0x1e
    357a:	0f 90       	pop	r0
    357c:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    357e:	ce 01       	movw	r24, r28
    3580:	05 96       	adiw	r24, 0x05	; 5
    3582:	9e 01       	movw	r18, r28
    3584:	24 5f       	subi	r18, 0xF4	; 244
    3586:	3f 4f       	sbci	r19, 0xFF	; 255
    3588:	b9 01       	movw	r22, r18
    358a:	0e 94 eb 2c 	call	0x59d6	; 0x59d6 <xTaskCheckForTimeOut>
    358e:	88 23       	and	r24, r24
    3590:	09 f5       	brne	.+66     	; 0x35d4 <xQueueGenericSend+0x136>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3592:	89 81       	ldd	r24, Y+1	; 0x01
    3594:	9a 81       	ldd	r25, Y+2	; 0x02
    3596:	0e 94 21 20 	call	0x4042	; 0x4042 <prvIsQueueFull>
    359a:	88 23       	and	r24, r24
    359c:	a1 f0       	breq	.+40     	; 0x35c6 <xQueueGenericSend+0x128>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    359e:	89 81       	ldd	r24, Y+1	; 0x01
    35a0:	9a 81       	ldd	r25, Y+2	; 0x02
    35a2:	08 96       	adiw	r24, 0x08	; 8
    35a4:	2c 85       	ldd	r18, Y+12	; 0x0c
    35a6:	3d 85       	ldd	r19, Y+13	; 0x0d
    35a8:	b9 01       	movw	r22, r18
    35aa:	0e 94 79 29 	call	0x52f2	; 0x52f2 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    35ae:	89 81       	ldd	r24, Y+1	; 0x01
    35b0:	9a 81       	ldd	r25, Y+2	; 0x02
    35b2:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    35b6:	0e 94 a8 25 	call	0x4b50	; 0x4b50 <xTaskResumeAll>
    35ba:	88 23       	and	r24, r24
    35bc:	09 f0       	breq	.+2      	; 0x35c0 <xQueueGenericSend+0x122>
    35be:	85 cf       	rjmp	.-246    	; 0x34ca <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
    35c0:	0e 94 86 10 	call	0x210c	; 0x210c <vPortYield>
    35c4:	82 cf       	rjmp	.-252    	; 0x34ca <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    35c6:	89 81       	ldd	r24, Y+1	; 0x01
    35c8:	9a 81       	ldd	r25, Y+2	; 0x02
    35ca:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    35ce:	0e 94 a8 25 	call	0x4b50	; 0x4b50 <xTaskResumeAll>
    35d2:	7b cf       	rjmp	.-266    	; 0x34ca <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    35d4:	89 81       	ldd	r24, Y+1	; 0x01
    35d6:	9a 81       	ldd	r25, Y+2	; 0x02
    35d8:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    35dc:	0e 94 a8 25 	call	0x4b50	; 0x4b50 <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    35e0:	1f 86       	std	Y+15, r1	; 0x0f
    35e2:	8f 85       	ldd	r24, Y+15	; 0x0f
        }
    } /*lint -restore */
}
    35e4:	2f 96       	adiw	r28, 0x0f	; 15
    35e6:	0f b6       	in	r0, 0x3f	; 63
    35e8:	f8 94       	cli
    35ea:	de bf       	out	0x3e, r29	; 62
    35ec:	0f be       	out	0x3f, r0	; 63
    35ee:	cd bf       	out	0x3d, r28	; 61
    35f0:	cf 91       	pop	r28
    35f2:	df 91       	pop	r29
    35f4:	08 95       	ret

000035f6 <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    35f6:	df 93       	push	r29
    35f8:	cf 93       	push	r28
    35fa:	cd b7       	in	r28, 0x3d	; 61
    35fc:	de b7       	in	r29, 0x3e	; 62
    35fe:	2d 97       	sbiw	r28, 0x0d	; 13
    3600:	0f b6       	in	r0, 0x3f	; 63
    3602:	f8 94       	cli
    3604:	de bf       	out	0x3e, r29	; 62
    3606:	0f be       	out	0x3f, r0	; 63
    3608:	cd bf       	out	0x3d, r28	; 61
    360a:	98 87       	std	Y+8, r25	; 0x08
    360c:	8f 83       	std	Y+7, r24	; 0x07
    360e:	7a 87       	std	Y+10, r23	; 0x0a
    3610:	69 87       	std	Y+9, r22	; 0x09
    3612:	5c 87       	std	Y+12, r21	; 0x0c
    3614:	4b 87       	std	Y+11, r20	; 0x0b
    3616:	2d 87       	std	Y+13, r18	; 0x0d
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    3618:	8f 81       	ldd	r24, Y+7	; 0x07
    361a:	98 85       	ldd	r25, Y+8	; 0x08
    361c:	9c 83       	std	Y+4, r25	; 0x04
    361e:	8b 83       	std	Y+3, r24	; 0x03
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3620:	1d 82       	std	Y+5, r1	; 0x05
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3622:	eb 81       	ldd	r30, Y+3	; 0x03
    3624:	fc 81       	ldd	r31, Y+4	; 0x04
    3626:	92 8d       	ldd	r25, Z+26	; 0x1a
    3628:	eb 81       	ldd	r30, Y+3	; 0x03
    362a:	fc 81       	ldd	r31, Y+4	; 0x04
    362c:	83 8d       	ldd	r24, Z+27	; 0x1b
    362e:	98 17       	cp	r25, r24
    3630:	18 f0       	brcs	.+6      	; 0x3638 <xQueueGenericSendFromISR+0x42>
    3632:	8d 85       	ldd	r24, Y+13	; 0x0d
    3634:	82 30       	cpi	r24, 0x02	; 2
    3636:	81 f5       	brne	.+96     	; 0x3698 <xQueueGenericSendFromISR+0xa2>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    3638:	eb 81       	ldd	r30, Y+3	; 0x03
    363a:	fc 81       	ldd	r31, Y+4	; 0x04
    363c:	86 8d       	ldd	r24, Z+30	; 0x1e
    363e:	8a 83       	std	Y+2, r24	; 0x02
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    3640:	eb 81       	ldd	r30, Y+3	; 0x03
    3642:	fc 81       	ldd	r31, Y+4	; 0x04
    3644:	82 8d       	ldd	r24, Z+26	; 0x1a
    3646:	89 83       	std	Y+1, r24	; 0x01
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3648:	8b 81       	ldd	r24, Y+3	; 0x03
    364a:	9c 81       	ldd	r25, Y+4	; 0x04
    364c:	29 85       	ldd	r18, Y+9	; 0x09
    364e:	3a 85       	ldd	r19, Y+10	; 0x0a
    3650:	b9 01       	movw	r22, r18
    3652:	4d 85       	ldd	r20, Y+13	; 0x0d
    3654:	0e 94 a5 1e 	call	0x3d4a	; 0x3d4a <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    3658:	8a 81       	ldd	r24, Y+2	; 0x02
    365a:	8f 3f       	cpi	r24, 0xFF	; 255
    365c:	a9 f4       	brne	.+42     	; 0x3688 <xQueueGenericSendFromISR+0x92>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    365e:	eb 81       	ldd	r30, Y+3	; 0x03
    3660:	fc 81       	ldd	r31, Y+4	; 0x04
    3662:	81 89       	ldd	r24, Z+17	; 0x11
    3664:	88 23       	and	r24, r24
    3666:	a9 f0       	breq	.+42     	; 0x3692 <xQueueGenericSendFromISR+0x9c>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3668:	8b 81       	ldd	r24, Y+3	; 0x03
    366a:	9c 81       	ldd	r25, Y+4	; 0x04
    366c:	41 96       	adiw	r24, 0x11	; 17
    366e:	0e 94 62 2a 	call	0x54c4	; 0x54c4 <xTaskRemoveFromEventList>
    3672:	88 23       	and	r24, r24
    3674:	71 f0       	breq	.+28     	; 0x3692 <xQueueGenericSendFromISR+0x9c>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    3676:	8b 85       	ldd	r24, Y+11	; 0x0b
    3678:	9c 85       	ldd	r25, Y+12	; 0x0c
    367a:	00 97       	sbiw	r24, 0x00	; 0
    367c:	51 f0       	breq	.+20     	; 0x3692 <xQueueGenericSendFromISR+0x9c>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    367e:	eb 85       	ldd	r30, Y+11	; 0x0b
    3680:	fc 85       	ldd	r31, Y+12	; 0x0c
    3682:	81 e0       	ldi	r24, 0x01	; 1
    3684:	80 83       	st	Z, r24
    3686:	05 c0       	rjmp	.+10     	; 0x3692 <xQueueGenericSendFromISR+0x9c>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    3688:	8a 81       	ldd	r24, Y+2	; 0x02
    368a:	8f 5f       	subi	r24, 0xFF	; 255
    368c:	eb 81       	ldd	r30, Y+3	; 0x03
    368e:	fc 81       	ldd	r31, Y+4	; 0x04
    3690:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    3692:	81 e0       	ldi	r24, 0x01	; 1
    3694:	8e 83       	std	Y+6, r24	; 0x06
    3696:	01 c0       	rjmp	.+2      	; 0x369a <xQueueGenericSendFromISR+0xa4>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    3698:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    369a:	8e 81       	ldd	r24, Y+6	; 0x06
}
    369c:	2d 96       	adiw	r28, 0x0d	; 13
    369e:	0f b6       	in	r0, 0x3f	; 63
    36a0:	f8 94       	cli
    36a2:	de bf       	out	0x3e, r29	; 62
    36a4:	0f be       	out	0x3f, r0	; 63
    36a6:	cd bf       	out	0x3d, r28	; 61
    36a8:	cf 91       	pop	r28
    36aa:	df 91       	pop	r29
    36ac:	08 95       	ret

000036ae <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    36ae:	df 93       	push	r29
    36b0:	cf 93       	push	r28
    36b2:	cd b7       	in	r28, 0x3d	; 61
    36b4:	de b7       	in	r29, 0x3e	; 62
    36b6:	2a 97       	sbiw	r28, 0x0a	; 10
    36b8:	0f b6       	in	r0, 0x3f	; 63
    36ba:	f8 94       	cli
    36bc:	de bf       	out	0x3e, r29	; 62
    36be:	0f be       	out	0x3f, r0	; 63
    36c0:	cd bf       	out	0x3d, r28	; 61
    36c2:	98 87       	std	Y+8, r25	; 0x08
    36c4:	8f 83       	std	Y+7, r24	; 0x07
    36c6:	7a 87       	std	Y+10, r23	; 0x0a
    36c8:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    36ca:	8f 81       	ldd	r24, Y+7	; 0x07
    36cc:	98 85       	ldd	r25, Y+8	; 0x08
    36ce:	9c 83       	std	Y+4, r25	; 0x04
    36d0:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    36d2:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    36d4:	eb 81       	ldd	r30, Y+3	; 0x03
    36d6:	fc 81       	ldd	r31, Y+4	; 0x04
    36d8:	82 8d       	ldd	r24, Z+26	; 0x1a
    36da:	8a 83       	std	Y+2, r24	; 0x02

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    36dc:	eb 81       	ldd	r30, Y+3	; 0x03
    36de:	fc 81       	ldd	r31, Y+4	; 0x04
    36e0:	93 8d       	ldd	r25, Z+27	; 0x1b
    36e2:	8a 81       	ldd	r24, Y+2	; 0x02
    36e4:	89 17       	cp	r24, r25
    36e6:	48 f5       	brcc	.+82     	; 0x373a <xQueueGiveFromISR+0x8c>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    36e8:	eb 81       	ldd	r30, Y+3	; 0x03
    36ea:	fc 81       	ldd	r31, Y+4	; 0x04
    36ec:	86 8d       	ldd	r24, Z+30	; 0x1e
    36ee:	89 83       	std	Y+1, r24	; 0x01
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    36f0:	8a 81       	ldd	r24, Y+2	; 0x02
    36f2:	8f 5f       	subi	r24, 0xFF	; 255
    36f4:	eb 81       	ldd	r30, Y+3	; 0x03
    36f6:	fc 81       	ldd	r31, Y+4	; 0x04
    36f8:	82 8f       	std	Z+26, r24	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    36fa:	89 81       	ldd	r24, Y+1	; 0x01
    36fc:	8f 3f       	cpi	r24, 0xFF	; 255
    36fe:	a9 f4       	brne	.+42     	; 0x372a <xQueueGiveFromISR+0x7c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3700:	eb 81       	ldd	r30, Y+3	; 0x03
    3702:	fc 81       	ldd	r31, Y+4	; 0x04
    3704:	81 89       	ldd	r24, Z+17	; 0x11
    3706:	88 23       	and	r24, r24
    3708:	a9 f0       	breq	.+42     	; 0x3734 <xQueueGiveFromISR+0x86>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    370a:	8b 81       	ldd	r24, Y+3	; 0x03
    370c:	9c 81       	ldd	r25, Y+4	; 0x04
    370e:	41 96       	adiw	r24, 0x11	; 17
    3710:	0e 94 62 2a 	call	0x54c4	; 0x54c4 <xTaskRemoveFromEventList>
    3714:	88 23       	and	r24, r24
    3716:	71 f0       	breq	.+28     	; 0x3734 <xQueueGiveFromISR+0x86>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    3718:	89 85       	ldd	r24, Y+9	; 0x09
    371a:	9a 85       	ldd	r25, Y+10	; 0x0a
    371c:	00 97       	sbiw	r24, 0x00	; 0
    371e:	51 f0       	breq	.+20     	; 0x3734 <xQueueGiveFromISR+0x86>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    3720:	e9 85       	ldd	r30, Y+9	; 0x09
    3722:	fa 85       	ldd	r31, Y+10	; 0x0a
    3724:	81 e0       	ldi	r24, 0x01	; 1
    3726:	80 83       	st	Z, r24
    3728:	05 c0       	rjmp	.+10     	; 0x3734 <xQueueGiveFromISR+0x86>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    372a:	89 81       	ldd	r24, Y+1	; 0x01
    372c:	8f 5f       	subi	r24, 0xFF	; 255
    372e:	eb 81       	ldd	r30, Y+3	; 0x03
    3730:	fc 81       	ldd	r31, Y+4	; 0x04
    3732:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    3734:	81 e0       	ldi	r24, 0x01	; 1
    3736:	8e 83       	std	Y+6, r24	; 0x06
    3738:	01 c0       	rjmp	.+2      	; 0x373c <xQueueGiveFromISR+0x8e>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    373a:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    373c:	8e 81       	ldd	r24, Y+6	; 0x06
}
    373e:	2a 96       	adiw	r28, 0x0a	; 10
    3740:	0f b6       	in	r0, 0x3f	; 63
    3742:	f8 94       	cli
    3744:	de bf       	out	0x3e, r29	; 62
    3746:	0f be       	out	0x3f, r0	; 63
    3748:	cd bf       	out	0x3d, r28	; 61
    374a:	cf 91       	pop	r28
    374c:	df 91       	pop	r29
    374e:	08 95       	ret

00003750 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    3750:	df 93       	push	r29
    3752:	cf 93       	push	r28
    3754:	cd b7       	in	r28, 0x3d	; 61
    3756:	de b7       	in	r29, 0x3e	; 62
    3758:	2e 97       	sbiw	r28, 0x0e	; 14
    375a:	0f b6       	in	r0, 0x3f	; 63
    375c:	f8 94       	cli
    375e:	de bf       	out	0x3e, r29	; 62
    3760:	0f be       	out	0x3f, r0	; 63
    3762:	cd bf       	out	0x3d, r28	; 61
    3764:	99 87       	std	Y+9, r25	; 0x09
    3766:	88 87       	std	Y+8, r24	; 0x08
    3768:	7b 87       	std	Y+11, r23	; 0x0b
    376a:	6a 87       	std	Y+10, r22	; 0x0a
    376c:	5d 87       	std	Y+13, r21	; 0x0d
    376e:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xEntryTimeSet = pdFALSE;
    3770:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    3772:	88 85       	ldd	r24, Y+8	; 0x08
    3774:	99 85       	ldd	r25, Y+9	; 0x09
    3776:	9b 83       	std	Y+3, r25	; 0x03
    3778:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    377a:	0f b6       	in	r0, 0x3f	; 63
    377c:	f8 94       	cli
    377e:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3780:	ea 81       	ldd	r30, Y+2	; 0x02
    3782:	fb 81       	ldd	r31, Y+3	; 0x03
    3784:	82 8d       	ldd	r24, Z+26	; 0x1a
    3786:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3788:	89 81       	ldd	r24, Y+1	; 0x01
    378a:	88 23       	and	r24, r24
    378c:	f9 f0       	breq	.+62     	; 0x37cc <xQueueReceive+0x7c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    378e:	8a 81       	ldd	r24, Y+2	; 0x02
    3790:	9b 81       	ldd	r25, Y+3	; 0x03
    3792:	2a 85       	ldd	r18, Y+10	; 0x0a
    3794:	3b 85       	ldd	r19, Y+11	; 0x0b
    3796:	b9 01       	movw	r22, r18
    3798:	0e 94 4b 1f 	call	0x3e96	; 0x3e96 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    379c:	89 81       	ldd	r24, Y+1	; 0x01
    379e:	81 50       	subi	r24, 0x01	; 1
    37a0:	ea 81       	ldd	r30, Y+2	; 0x02
    37a2:	fb 81       	ldd	r31, Y+3	; 0x03
    37a4:	82 8f       	std	Z+26, r24	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    37a6:	ea 81       	ldd	r30, Y+2	; 0x02
    37a8:	fb 81       	ldd	r31, Y+3	; 0x03
    37aa:	80 85       	ldd	r24, Z+8	; 0x08
    37ac:	88 23       	and	r24, r24
    37ae:	49 f0       	breq	.+18     	; 0x37c2 <xQueueReceive+0x72>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    37b0:	8a 81       	ldd	r24, Y+2	; 0x02
    37b2:	9b 81       	ldd	r25, Y+3	; 0x03
    37b4:	08 96       	adiw	r24, 0x08	; 8
    37b6:	0e 94 62 2a 	call	0x54c4	; 0x54c4 <xTaskRemoveFromEventList>
    37ba:	88 23       	and	r24, r24
    37bc:	11 f0       	breq	.+4      	; 0x37c2 <xQueueReceive+0x72>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    37be:	0e 94 86 10 	call	0x210c	; 0x210c <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    37c2:	0f 90       	pop	r0
    37c4:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    37c6:	81 e0       	ldi	r24, 0x01	; 1
    37c8:	8e 87       	std	Y+14, r24	; 0x0e
    37ca:	63 c0       	rjmp	.+198    	; 0x3892 <xQueueReceive+0x142>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    37cc:	8c 85       	ldd	r24, Y+12	; 0x0c
    37ce:	9d 85       	ldd	r25, Y+13	; 0x0d
    37d0:	00 97       	sbiw	r24, 0x00	; 0
    37d2:	21 f4       	brne	.+8      	; 0x37dc <xQueueReceive+0x8c>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    37d4:	0f 90       	pop	r0
    37d6:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    37d8:	1e 86       	std	Y+14, r1	; 0x0e
    37da:	5b c0       	rjmp	.+182    	; 0x3892 <xQueueReceive+0x142>
                }
                else if( xEntryTimeSet == pdFALSE )
    37dc:	8c 81       	ldd	r24, Y+4	; 0x04
    37de:	88 23       	and	r24, r24
    37e0:	31 f4       	brne	.+12     	; 0x37ee <xQueueReceive+0x9e>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    37e2:	ce 01       	movw	r24, r28
    37e4:	05 96       	adiw	r24, 0x05	; 5
    37e6:	0e 94 d2 2c 	call	0x59a4	; 0x59a4 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    37ea:	81 e0       	ldi	r24, 0x01	; 1
    37ec:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    37ee:	0f 90       	pop	r0
    37f0:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    37f2:	0e 94 9c 25 	call	0x4b38	; 0x4b38 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    37f6:	0f b6       	in	r0, 0x3f	; 63
    37f8:	f8 94       	cli
    37fa:	0f 92       	push	r0
    37fc:	ea 81       	ldd	r30, Y+2	; 0x02
    37fe:	fb 81       	ldd	r31, Y+3	; 0x03
    3800:	85 8d       	ldd	r24, Z+29	; 0x1d
    3802:	8f 3f       	cpi	r24, 0xFF	; 255
    3804:	19 f4       	brne	.+6      	; 0x380c <xQueueReceive+0xbc>
    3806:	ea 81       	ldd	r30, Y+2	; 0x02
    3808:	fb 81       	ldd	r31, Y+3	; 0x03
    380a:	15 8e       	std	Z+29, r1	; 0x1d
    380c:	ea 81       	ldd	r30, Y+2	; 0x02
    380e:	fb 81       	ldd	r31, Y+3	; 0x03
    3810:	86 8d       	ldd	r24, Z+30	; 0x1e
    3812:	8f 3f       	cpi	r24, 0xFF	; 255
    3814:	19 f4       	brne	.+6      	; 0x381c <xQueueReceive+0xcc>
    3816:	ea 81       	ldd	r30, Y+2	; 0x02
    3818:	fb 81       	ldd	r31, Y+3	; 0x03
    381a:	16 8e       	std	Z+30, r1	; 0x1e
    381c:	0f 90       	pop	r0
    381e:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3820:	ce 01       	movw	r24, r28
    3822:	05 96       	adiw	r24, 0x05	; 5
    3824:	9e 01       	movw	r18, r28
    3826:	24 5f       	subi	r18, 0xF4	; 244
    3828:	3f 4f       	sbci	r19, 0xFF	; 255
    382a:	b9 01       	movw	r22, r18
    382c:	0e 94 eb 2c 	call	0x59d6	; 0x59d6 <xTaskCheckForTimeOut>
    3830:	88 23       	and	r24, r24
    3832:	09 f5       	brne	.+66     	; 0x3876 <xQueueReceive+0x126>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3834:	8a 81       	ldd	r24, Y+2	; 0x02
    3836:	9b 81       	ldd	r25, Y+3	; 0x03
    3838:	0e 94 e5 1f 	call	0x3fca	; 0x3fca <prvIsQueueEmpty>
    383c:	88 23       	and	r24, r24
    383e:	a1 f0       	breq	.+40     	; 0x3868 <xQueueReceive+0x118>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3840:	8a 81       	ldd	r24, Y+2	; 0x02
    3842:	9b 81       	ldd	r25, Y+3	; 0x03
    3844:	41 96       	adiw	r24, 0x11	; 17
    3846:	2c 85       	ldd	r18, Y+12	; 0x0c
    3848:	3d 85       	ldd	r19, Y+13	; 0x0d
    384a:	b9 01       	movw	r22, r18
    384c:	0e 94 79 29 	call	0x52f2	; 0x52f2 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    3850:	8a 81       	ldd	r24, Y+2	; 0x02
    3852:	9b 81       	ldd	r25, Y+3	; 0x03
    3854:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    3858:	0e 94 a8 25 	call	0x4b50	; 0x4b50 <xTaskResumeAll>
    385c:	88 23       	and	r24, r24
    385e:	09 f0       	breq	.+2      	; 0x3862 <xQueueReceive+0x112>
    3860:	8c cf       	rjmp	.-232    	; 0x377a <xQueueReceive+0x2a>
                {
                    portYIELD_WITHIN_API();
    3862:	0e 94 86 10 	call	0x210c	; 0x210c <vPortYield>
    3866:	89 cf       	rjmp	.-238    	; 0x377a <xQueueReceive+0x2a>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    3868:	8a 81       	ldd	r24, Y+2	; 0x02
    386a:	9b 81       	ldd	r25, Y+3	; 0x03
    386c:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    3870:	0e 94 a8 25 	call	0x4b50	; 0x4b50 <xTaskResumeAll>
    3874:	82 cf       	rjmp	.-252    	; 0x377a <xQueueReceive+0x2a>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    3876:	8a 81       	ldd	r24, Y+2	; 0x02
    3878:	9b 81       	ldd	r25, Y+3	; 0x03
    387a:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    387e:	0e 94 a8 25 	call	0x4b50	; 0x4b50 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3882:	8a 81       	ldd	r24, Y+2	; 0x02
    3884:	9b 81       	ldd	r25, Y+3	; 0x03
    3886:	0e 94 e5 1f 	call	0x3fca	; 0x3fca <prvIsQueueEmpty>
    388a:	88 23       	and	r24, r24
    388c:	09 f4       	brne	.+2      	; 0x3890 <xQueueReceive+0x140>
    388e:	75 cf       	rjmp	.-278    	; 0x377a <xQueueReceive+0x2a>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    3890:	1e 86       	std	Y+14, r1	; 0x0e
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    3892:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    3894:	2e 96       	adiw	r28, 0x0e	; 14
    3896:	0f b6       	in	r0, 0x3f	; 63
    3898:	f8 94       	cli
    389a:	de bf       	out	0x3e, r29	; 62
    389c:	0f be       	out	0x3f, r0	; 63
    389e:	cd bf       	out	0x3d, r28	; 61
    38a0:	cf 91       	pop	r28
    38a2:	df 91       	pop	r29
    38a4:	08 95       	ret

000038a6 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    38a6:	df 93       	push	r29
    38a8:	cf 93       	push	r28
    38aa:	cd b7       	in	r28, 0x3d	; 61
    38ac:	de b7       	in	r29, 0x3e	; 62
    38ae:	2c 97       	sbiw	r28, 0x0c	; 12
    38b0:	0f b6       	in	r0, 0x3f	; 63
    38b2:	f8 94       	cli
    38b4:	de bf       	out	0x3e, r29	; 62
    38b6:	0f be       	out	0x3f, r0	; 63
    38b8:	cd bf       	out	0x3d, r28	; 61
    38ba:	99 87       	std	Y+9, r25	; 0x09
    38bc:	88 87       	std	Y+8, r24	; 0x08
    38be:	7b 87       	std	Y+11, r23	; 0x0b
    38c0:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xEntryTimeSet = pdFALSE;
    38c2:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    38c4:	88 85       	ldd	r24, Y+8	; 0x08
    38c6:	99 85       	ldd	r25, Y+9	; 0x09
    38c8:	9b 83       	std	Y+3, r25	; 0x03
    38ca:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    38cc:	0f b6       	in	r0, 0x3f	; 63
    38ce:	f8 94       	cli
    38d0:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    38d2:	ea 81       	ldd	r30, Y+2	; 0x02
    38d4:	fb 81       	ldd	r31, Y+3	; 0x03
    38d6:	82 8d       	ldd	r24, Z+26	; 0x1a
    38d8:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    38da:	89 81       	ldd	r24, Y+1	; 0x01
    38dc:	88 23       	and	r24, r24
    38de:	c1 f0       	breq	.+48     	; 0x3910 <xQueueSemaphoreTake+0x6a>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    38e0:	89 81       	ldd	r24, Y+1	; 0x01
    38e2:	81 50       	subi	r24, 0x01	; 1
    38e4:	ea 81       	ldd	r30, Y+2	; 0x02
    38e6:	fb 81       	ldd	r31, Y+3	; 0x03
    38e8:	82 8f       	std	Z+26, r24	; 0x1a
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    38ea:	ea 81       	ldd	r30, Y+2	; 0x02
    38ec:	fb 81       	ldd	r31, Y+3	; 0x03
    38ee:	80 85       	ldd	r24, Z+8	; 0x08
    38f0:	88 23       	and	r24, r24
    38f2:	49 f0       	breq	.+18     	; 0x3906 <xQueueSemaphoreTake+0x60>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    38f4:	8a 81       	ldd	r24, Y+2	; 0x02
    38f6:	9b 81       	ldd	r25, Y+3	; 0x03
    38f8:	08 96       	adiw	r24, 0x08	; 8
    38fa:	0e 94 62 2a 	call	0x54c4	; 0x54c4 <xTaskRemoveFromEventList>
    38fe:	88 23       	and	r24, r24
    3900:	11 f0       	breq	.+4      	; 0x3906 <xQueueSemaphoreTake+0x60>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    3902:	0e 94 86 10 	call	0x210c	; 0x210c <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    3906:	0f 90       	pop	r0
    3908:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    390a:	81 e0       	ldi	r24, 0x01	; 1
    390c:	8c 87       	std	Y+12, r24	; 0x0c
    390e:	63 c0       	rjmp	.+198    	; 0x39d6 <xQueueSemaphoreTake+0x130>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    3910:	8a 85       	ldd	r24, Y+10	; 0x0a
    3912:	9b 85       	ldd	r25, Y+11	; 0x0b
    3914:	00 97       	sbiw	r24, 0x00	; 0
    3916:	21 f4       	brne	.+8      	; 0x3920 <xQueueSemaphoreTake+0x7a>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    3918:	0f 90       	pop	r0
    391a:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    391c:	1c 86       	std	Y+12, r1	; 0x0c
    391e:	5b c0       	rjmp	.+182    	; 0x39d6 <xQueueSemaphoreTake+0x130>
                }
                else if( xEntryTimeSet == pdFALSE )
    3920:	8c 81       	ldd	r24, Y+4	; 0x04
    3922:	88 23       	and	r24, r24
    3924:	31 f4       	brne	.+12     	; 0x3932 <xQueueSemaphoreTake+0x8c>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3926:	ce 01       	movw	r24, r28
    3928:	05 96       	adiw	r24, 0x05	; 5
    392a:	0e 94 d2 2c 	call	0x59a4	; 0x59a4 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    392e:	81 e0       	ldi	r24, 0x01	; 1
    3930:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    3932:	0f 90       	pop	r0
    3934:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    3936:	0e 94 9c 25 	call	0x4b38	; 0x4b38 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    393a:	0f b6       	in	r0, 0x3f	; 63
    393c:	f8 94       	cli
    393e:	0f 92       	push	r0
    3940:	ea 81       	ldd	r30, Y+2	; 0x02
    3942:	fb 81       	ldd	r31, Y+3	; 0x03
    3944:	85 8d       	ldd	r24, Z+29	; 0x1d
    3946:	8f 3f       	cpi	r24, 0xFF	; 255
    3948:	19 f4       	brne	.+6      	; 0x3950 <xQueueSemaphoreTake+0xaa>
    394a:	ea 81       	ldd	r30, Y+2	; 0x02
    394c:	fb 81       	ldd	r31, Y+3	; 0x03
    394e:	15 8e       	std	Z+29, r1	; 0x1d
    3950:	ea 81       	ldd	r30, Y+2	; 0x02
    3952:	fb 81       	ldd	r31, Y+3	; 0x03
    3954:	86 8d       	ldd	r24, Z+30	; 0x1e
    3956:	8f 3f       	cpi	r24, 0xFF	; 255
    3958:	19 f4       	brne	.+6      	; 0x3960 <xQueueSemaphoreTake+0xba>
    395a:	ea 81       	ldd	r30, Y+2	; 0x02
    395c:	fb 81       	ldd	r31, Y+3	; 0x03
    395e:	16 8e       	std	Z+30, r1	; 0x1e
    3960:	0f 90       	pop	r0
    3962:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3964:	ce 01       	movw	r24, r28
    3966:	05 96       	adiw	r24, 0x05	; 5
    3968:	9e 01       	movw	r18, r28
    396a:	26 5f       	subi	r18, 0xF6	; 246
    396c:	3f 4f       	sbci	r19, 0xFF	; 255
    396e:	b9 01       	movw	r22, r18
    3970:	0e 94 eb 2c 	call	0x59d6	; 0x59d6 <xTaskCheckForTimeOut>
    3974:	88 23       	and	r24, r24
    3976:	09 f5       	brne	.+66     	; 0x39ba <xQueueSemaphoreTake+0x114>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3978:	8a 81       	ldd	r24, Y+2	; 0x02
    397a:	9b 81       	ldd	r25, Y+3	; 0x03
    397c:	0e 94 e5 1f 	call	0x3fca	; 0x3fca <prvIsQueueEmpty>
    3980:	88 23       	and	r24, r24
    3982:	a1 f0       	breq	.+40     	; 0x39ac <xQueueSemaphoreTake+0x106>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3984:	8a 81       	ldd	r24, Y+2	; 0x02
    3986:	9b 81       	ldd	r25, Y+3	; 0x03
    3988:	41 96       	adiw	r24, 0x11	; 17
    398a:	2a 85       	ldd	r18, Y+10	; 0x0a
    398c:	3b 85       	ldd	r19, Y+11	; 0x0b
    398e:	b9 01       	movw	r22, r18
    3990:	0e 94 79 29 	call	0x52f2	; 0x52f2 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    3994:	8a 81       	ldd	r24, Y+2	; 0x02
    3996:	9b 81       	ldd	r25, Y+3	; 0x03
    3998:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    399c:	0e 94 a8 25 	call	0x4b50	; 0x4b50 <xTaskResumeAll>
    39a0:	88 23       	and	r24, r24
    39a2:	09 f0       	breq	.+2      	; 0x39a6 <xQueueSemaphoreTake+0x100>
    39a4:	93 cf       	rjmp	.-218    	; 0x38cc <xQueueSemaphoreTake+0x26>
                {
                    portYIELD_WITHIN_API();
    39a6:	0e 94 86 10 	call	0x210c	; 0x210c <vPortYield>
    39aa:	90 cf       	rjmp	.-224    	; 0x38cc <xQueueSemaphoreTake+0x26>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    39ac:	8a 81       	ldd	r24, Y+2	; 0x02
    39ae:	9b 81       	ldd	r25, Y+3	; 0x03
    39b0:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    39b4:	0e 94 a8 25 	call	0x4b50	; 0x4b50 <xTaskResumeAll>
    39b8:	89 cf       	rjmp	.-238    	; 0x38cc <xQueueSemaphoreTake+0x26>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    39ba:	8a 81       	ldd	r24, Y+2	; 0x02
    39bc:	9b 81       	ldd	r25, Y+3	; 0x03
    39be:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    39c2:	0e 94 a8 25 	call	0x4b50	; 0x4b50 <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    39c6:	8a 81       	ldd	r24, Y+2	; 0x02
    39c8:	9b 81       	ldd	r25, Y+3	; 0x03
    39ca:	0e 94 e5 1f 	call	0x3fca	; 0x3fca <prvIsQueueEmpty>
    39ce:	88 23       	and	r24, r24
    39d0:	09 f4       	brne	.+2      	; 0x39d4 <xQueueSemaphoreTake+0x12e>
    39d2:	7c cf       	rjmp	.-264    	; 0x38cc <xQueueSemaphoreTake+0x26>
                        }
                    }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    39d4:	1c 86       	std	Y+12, r1	; 0x0c
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    39d6:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    39d8:	2c 96       	adiw	r28, 0x0c	; 12
    39da:	0f b6       	in	r0, 0x3f	; 63
    39dc:	f8 94       	cli
    39de:	de bf       	out	0x3e, r29	; 62
    39e0:	0f be       	out	0x3f, r0	; 63
    39e2:	cd bf       	out	0x3d, r28	; 61
    39e4:	cf 91       	pop	r28
    39e6:	df 91       	pop	r29
    39e8:	08 95       	ret

000039ea <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    39ea:	df 93       	push	r29
    39ec:	cf 93       	push	r28
    39ee:	cd b7       	in	r28, 0x3d	; 61
    39f0:	de b7       	in	r29, 0x3e	; 62
    39f2:	60 97       	sbiw	r28, 0x10	; 16
    39f4:	0f b6       	in	r0, 0x3f	; 63
    39f6:	f8 94       	cli
    39f8:	de bf       	out	0x3e, r29	; 62
    39fa:	0f be       	out	0x3f, r0	; 63
    39fc:	cd bf       	out	0x3d, r28	; 61
    39fe:	9b 87       	std	Y+11, r25	; 0x0b
    3a00:	8a 87       	std	Y+10, r24	; 0x0a
    3a02:	7d 87       	std	Y+13, r23	; 0x0d
    3a04:	6c 87       	std	Y+12, r22	; 0x0c
    3a06:	5f 87       	std	Y+15, r21	; 0x0f
    3a08:	4e 87       	std	Y+14, r20	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE;
    3a0a:	1e 82       	std	Y+6, r1	; 0x06
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    3a0c:	8a 85       	ldd	r24, Y+10	; 0x0a
    3a0e:	9b 85       	ldd	r25, Y+11	; 0x0b
    3a10:	9b 83       	std	Y+3, r25	; 0x03
    3a12:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    3a14:	0f b6       	in	r0, 0x3f	; 63
    3a16:	f8 94       	cli
    3a18:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3a1a:	ea 81       	ldd	r30, Y+2	; 0x02
    3a1c:	fb 81       	ldd	r31, Y+3	; 0x03
    3a1e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3a20:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3a22:	89 81       	ldd	r24, Y+1	; 0x01
    3a24:	88 23       	and	r24, r24
    3a26:	31 f1       	breq	.+76     	; 0x3a74 <xQueuePeek+0x8a>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    3a28:	ea 81       	ldd	r30, Y+2	; 0x02
    3a2a:	fb 81       	ldd	r31, Y+3	; 0x03
    3a2c:	86 81       	ldd	r24, Z+6	; 0x06
    3a2e:	97 81       	ldd	r25, Z+7	; 0x07
    3a30:	9d 83       	std	Y+5, r25	; 0x05
    3a32:	8c 83       	std	Y+4, r24	; 0x04

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    3a34:	8a 81       	ldd	r24, Y+2	; 0x02
    3a36:	9b 81       	ldd	r25, Y+3	; 0x03
    3a38:	2c 85       	ldd	r18, Y+12	; 0x0c
    3a3a:	3d 85       	ldd	r19, Y+13	; 0x0d
    3a3c:	b9 01       	movw	r22, r18
    3a3e:	0e 94 4b 1f 	call	0x3e96	; 0x3e96 <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    3a42:	ea 81       	ldd	r30, Y+2	; 0x02
    3a44:	fb 81       	ldd	r31, Y+3	; 0x03
    3a46:	8c 81       	ldd	r24, Y+4	; 0x04
    3a48:	9d 81       	ldd	r25, Y+5	; 0x05
    3a4a:	97 83       	std	Z+7, r25	; 0x07
    3a4c:	86 83       	std	Z+6, r24	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3a4e:	ea 81       	ldd	r30, Y+2	; 0x02
    3a50:	fb 81       	ldd	r31, Y+3	; 0x03
    3a52:	81 89       	ldd	r24, Z+17	; 0x11
    3a54:	88 23       	and	r24, r24
    3a56:	49 f0       	breq	.+18     	; 0x3a6a <xQueuePeek+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3a58:	8a 81       	ldd	r24, Y+2	; 0x02
    3a5a:	9b 81       	ldd	r25, Y+3	; 0x03
    3a5c:	41 96       	adiw	r24, 0x11	; 17
    3a5e:	0e 94 62 2a 	call	0x54c4	; 0x54c4 <xTaskRemoveFromEventList>
    3a62:	88 23       	and	r24, r24
    3a64:	11 f0       	breq	.+4      	; 0x3a6a <xQueuePeek+0x80>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    3a66:	0e 94 86 10 	call	0x210c	; 0x210c <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    3a6a:	0f 90       	pop	r0
    3a6c:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    3a6e:	81 e0       	ldi	r24, 0x01	; 1
    3a70:	88 8b       	std	Y+16, r24	; 0x10
    3a72:	63 c0       	rjmp	.+198    	; 0x3b3a <xQueuePeek+0x150>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    3a74:	8e 85       	ldd	r24, Y+14	; 0x0e
    3a76:	9f 85       	ldd	r25, Y+15	; 0x0f
    3a78:	00 97       	sbiw	r24, 0x00	; 0
    3a7a:	21 f4       	brne	.+8      	; 0x3a84 <xQueuePeek+0x9a>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    3a7c:	0f 90       	pop	r0
    3a7e:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    3a80:	18 8a       	std	Y+16, r1	; 0x10
    3a82:	5b c0       	rjmp	.+182    	; 0x3b3a <xQueuePeek+0x150>
                }
                else if( xEntryTimeSet == pdFALSE )
    3a84:	8e 81       	ldd	r24, Y+6	; 0x06
    3a86:	88 23       	and	r24, r24
    3a88:	31 f4       	brne	.+12     	; 0x3a96 <xQueuePeek+0xac>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3a8a:	ce 01       	movw	r24, r28
    3a8c:	07 96       	adiw	r24, 0x07	; 7
    3a8e:	0e 94 d2 2c 	call	0x59a4	; 0x59a4 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    3a92:	81 e0       	ldi	r24, 0x01	; 1
    3a94:	8e 83       	std	Y+6, r24	; 0x06
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    3a96:	0f 90       	pop	r0
    3a98:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    3a9a:	0e 94 9c 25 	call	0x4b38	; 0x4b38 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    3a9e:	0f b6       	in	r0, 0x3f	; 63
    3aa0:	f8 94       	cli
    3aa2:	0f 92       	push	r0
    3aa4:	ea 81       	ldd	r30, Y+2	; 0x02
    3aa6:	fb 81       	ldd	r31, Y+3	; 0x03
    3aa8:	85 8d       	ldd	r24, Z+29	; 0x1d
    3aaa:	8f 3f       	cpi	r24, 0xFF	; 255
    3aac:	19 f4       	brne	.+6      	; 0x3ab4 <xQueuePeek+0xca>
    3aae:	ea 81       	ldd	r30, Y+2	; 0x02
    3ab0:	fb 81       	ldd	r31, Y+3	; 0x03
    3ab2:	15 8e       	std	Z+29, r1	; 0x1d
    3ab4:	ea 81       	ldd	r30, Y+2	; 0x02
    3ab6:	fb 81       	ldd	r31, Y+3	; 0x03
    3ab8:	86 8d       	ldd	r24, Z+30	; 0x1e
    3aba:	8f 3f       	cpi	r24, 0xFF	; 255
    3abc:	19 f4       	brne	.+6      	; 0x3ac4 <xQueuePeek+0xda>
    3abe:	ea 81       	ldd	r30, Y+2	; 0x02
    3ac0:	fb 81       	ldd	r31, Y+3	; 0x03
    3ac2:	16 8e       	std	Z+30, r1	; 0x1e
    3ac4:	0f 90       	pop	r0
    3ac6:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3ac8:	ce 01       	movw	r24, r28
    3aca:	07 96       	adiw	r24, 0x07	; 7
    3acc:	9e 01       	movw	r18, r28
    3ace:	22 5f       	subi	r18, 0xF2	; 242
    3ad0:	3f 4f       	sbci	r19, 0xFF	; 255
    3ad2:	b9 01       	movw	r22, r18
    3ad4:	0e 94 eb 2c 	call	0x59d6	; 0x59d6 <xTaskCheckForTimeOut>
    3ad8:	88 23       	and	r24, r24
    3ada:	09 f5       	brne	.+66     	; 0x3b1e <xQueuePeek+0x134>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3adc:	8a 81       	ldd	r24, Y+2	; 0x02
    3ade:	9b 81       	ldd	r25, Y+3	; 0x03
    3ae0:	0e 94 e5 1f 	call	0x3fca	; 0x3fca <prvIsQueueEmpty>
    3ae4:	88 23       	and	r24, r24
    3ae6:	a1 f0       	breq	.+40     	; 0x3b10 <xQueuePeek+0x126>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3ae8:	8a 81       	ldd	r24, Y+2	; 0x02
    3aea:	9b 81       	ldd	r25, Y+3	; 0x03
    3aec:	41 96       	adiw	r24, 0x11	; 17
    3aee:	2e 85       	ldd	r18, Y+14	; 0x0e
    3af0:	3f 85       	ldd	r19, Y+15	; 0x0f
    3af2:	b9 01       	movw	r22, r18
    3af4:	0e 94 79 29 	call	0x52f2	; 0x52f2 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    3af8:	8a 81       	ldd	r24, Y+2	; 0x02
    3afa:	9b 81       	ldd	r25, Y+3	; 0x03
    3afc:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    3b00:	0e 94 a8 25 	call	0x4b50	; 0x4b50 <xTaskResumeAll>
    3b04:	88 23       	and	r24, r24
    3b06:	09 f0       	breq	.+2      	; 0x3b0a <xQueuePeek+0x120>
    3b08:	85 cf       	rjmp	.-246    	; 0x3a14 <xQueuePeek+0x2a>
                {
                    portYIELD_WITHIN_API();
    3b0a:	0e 94 86 10 	call	0x210c	; 0x210c <vPortYield>
    3b0e:	82 cf       	rjmp	.-252    	; 0x3a14 <xQueuePeek+0x2a>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    3b10:	8a 81       	ldd	r24, Y+2	; 0x02
    3b12:	9b 81       	ldd	r25, Y+3	; 0x03
    3b14:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    3b18:	0e 94 a8 25 	call	0x4b50	; 0x4b50 <xTaskResumeAll>
    3b1c:	7b cf       	rjmp	.-266    	; 0x3a14 <xQueuePeek+0x2a>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    3b1e:	8a 81       	ldd	r24, Y+2	; 0x02
    3b20:	9b 81       	ldd	r25, Y+3	; 0x03
    3b22:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    3b26:	0e 94 a8 25 	call	0x4b50	; 0x4b50 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3b2a:	8a 81       	ldd	r24, Y+2	; 0x02
    3b2c:	9b 81       	ldd	r25, Y+3	; 0x03
    3b2e:	0e 94 e5 1f 	call	0x3fca	; 0x3fca <prvIsQueueEmpty>
    3b32:	88 23       	and	r24, r24
    3b34:	09 f4       	brne	.+2      	; 0x3b38 <xQueuePeek+0x14e>
    3b36:	6e cf       	rjmp	.-292    	; 0x3a14 <xQueuePeek+0x2a>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    3b38:	18 8a       	std	Y+16, r1	; 0x10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    3b3a:	88 89       	ldd	r24, Y+16	; 0x10
}
    3b3c:	60 96       	adiw	r28, 0x10	; 16
    3b3e:	0f b6       	in	r0, 0x3f	; 63
    3b40:	f8 94       	cli
    3b42:	de bf       	out	0x3e, r29	; 62
    3b44:	0f be       	out	0x3f, r0	; 63
    3b46:	cd bf       	out	0x3d, r28	; 61
    3b48:	cf 91       	pop	r28
    3b4a:	df 91       	pop	r29
    3b4c:	08 95       	ret

00003b4e <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    3b4e:	df 93       	push	r29
    3b50:	cf 93       	push	r28
    3b52:	cd b7       	in	r28, 0x3d	; 61
    3b54:	de b7       	in	r29, 0x3e	; 62
    3b56:	2c 97       	sbiw	r28, 0x0c	; 12
    3b58:	0f b6       	in	r0, 0x3f	; 63
    3b5a:	f8 94       	cli
    3b5c:	de bf       	out	0x3e, r29	; 62
    3b5e:	0f be       	out	0x3f, r0	; 63
    3b60:	cd bf       	out	0x3d, r28	; 61
    3b62:	98 87       	std	Y+8, r25	; 0x08
    3b64:	8f 83       	std	Y+7, r24	; 0x07
    3b66:	7a 87       	std	Y+10, r23	; 0x0a
    3b68:	69 87       	std	Y+9, r22	; 0x09
    3b6a:	5c 87       	std	Y+12, r21	; 0x0c
    3b6c:	4b 87       	std	Y+11, r20	; 0x0b
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    3b6e:	8f 81       	ldd	r24, Y+7	; 0x07
    3b70:	98 85       	ldd	r25, Y+8	; 0x08
    3b72:	9c 83       	std	Y+4, r25	; 0x04
    3b74:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3b76:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3b78:	eb 81       	ldd	r30, Y+3	; 0x03
    3b7a:	fc 81       	ldd	r31, Y+4	; 0x04
    3b7c:	82 8d       	ldd	r24, Z+26	; 0x1a
    3b7e:	8a 83       	std	Y+2, r24	; 0x02

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3b80:	8a 81       	ldd	r24, Y+2	; 0x02
    3b82:	88 23       	and	r24, r24
    3b84:	81 f1       	breq	.+96     	; 0x3be6 <xQueueReceiveFromISR+0x98>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    3b86:	eb 81       	ldd	r30, Y+3	; 0x03
    3b88:	fc 81       	ldd	r31, Y+4	; 0x04
    3b8a:	85 8d       	ldd	r24, Z+29	; 0x1d
    3b8c:	89 83       	std	Y+1, r24	; 0x01

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    3b8e:	8b 81       	ldd	r24, Y+3	; 0x03
    3b90:	9c 81       	ldd	r25, Y+4	; 0x04
    3b92:	29 85       	ldd	r18, Y+9	; 0x09
    3b94:	3a 85       	ldd	r19, Y+10	; 0x0a
    3b96:	b9 01       	movw	r22, r18
    3b98:	0e 94 4b 1f 	call	0x3e96	; 0x3e96 <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    3b9c:	8a 81       	ldd	r24, Y+2	; 0x02
    3b9e:	81 50       	subi	r24, 0x01	; 1
    3ba0:	eb 81       	ldd	r30, Y+3	; 0x03
    3ba2:	fc 81       	ldd	r31, Y+4	; 0x04
    3ba4:	82 8f       	std	Z+26, r24	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    3ba6:	89 81       	ldd	r24, Y+1	; 0x01
    3ba8:	8f 3f       	cpi	r24, 0xFF	; 255
    3baa:	a9 f4       	brne	.+42     	; 0x3bd6 <xQueueReceiveFromISR+0x88>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3bac:	eb 81       	ldd	r30, Y+3	; 0x03
    3bae:	fc 81       	ldd	r31, Y+4	; 0x04
    3bb0:	80 85       	ldd	r24, Z+8	; 0x08
    3bb2:	88 23       	and	r24, r24
    3bb4:	a9 f0       	breq	.+42     	; 0x3be0 <xQueueReceiveFromISR+0x92>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3bb6:	8b 81       	ldd	r24, Y+3	; 0x03
    3bb8:	9c 81       	ldd	r25, Y+4	; 0x04
    3bba:	08 96       	adiw	r24, 0x08	; 8
    3bbc:	0e 94 62 2a 	call	0x54c4	; 0x54c4 <xTaskRemoveFromEventList>
    3bc0:	88 23       	and	r24, r24
    3bc2:	71 f0       	breq	.+28     	; 0x3be0 <xQueueReceiveFromISR+0x92>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    3bc4:	8b 85       	ldd	r24, Y+11	; 0x0b
    3bc6:	9c 85       	ldd	r25, Y+12	; 0x0c
    3bc8:	00 97       	sbiw	r24, 0x00	; 0
    3bca:	51 f0       	breq	.+20     	; 0x3be0 <xQueueReceiveFromISR+0x92>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    3bcc:	eb 85       	ldd	r30, Y+11	; 0x0b
    3bce:	fc 85       	ldd	r31, Y+12	; 0x0c
    3bd0:	81 e0       	ldi	r24, 0x01	; 1
    3bd2:	80 83       	st	Z, r24
    3bd4:	05 c0       	rjmp	.+10     	; 0x3be0 <xQueueReceiveFromISR+0x92>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                configASSERT( cRxLock != queueINT8_MAX );

                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    3bd6:	89 81       	ldd	r24, Y+1	; 0x01
    3bd8:	8f 5f       	subi	r24, 0xFF	; 255
    3bda:	eb 81       	ldd	r30, Y+3	; 0x03
    3bdc:	fc 81       	ldd	r31, Y+4	; 0x04
    3bde:	85 8f       	std	Z+29, r24	; 0x1d
            }

            xReturn = pdPASS;
    3be0:	81 e0       	ldi	r24, 0x01	; 1
    3be2:	8e 83       	std	Y+6, r24	; 0x06
    3be4:	01 c0       	rjmp	.+2      	; 0x3be8 <xQueueReceiveFromISR+0x9a>
        }
        else
        {
            xReturn = pdFAIL;
    3be6:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    3be8:	8e 81       	ldd	r24, Y+6	; 0x06
}
    3bea:	2c 96       	adiw	r28, 0x0c	; 12
    3bec:	0f b6       	in	r0, 0x3f	; 63
    3bee:	f8 94       	cli
    3bf0:	de bf       	out	0x3e, r29	; 62
    3bf2:	0f be       	out	0x3f, r0	; 63
    3bf4:	cd bf       	out	0x3d, r28	; 61
    3bf6:	cf 91       	pop	r28
    3bf8:	df 91       	pop	r29
    3bfa:	08 95       	ret

00003bfc <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    3bfc:	df 93       	push	r29
    3bfe:	cf 93       	push	r28
    3c00:	cd b7       	in	r28, 0x3d	; 61
    3c02:	de b7       	in	r29, 0x3e	; 62
    3c04:	2a 97       	sbiw	r28, 0x0a	; 10
    3c06:	0f b6       	in	r0, 0x3f	; 63
    3c08:	f8 94       	cli
    3c0a:	de bf       	out	0x3e, r29	; 62
    3c0c:	0f be       	out	0x3f, r0	; 63
    3c0e:	cd bf       	out	0x3d, r28	; 61
    3c10:	98 87       	std	Y+8, r25	; 0x08
    3c12:	8f 83       	std	Y+7, r24	; 0x07
    3c14:	7a 87       	std	Y+10, r23	; 0x0a
    3c16:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    3c18:	8f 81       	ldd	r24, Y+7	; 0x07
    3c1a:	98 85       	ldd	r25, Y+8	; 0x08
    3c1c:	9a 83       	std	Y+2, r25	; 0x02
    3c1e:	89 83       	std	Y+1, r24	; 0x01
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3c20:	1d 82       	std	Y+5, r1	; 0x05
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3c22:	e9 81       	ldd	r30, Y+1	; 0x01
    3c24:	fa 81       	ldd	r31, Y+2	; 0x02
    3c26:	82 8d       	ldd	r24, Z+26	; 0x1a
    3c28:	88 23       	and	r24, r24
    3c2a:	b1 f0       	breq	.+44     	; 0x3c58 <xQueuePeekFromISR+0x5c>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    3c2c:	e9 81       	ldd	r30, Y+1	; 0x01
    3c2e:	fa 81       	ldd	r31, Y+2	; 0x02
    3c30:	86 81       	ldd	r24, Z+6	; 0x06
    3c32:	97 81       	ldd	r25, Z+7	; 0x07
    3c34:	9c 83       	std	Y+4, r25	; 0x04
    3c36:	8b 83       	std	Y+3, r24	; 0x03
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    3c38:	89 81       	ldd	r24, Y+1	; 0x01
    3c3a:	9a 81       	ldd	r25, Y+2	; 0x02
    3c3c:	29 85       	ldd	r18, Y+9	; 0x09
    3c3e:	3a 85       	ldd	r19, Y+10	; 0x0a
    3c40:	b9 01       	movw	r22, r18
    3c42:	0e 94 4b 1f 	call	0x3e96	; 0x3e96 <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    3c46:	e9 81       	ldd	r30, Y+1	; 0x01
    3c48:	fa 81       	ldd	r31, Y+2	; 0x02
    3c4a:	8b 81       	ldd	r24, Y+3	; 0x03
    3c4c:	9c 81       	ldd	r25, Y+4	; 0x04
    3c4e:	97 83       	std	Z+7, r25	; 0x07
    3c50:	86 83       	std	Z+6, r24	; 0x06

            xReturn = pdPASS;
    3c52:	81 e0       	ldi	r24, 0x01	; 1
    3c54:	8e 83       	std	Y+6, r24	; 0x06
    3c56:	01 c0       	rjmp	.+2      	; 0x3c5a <xQueuePeekFromISR+0x5e>
        }
        else
        {
            xReturn = pdFAIL;
    3c58:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    3c5a:	8e 81       	ldd	r24, Y+6	; 0x06
}
    3c5c:	2a 96       	adiw	r28, 0x0a	; 10
    3c5e:	0f b6       	in	r0, 0x3f	; 63
    3c60:	f8 94       	cli
    3c62:	de bf       	out	0x3e, r29	; 62
    3c64:	0f be       	out	0x3f, r0	; 63
    3c66:	cd bf       	out	0x3d, r28	; 61
    3c68:	cf 91       	pop	r28
    3c6a:	df 91       	pop	r29
    3c6c:	08 95       	ret

00003c6e <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    3c6e:	df 93       	push	r29
    3c70:	cf 93       	push	r28
    3c72:	00 d0       	rcall	.+0      	; 0x3c74 <uxQueueMessagesWaiting+0x6>
    3c74:	0f 92       	push	r0
    3c76:	cd b7       	in	r28, 0x3d	; 61
    3c78:	de b7       	in	r29, 0x3e	; 62
    3c7a:	9b 83       	std	Y+3, r25	; 0x03
    3c7c:	8a 83       	std	Y+2, r24	; 0x02
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    3c7e:	0f b6       	in	r0, 0x3f	; 63
    3c80:	f8 94       	cli
    3c82:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    3c84:	ea 81       	ldd	r30, Y+2	; 0x02
    3c86:	fb 81       	ldd	r31, Y+3	; 0x03
    3c88:	82 8d       	ldd	r24, Z+26	; 0x1a
    3c8a:	89 83       	std	Y+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    3c8c:	0f 90       	pop	r0
    3c8e:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    3c90:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3c92:	0f 90       	pop	r0
    3c94:	0f 90       	pop	r0
    3c96:	0f 90       	pop	r0
    3c98:	cf 91       	pop	r28
    3c9a:	df 91       	pop	r29
    3c9c:	08 95       	ret

00003c9e <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    3c9e:	df 93       	push	r29
    3ca0:	cf 93       	push	r28
    3ca2:	00 d0       	rcall	.+0      	; 0x3ca4 <uxQueueSpacesAvailable+0x6>
    3ca4:	00 d0       	rcall	.+0      	; 0x3ca6 <uxQueueSpacesAvailable+0x8>
    3ca6:	0f 92       	push	r0
    3ca8:	cd b7       	in	r28, 0x3d	; 61
    3caa:	de b7       	in	r29, 0x3e	; 62
    3cac:	9d 83       	std	Y+5, r25	; 0x05
    3cae:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    3cb0:	8c 81       	ldd	r24, Y+4	; 0x04
    3cb2:	9d 81       	ldd	r25, Y+5	; 0x05
    3cb4:	9a 83       	std	Y+2, r25	; 0x02
    3cb6:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    3cb8:	0f b6       	in	r0, 0x3f	; 63
    3cba:	f8 94       	cli
    3cbc:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    3cbe:	e9 81       	ldd	r30, Y+1	; 0x01
    3cc0:	fa 81       	ldd	r31, Y+2	; 0x02
    3cc2:	93 8d       	ldd	r25, Z+27	; 0x1b
    3cc4:	e9 81       	ldd	r30, Y+1	; 0x01
    3cc6:	fa 81       	ldd	r31, Y+2	; 0x02
    3cc8:	82 8d       	ldd	r24, Z+26	; 0x1a
    3cca:	29 2f       	mov	r18, r25
    3ccc:	28 1b       	sub	r18, r24
    3cce:	82 2f       	mov	r24, r18
    3cd0:	8b 83       	std	Y+3, r24	; 0x03
    }
    taskEXIT_CRITICAL();
    3cd2:	0f 90       	pop	r0
    3cd4:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    3cd6:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3cd8:	0f 90       	pop	r0
    3cda:	0f 90       	pop	r0
    3cdc:	0f 90       	pop	r0
    3cde:	0f 90       	pop	r0
    3ce0:	0f 90       	pop	r0
    3ce2:	cf 91       	pop	r28
    3ce4:	df 91       	pop	r29
    3ce6:	08 95       	ret

00003ce8 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    3ce8:	df 93       	push	r29
    3cea:	cf 93       	push	r28
    3cec:	00 d0       	rcall	.+0      	; 0x3cee <uxQueueMessagesWaitingFromISR+0x6>
    3cee:	00 d0       	rcall	.+0      	; 0x3cf0 <uxQueueMessagesWaitingFromISR+0x8>
    3cf0:	0f 92       	push	r0
    3cf2:	cd b7       	in	r28, 0x3d	; 61
    3cf4:	de b7       	in	r29, 0x3e	; 62
    3cf6:	9d 83       	std	Y+5, r25	; 0x05
    3cf8:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    3cfa:	8c 81       	ldd	r24, Y+4	; 0x04
    3cfc:	9d 81       	ldd	r25, Y+5	; 0x05
    3cfe:	9a 83       	std	Y+2, r25	; 0x02
    3d00:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    3d02:	e9 81       	ldd	r30, Y+1	; 0x01
    3d04:	fa 81       	ldd	r31, Y+2	; 0x02
    3d06:	82 8d       	ldd	r24, Z+26	; 0x1a
    3d08:	8b 83       	std	Y+3, r24	; 0x03

    return uxReturn;
    3d0a:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3d0c:	0f 90       	pop	r0
    3d0e:	0f 90       	pop	r0
    3d10:	0f 90       	pop	r0
    3d12:	0f 90       	pop	r0
    3d14:	0f 90       	pop	r0
    3d16:	cf 91       	pop	r28
    3d18:	df 91       	pop	r29
    3d1a:	08 95       	ret

00003d1c <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    3d1c:	df 93       	push	r29
    3d1e:	cf 93       	push	r28
    3d20:	00 d0       	rcall	.+0      	; 0x3d22 <vQueueDelete+0x6>
    3d22:	00 d0       	rcall	.+0      	; 0x3d24 <vQueueDelete+0x8>
    3d24:	cd b7       	in	r28, 0x3d	; 61
    3d26:	de b7       	in	r29, 0x3e	; 62
    3d28:	9c 83       	std	Y+4, r25	; 0x04
    3d2a:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    3d2c:	8b 81       	ldd	r24, Y+3	; 0x03
    3d2e:	9c 81       	ldd	r25, Y+4	; 0x04
    3d30:	9a 83       	std	Y+2, r25	; 0x02
    3d32:	89 83       	std	Y+1, r24	; 0x01

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
        {
            /* The queue can only have been allocated dynamically - free it
             * again. */
            vPortFree( pxQueue );
    3d34:	89 81       	ldd	r24, Y+1	; 0x01
    3d36:	9a 81       	ldd	r25, Y+2	; 0x02
    3d38:	0e 94 a1 0e 	call	0x1d42	; 0x1d42 <vPortFree>
            /* The queue must have been statically allocated, so is not going to be
             * deleted.  Avoid compiler warnings about the unused parameter. */
            ( void ) pxQueue;
        }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    3d3c:	0f 90       	pop	r0
    3d3e:	0f 90       	pop	r0
    3d40:	0f 90       	pop	r0
    3d42:	0f 90       	pop	r0
    3d44:	cf 91       	pop	r28
    3d46:	df 91       	pop	r29
    3d48:	08 95       	ret

00003d4a <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    3d4a:	df 93       	push	r29
    3d4c:	cf 93       	push	r28
    3d4e:	cd b7       	in	r28, 0x3d	; 61
    3d50:	de b7       	in	r29, 0x3e	; 62
    3d52:	27 97       	sbiw	r28, 0x07	; 7
    3d54:	0f b6       	in	r0, 0x3f	; 63
    3d56:	f8 94       	cli
    3d58:	de bf       	out	0x3e, r29	; 62
    3d5a:	0f be       	out	0x3f, r0	; 63
    3d5c:	cd bf       	out	0x3d, r28	; 61
    3d5e:	9c 83       	std	Y+4, r25	; 0x04
    3d60:	8b 83       	std	Y+3, r24	; 0x03
    3d62:	7e 83       	std	Y+6, r23	; 0x06
    3d64:	6d 83       	std	Y+5, r22	; 0x05
    3d66:	4f 83       	std	Y+7, r20	; 0x07
    BaseType_t xReturn = pdFALSE;
    3d68:	1a 82       	std	Y+2, r1	; 0x02
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3d6a:	eb 81       	ldd	r30, Y+3	; 0x03
    3d6c:	fc 81       	ldd	r31, Y+4	; 0x04
    3d6e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3d70:	89 83       	std	Y+1, r24	; 0x01

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    3d72:	eb 81       	ldd	r30, Y+3	; 0x03
    3d74:	fc 81       	ldd	r31, Y+4	; 0x04
    3d76:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d78:	88 23       	and	r24, r24
    3d7a:	09 f4       	brne	.+2      	; 0x3d7e <prvCopyDataToQueue+0x34>
    3d7c:	7d c0       	rjmp	.+250    	; 0x3e78 <prvCopyDataToQueue+0x12e>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    3d7e:	8f 81       	ldd	r24, Y+7	; 0x07
    3d80:	88 23       	and	r24, r24
    3d82:	99 f5       	brne	.+102    	; 0x3dea <prvCopyDataToQueue+0xa0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3d84:	eb 81       	ldd	r30, Y+3	; 0x03
    3d86:	fc 81       	ldd	r31, Y+4	; 0x04
    3d88:	62 81       	ldd	r22, Z+2	; 0x02
    3d8a:	73 81       	ldd	r23, Z+3	; 0x03
    3d8c:	eb 81       	ldd	r30, Y+3	; 0x03
    3d8e:	fc 81       	ldd	r31, Y+4	; 0x04
    3d90:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d92:	48 2f       	mov	r20, r24
    3d94:	50 e0       	ldi	r21, 0x00	; 0
    3d96:	2d 81       	ldd	r18, Y+5	; 0x05
    3d98:	3e 81       	ldd	r19, Y+6	; 0x06
    3d9a:	cb 01       	movw	r24, r22
    3d9c:	b9 01       	movw	r22, r18
    3d9e:	0e 94 e2 3b 	call	0x77c4	; 0x77c4 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3da2:	eb 81       	ldd	r30, Y+3	; 0x03
    3da4:	fc 81       	ldd	r31, Y+4	; 0x04
    3da6:	22 81       	ldd	r18, Z+2	; 0x02
    3da8:	33 81       	ldd	r19, Z+3	; 0x03
    3daa:	eb 81       	ldd	r30, Y+3	; 0x03
    3dac:	fc 81       	ldd	r31, Y+4	; 0x04
    3dae:	84 8d       	ldd	r24, Z+28	; 0x1c
    3db0:	88 2f       	mov	r24, r24
    3db2:	90 e0       	ldi	r25, 0x00	; 0
    3db4:	82 0f       	add	r24, r18
    3db6:	93 1f       	adc	r25, r19
    3db8:	eb 81       	ldd	r30, Y+3	; 0x03
    3dba:	fc 81       	ldd	r31, Y+4	; 0x04
    3dbc:	93 83       	std	Z+3, r25	; 0x03
    3dbe:	82 83       	std	Z+2, r24	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3dc0:	eb 81       	ldd	r30, Y+3	; 0x03
    3dc2:	fc 81       	ldd	r31, Y+4	; 0x04
    3dc4:	22 81       	ldd	r18, Z+2	; 0x02
    3dc6:	33 81       	ldd	r19, Z+3	; 0x03
    3dc8:	eb 81       	ldd	r30, Y+3	; 0x03
    3dca:	fc 81       	ldd	r31, Y+4	; 0x04
    3dcc:	84 81       	ldd	r24, Z+4	; 0x04
    3dce:	95 81       	ldd	r25, Z+5	; 0x05
    3dd0:	28 17       	cp	r18, r24
    3dd2:	39 07       	cpc	r19, r25
    3dd4:	08 f4       	brcc	.+2      	; 0x3dd8 <prvCopyDataToQueue+0x8e>
    3dd6:	50 c0       	rjmp	.+160    	; 0x3e78 <prvCopyDataToQueue+0x12e>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    3dd8:	eb 81       	ldd	r30, Y+3	; 0x03
    3dda:	fc 81       	ldd	r31, Y+4	; 0x04
    3ddc:	80 81       	ld	r24, Z
    3dde:	91 81       	ldd	r25, Z+1	; 0x01
    3de0:	eb 81       	ldd	r30, Y+3	; 0x03
    3de2:	fc 81       	ldd	r31, Y+4	; 0x04
    3de4:	93 83       	std	Z+3, r25	; 0x03
    3de6:	82 83       	std	Z+2, r24	; 0x02
    3de8:	47 c0       	rjmp	.+142    	; 0x3e78 <prvCopyDataToQueue+0x12e>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    3dea:	eb 81       	ldd	r30, Y+3	; 0x03
    3dec:	fc 81       	ldd	r31, Y+4	; 0x04
    3dee:	66 81       	ldd	r22, Z+6	; 0x06
    3df0:	77 81       	ldd	r23, Z+7	; 0x07
    3df2:	eb 81       	ldd	r30, Y+3	; 0x03
    3df4:	fc 81       	ldd	r31, Y+4	; 0x04
    3df6:	84 8d       	ldd	r24, Z+28	; 0x1c
    3df8:	48 2f       	mov	r20, r24
    3dfa:	50 e0       	ldi	r21, 0x00	; 0
    3dfc:	2d 81       	ldd	r18, Y+5	; 0x05
    3dfe:	3e 81       	ldd	r19, Y+6	; 0x06
    3e00:	cb 01       	movw	r24, r22
    3e02:	b9 01       	movw	r22, r18
    3e04:	0e 94 e2 3b 	call	0x77c4	; 0x77c4 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    3e08:	eb 81       	ldd	r30, Y+3	; 0x03
    3e0a:	fc 81       	ldd	r31, Y+4	; 0x04
    3e0c:	26 81       	ldd	r18, Z+6	; 0x06
    3e0e:	37 81       	ldd	r19, Z+7	; 0x07
    3e10:	eb 81       	ldd	r30, Y+3	; 0x03
    3e12:	fc 81       	ldd	r31, Y+4	; 0x04
    3e14:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e16:	88 2f       	mov	r24, r24
    3e18:	90 e0       	ldi	r25, 0x00	; 0
    3e1a:	90 95       	com	r25
    3e1c:	81 95       	neg	r24
    3e1e:	9f 4f       	sbci	r25, 0xFF	; 255
    3e20:	82 0f       	add	r24, r18
    3e22:	93 1f       	adc	r25, r19
    3e24:	eb 81       	ldd	r30, Y+3	; 0x03
    3e26:	fc 81       	ldd	r31, Y+4	; 0x04
    3e28:	97 83       	std	Z+7, r25	; 0x07
    3e2a:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3e2c:	eb 81       	ldd	r30, Y+3	; 0x03
    3e2e:	fc 81       	ldd	r31, Y+4	; 0x04
    3e30:	26 81       	ldd	r18, Z+6	; 0x06
    3e32:	37 81       	ldd	r19, Z+7	; 0x07
    3e34:	eb 81       	ldd	r30, Y+3	; 0x03
    3e36:	fc 81       	ldd	r31, Y+4	; 0x04
    3e38:	80 81       	ld	r24, Z
    3e3a:	91 81       	ldd	r25, Z+1	; 0x01
    3e3c:	28 17       	cp	r18, r24
    3e3e:	39 07       	cpc	r19, r25
    3e40:	90 f4       	brcc	.+36     	; 0x3e66 <prvCopyDataToQueue+0x11c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    3e42:	eb 81       	ldd	r30, Y+3	; 0x03
    3e44:	fc 81       	ldd	r31, Y+4	; 0x04
    3e46:	24 81       	ldd	r18, Z+4	; 0x04
    3e48:	35 81       	ldd	r19, Z+5	; 0x05
    3e4a:	eb 81       	ldd	r30, Y+3	; 0x03
    3e4c:	fc 81       	ldd	r31, Y+4	; 0x04
    3e4e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e50:	88 2f       	mov	r24, r24
    3e52:	90 e0       	ldi	r25, 0x00	; 0
    3e54:	90 95       	com	r25
    3e56:	81 95       	neg	r24
    3e58:	9f 4f       	sbci	r25, 0xFF	; 255
    3e5a:	82 0f       	add	r24, r18
    3e5c:	93 1f       	adc	r25, r19
    3e5e:	eb 81       	ldd	r30, Y+3	; 0x03
    3e60:	fc 81       	ldd	r31, Y+4	; 0x04
    3e62:	97 83       	std	Z+7, r25	; 0x07
    3e64:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    3e66:	8f 81       	ldd	r24, Y+7	; 0x07
    3e68:	82 30       	cpi	r24, 0x02	; 2
    3e6a:	31 f4       	brne	.+12     	; 0x3e78 <prvCopyDataToQueue+0x12e>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3e6c:	89 81       	ldd	r24, Y+1	; 0x01
    3e6e:	88 23       	and	r24, r24
    3e70:	19 f0       	breq	.+6      	; 0x3e78 <prvCopyDataToQueue+0x12e>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    3e72:	89 81       	ldd	r24, Y+1	; 0x01
    3e74:	81 50       	subi	r24, 0x01	; 1
    3e76:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3e78:	89 81       	ldd	r24, Y+1	; 0x01
    3e7a:	8f 5f       	subi	r24, 0xFF	; 255
    3e7c:	eb 81       	ldd	r30, Y+3	; 0x03
    3e7e:	fc 81       	ldd	r31, Y+4	; 0x04
    3e80:	82 8f       	std	Z+26, r24	; 0x1a

    return xReturn;
    3e82:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3e84:	27 96       	adiw	r28, 0x07	; 7
    3e86:	0f b6       	in	r0, 0x3f	; 63
    3e88:	f8 94       	cli
    3e8a:	de bf       	out	0x3e, r29	; 62
    3e8c:	0f be       	out	0x3f, r0	; 63
    3e8e:	cd bf       	out	0x3d, r28	; 61
    3e90:	cf 91       	pop	r28
    3e92:	df 91       	pop	r29
    3e94:	08 95       	ret

00003e96 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    3e96:	df 93       	push	r29
    3e98:	cf 93       	push	r28
    3e9a:	00 d0       	rcall	.+0      	; 0x3e9c <prvCopyDataFromQueue+0x6>
    3e9c:	00 d0       	rcall	.+0      	; 0x3e9e <prvCopyDataFromQueue+0x8>
    3e9e:	cd b7       	in	r28, 0x3d	; 61
    3ea0:	de b7       	in	r29, 0x3e	; 62
    3ea2:	9a 83       	std	Y+2, r25	; 0x02
    3ea4:	89 83       	std	Y+1, r24	; 0x01
    3ea6:	7c 83       	std	Y+4, r23	; 0x04
    3ea8:	6b 83       	std	Y+3, r22	; 0x03
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    3eaa:	e9 81       	ldd	r30, Y+1	; 0x01
    3eac:	fa 81       	ldd	r31, Y+2	; 0x02
    3eae:	84 8d       	ldd	r24, Z+28	; 0x1c
    3eb0:	88 23       	and	r24, r24
    3eb2:	89 f1       	breq	.+98     	; 0x3f16 <prvCopyDataFromQueue+0x80>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3eb4:	e9 81       	ldd	r30, Y+1	; 0x01
    3eb6:	fa 81       	ldd	r31, Y+2	; 0x02
    3eb8:	26 81       	ldd	r18, Z+6	; 0x06
    3eba:	37 81       	ldd	r19, Z+7	; 0x07
    3ebc:	e9 81       	ldd	r30, Y+1	; 0x01
    3ebe:	fa 81       	ldd	r31, Y+2	; 0x02
    3ec0:	84 8d       	ldd	r24, Z+28	; 0x1c
    3ec2:	88 2f       	mov	r24, r24
    3ec4:	90 e0       	ldi	r25, 0x00	; 0
    3ec6:	82 0f       	add	r24, r18
    3ec8:	93 1f       	adc	r25, r19
    3eca:	e9 81       	ldd	r30, Y+1	; 0x01
    3ecc:	fa 81       	ldd	r31, Y+2	; 0x02
    3ece:	97 83       	std	Z+7, r25	; 0x07
    3ed0:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3ed2:	e9 81       	ldd	r30, Y+1	; 0x01
    3ed4:	fa 81       	ldd	r31, Y+2	; 0x02
    3ed6:	26 81       	ldd	r18, Z+6	; 0x06
    3ed8:	37 81       	ldd	r19, Z+7	; 0x07
    3eda:	e9 81       	ldd	r30, Y+1	; 0x01
    3edc:	fa 81       	ldd	r31, Y+2	; 0x02
    3ede:	84 81       	ldd	r24, Z+4	; 0x04
    3ee0:	95 81       	ldd	r25, Z+5	; 0x05
    3ee2:	28 17       	cp	r18, r24
    3ee4:	39 07       	cpc	r19, r25
    3ee6:	40 f0       	brcs	.+16     	; 0x3ef8 <prvCopyDataFromQueue+0x62>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    3ee8:	e9 81       	ldd	r30, Y+1	; 0x01
    3eea:	fa 81       	ldd	r31, Y+2	; 0x02
    3eec:	80 81       	ld	r24, Z
    3eee:	91 81       	ldd	r25, Z+1	; 0x01
    3ef0:	e9 81       	ldd	r30, Y+1	; 0x01
    3ef2:	fa 81       	ldd	r31, Y+2	; 0x02
    3ef4:	97 83       	std	Z+7, r25	; 0x07
    3ef6:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3ef8:	e9 81       	ldd	r30, Y+1	; 0x01
    3efa:	fa 81       	ldd	r31, Y+2	; 0x02
    3efc:	46 81       	ldd	r20, Z+6	; 0x06
    3efe:	57 81       	ldd	r21, Z+7	; 0x07
    3f00:	e9 81       	ldd	r30, Y+1	; 0x01
    3f02:	fa 81       	ldd	r31, Y+2	; 0x02
    3f04:	84 8d       	ldd	r24, Z+28	; 0x1c
    3f06:	28 2f       	mov	r18, r24
    3f08:	30 e0       	ldi	r19, 0x00	; 0
    3f0a:	8b 81       	ldd	r24, Y+3	; 0x03
    3f0c:	9c 81       	ldd	r25, Y+4	; 0x04
    3f0e:	ba 01       	movw	r22, r20
    3f10:	a9 01       	movw	r20, r18
    3f12:	0e 94 e2 3b 	call	0x77c4	; 0x77c4 <memcpy>
    }
}
    3f16:	0f 90       	pop	r0
    3f18:	0f 90       	pop	r0
    3f1a:	0f 90       	pop	r0
    3f1c:	0f 90       	pop	r0
    3f1e:	cf 91       	pop	r28
    3f20:	df 91       	pop	r29
    3f22:	08 95       	ret

00003f24 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    3f24:	df 93       	push	r29
    3f26:	cf 93       	push	r28
    3f28:	00 d0       	rcall	.+0      	; 0x3f2a <prvUnlockQueue+0x6>
    3f2a:	00 d0       	rcall	.+0      	; 0x3f2c <prvUnlockQueue+0x8>
    3f2c:	cd b7       	in	r28, 0x3d	; 61
    3f2e:	de b7       	in	r29, 0x3e	; 62
    3f30:	9c 83       	std	Y+4, r25	; 0x04
    3f32:	8b 83       	std	Y+3, r24	; 0x03

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    3f34:	0f b6       	in	r0, 0x3f	; 63
    3f36:	f8 94       	cli
    3f38:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    3f3a:	eb 81       	ldd	r30, Y+3	; 0x03
    3f3c:	fc 81       	ldd	r31, Y+4	; 0x04
    3f3e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3f40:	8a 83       	std	Y+2, r24	; 0x02
    3f42:	11 c0       	rjmp	.+34     	; 0x3f66 <prvUnlockQueue+0x42>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3f44:	eb 81       	ldd	r30, Y+3	; 0x03
    3f46:	fc 81       	ldd	r31, Y+4	; 0x04
    3f48:	81 89       	ldd	r24, Z+17	; 0x11
    3f4a:	88 23       	and	r24, r24
    3f4c:	79 f0       	breq	.+30     	; 0x3f6c <prvUnlockQueue+0x48>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3f4e:	8b 81       	ldd	r24, Y+3	; 0x03
    3f50:	9c 81       	ldd	r25, Y+4	; 0x04
    3f52:	41 96       	adiw	r24, 0x11	; 17
    3f54:	0e 94 62 2a 	call	0x54c4	; 0x54c4 <xTaskRemoveFromEventList>
    3f58:	88 23       	and	r24, r24
    3f5a:	11 f0       	breq	.+4      	; 0x3f60 <prvUnlockQueue+0x3c>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
    3f5c:	0e 94 52 2d 	call	0x5aa4	; 0x5aa4 <vTaskMissedYield>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    3f60:	8a 81       	ldd	r24, Y+2	; 0x02
    3f62:	81 50       	subi	r24, 0x01	; 1
    3f64:	8a 83       	std	Y+2, r24	; 0x02
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    3f66:	8a 81       	ldd	r24, Y+2	; 0x02
    3f68:	18 16       	cp	r1, r24
    3f6a:	64 f3       	brlt	.-40     	; 0x3f44 <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    3f6c:	eb 81       	ldd	r30, Y+3	; 0x03
    3f6e:	fc 81       	ldd	r31, Y+4	; 0x04
    3f70:	8f ef       	ldi	r24, 0xFF	; 255
    3f72:	86 8f       	std	Z+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    3f74:	0f 90       	pop	r0
    3f76:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    3f78:	0f b6       	in	r0, 0x3f	; 63
    3f7a:	f8 94       	cli
    3f7c:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    3f7e:	eb 81       	ldd	r30, Y+3	; 0x03
    3f80:	fc 81       	ldd	r31, Y+4	; 0x04
    3f82:	85 8d       	ldd	r24, Z+29	; 0x1d
    3f84:	89 83       	std	Y+1, r24	; 0x01
    3f86:	11 c0       	rjmp	.+34     	; 0x3faa <prvUnlockQueue+0x86>

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3f88:	eb 81       	ldd	r30, Y+3	; 0x03
    3f8a:	fc 81       	ldd	r31, Y+4	; 0x04
    3f8c:	80 85       	ldd	r24, Z+8	; 0x08
    3f8e:	88 23       	and	r24, r24
    3f90:	79 f0       	breq	.+30     	; 0x3fb0 <prvUnlockQueue+0x8c>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3f92:	8b 81       	ldd	r24, Y+3	; 0x03
    3f94:	9c 81       	ldd	r25, Y+4	; 0x04
    3f96:	08 96       	adiw	r24, 0x08	; 8
    3f98:	0e 94 62 2a 	call	0x54c4	; 0x54c4 <xTaskRemoveFromEventList>
    3f9c:	88 23       	and	r24, r24
    3f9e:	11 f0       	breq	.+4      	; 0x3fa4 <prvUnlockQueue+0x80>
                {
                    vTaskMissedYield();
    3fa0:	0e 94 52 2d 	call	0x5aa4	; 0x5aa4 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    3fa4:	89 81       	ldd	r24, Y+1	; 0x01
    3fa6:	81 50       	subi	r24, 0x01	; 1
    3fa8:	89 83       	std	Y+1, r24	; 0x01
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    3faa:	89 81       	ldd	r24, Y+1	; 0x01
    3fac:	18 16       	cp	r1, r24
    3fae:	64 f3       	brlt	.-40     	; 0x3f88 <prvUnlockQueue+0x64>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    3fb0:	eb 81       	ldd	r30, Y+3	; 0x03
    3fb2:	fc 81       	ldd	r31, Y+4	; 0x04
    3fb4:	8f ef       	ldi	r24, 0xFF	; 255
    3fb6:	85 8f       	std	Z+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    3fb8:	0f 90       	pop	r0
    3fba:	0f be       	out	0x3f, r0	; 63
}
    3fbc:	0f 90       	pop	r0
    3fbe:	0f 90       	pop	r0
    3fc0:	0f 90       	pop	r0
    3fc2:	0f 90       	pop	r0
    3fc4:	cf 91       	pop	r28
    3fc6:	df 91       	pop	r29
    3fc8:	08 95       	ret

00003fca <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    3fca:	df 93       	push	r29
    3fcc:	cf 93       	push	r28
    3fce:	00 d0       	rcall	.+0      	; 0x3fd0 <prvIsQueueEmpty+0x6>
    3fd0:	0f 92       	push	r0
    3fd2:	cd b7       	in	r28, 0x3d	; 61
    3fd4:	de b7       	in	r29, 0x3e	; 62
    3fd6:	9b 83       	std	Y+3, r25	; 0x03
    3fd8:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    3fda:	0f b6       	in	r0, 0x3f	; 63
    3fdc:	f8 94       	cli
    3fde:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3fe0:	ea 81       	ldd	r30, Y+2	; 0x02
    3fe2:	fb 81       	ldd	r31, Y+3	; 0x03
    3fe4:	82 8d       	ldd	r24, Z+26	; 0x1a
    3fe6:	88 23       	and	r24, r24
    3fe8:	19 f4       	brne	.+6      	; 0x3ff0 <prvIsQueueEmpty+0x26>
        {
            xReturn = pdTRUE;
    3fea:	81 e0       	ldi	r24, 0x01	; 1
    3fec:	89 83       	std	Y+1, r24	; 0x01
    3fee:	01 c0       	rjmp	.+2      	; 0x3ff2 <prvIsQueueEmpty+0x28>
        }
        else
        {
            xReturn = pdFALSE;
    3ff0:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    3ff2:	0f 90       	pop	r0
    3ff4:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    3ff6:	89 81       	ldd	r24, Y+1	; 0x01
}
    3ff8:	0f 90       	pop	r0
    3ffa:	0f 90       	pop	r0
    3ffc:	0f 90       	pop	r0
    3ffe:	cf 91       	pop	r28
    4000:	df 91       	pop	r29
    4002:	08 95       	ret

00004004 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    4004:	df 93       	push	r29
    4006:	cf 93       	push	r28
    4008:	00 d0       	rcall	.+0      	; 0x400a <xQueueIsQueueEmptyFromISR+0x6>
    400a:	00 d0       	rcall	.+0      	; 0x400c <xQueueIsQueueEmptyFromISR+0x8>
    400c:	0f 92       	push	r0
    400e:	cd b7       	in	r28, 0x3d	; 61
    4010:	de b7       	in	r29, 0x3e	; 62
    4012:	9d 83       	std	Y+5, r25	; 0x05
    4014:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    4016:	8c 81       	ldd	r24, Y+4	; 0x04
    4018:	9d 81       	ldd	r25, Y+5	; 0x05
    401a:	9a 83       	std	Y+2, r25	; 0x02
    401c:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    401e:	e9 81       	ldd	r30, Y+1	; 0x01
    4020:	fa 81       	ldd	r31, Y+2	; 0x02
    4022:	82 8d       	ldd	r24, Z+26	; 0x1a
    4024:	88 23       	and	r24, r24
    4026:	19 f4       	brne	.+6      	; 0x402e <xQueueIsQueueEmptyFromISR+0x2a>
    {
        xReturn = pdTRUE;
    4028:	81 e0       	ldi	r24, 0x01	; 1
    402a:	8b 83       	std	Y+3, r24	; 0x03
    402c:	01 c0       	rjmp	.+2      	; 0x4030 <xQueueIsQueueEmptyFromISR+0x2c>
    }
    else
    {
        xReturn = pdFALSE;
    402e:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    4030:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    4032:	0f 90       	pop	r0
    4034:	0f 90       	pop	r0
    4036:	0f 90       	pop	r0
    4038:	0f 90       	pop	r0
    403a:	0f 90       	pop	r0
    403c:	cf 91       	pop	r28
    403e:	df 91       	pop	r29
    4040:	08 95       	ret

00004042 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    4042:	df 93       	push	r29
    4044:	cf 93       	push	r28
    4046:	00 d0       	rcall	.+0      	; 0x4048 <prvIsQueueFull+0x6>
    4048:	0f 92       	push	r0
    404a:	cd b7       	in	r28, 0x3d	; 61
    404c:	de b7       	in	r29, 0x3e	; 62
    404e:	9b 83       	std	Y+3, r25	; 0x03
    4050:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    4052:	0f b6       	in	r0, 0x3f	; 63
    4054:	f8 94       	cli
    4056:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    4058:	ea 81       	ldd	r30, Y+2	; 0x02
    405a:	fb 81       	ldd	r31, Y+3	; 0x03
    405c:	92 8d       	ldd	r25, Z+26	; 0x1a
    405e:	ea 81       	ldd	r30, Y+2	; 0x02
    4060:	fb 81       	ldd	r31, Y+3	; 0x03
    4062:	83 8d       	ldd	r24, Z+27	; 0x1b
    4064:	98 17       	cp	r25, r24
    4066:	19 f4       	brne	.+6      	; 0x406e <prvIsQueueFull+0x2c>
        {
            xReturn = pdTRUE;
    4068:	81 e0       	ldi	r24, 0x01	; 1
    406a:	89 83       	std	Y+1, r24	; 0x01
    406c:	01 c0       	rjmp	.+2      	; 0x4070 <prvIsQueueFull+0x2e>
        }
        else
        {
            xReturn = pdFALSE;
    406e:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    4070:	0f 90       	pop	r0
    4072:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    4074:	89 81       	ldd	r24, Y+1	; 0x01
}
    4076:	0f 90       	pop	r0
    4078:	0f 90       	pop	r0
    407a:	0f 90       	pop	r0
    407c:	cf 91       	pop	r28
    407e:	df 91       	pop	r29
    4080:	08 95       	ret

00004082 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    4082:	df 93       	push	r29
    4084:	cf 93       	push	r28
    4086:	00 d0       	rcall	.+0      	; 0x4088 <xQueueIsQueueFullFromISR+0x6>
    4088:	00 d0       	rcall	.+0      	; 0x408a <xQueueIsQueueFullFromISR+0x8>
    408a:	0f 92       	push	r0
    408c:	cd b7       	in	r28, 0x3d	; 61
    408e:	de b7       	in	r29, 0x3e	; 62
    4090:	9d 83       	std	Y+5, r25	; 0x05
    4092:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    4094:	8c 81       	ldd	r24, Y+4	; 0x04
    4096:	9d 81       	ldd	r25, Y+5	; 0x05
    4098:	9a 83       	std	Y+2, r25	; 0x02
    409a:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    409c:	e9 81       	ldd	r30, Y+1	; 0x01
    409e:	fa 81       	ldd	r31, Y+2	; 0x02
    40a0:	92 8d       	ldd	r25, Z+26	; 0x1a
    40a2:	e9 81       	ldd	r30, Y+1	; 0x01
    40a4:	fa 81       	ldd	r31, Y+2	; 0x02
    40a6:	83 8d       	ldd	r24, Z+27	; 0x1b
    40a8:	98 17       	cp	r25, r24
    40aa:	19 f4       	brne	.+6      	; 0x40b2 <xQueueIsQueueFullFromISR+0x30>
    {
        xReturn = pdTRUE;
    40ac:	81 e0       	ldi	r24, 0x01	; 1
    40ae:	8b 83       	std	Y+3, r24	; 0x03
    40b0:	01 c0       	rjmp	.+2      	; 0x40b4 <xQueueIsQueueFullFromISR+0x32>
    }
    else
    {
        xReturn = pdFALSE;
    40b2:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    40b4:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    40b6:	0f 90       	pop	r0
    40b8:	0f 90       	pop	r0
    40ba:	0f 90       	pop	r0
    40bc:	0f 90       	pop	r0
    40be:	0f 90       	pop	r0
    40c0:	cf 91       	pop	r28
    40c2:	df 91       	pop	r29
    40c4:	08 95       	ret

000040c6 <xQueueCRSend>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSend( QueueHandle_t xQueue,
                             const void * pvItemToQueue,
                             TickType_t xTicksToWait )
    {
    40c6:	df 93       	push	r29
    40c8:	cf 93       	push	r28
    40ca:	cd b7       	in	r28, 0x3d	; 61
    40cc:	de b7       	in	r29, 0x3e	; 62
    40ce:	2a 97       	sbiw	r28, 0x0a	; 10
    40d0:	0f b6       	in	r0, 0x3f	; 63
    40d2:	f8 94       	cli
    40d4:	de bf       	out	0x3e, r29	; 62
    40d6:	0f be       	out	0x3f, r0	; 63
    40d8:	cd bf       	out	0x3d, r28	; 61
    40da:	9d 83       	std	Y+5, r25	; 0x05
    40dc:	8c 83       	std	Y+4, r24	; 0x04
    40de:	7f 83       	std	Y+7, r23	; 0x07
    40e0:	6e 83       	std	Y+6, r22	; 0x06
    40e2:	59 87       	std	Y+9, r21	; 0x09
    40e4:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    40e6:	8c 81       	ldd	r24, Y+4	; 0x04
    40e8:	9d 81       	ldd	r25, Y+5	; 0x05
    40ea:	9a 83       	std	Y+2, r25	; 0x02
    40ec:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already full we may have to block.  A critical section
         * is required to prevent an interrupt removing something from the queue
         * between the check to see if the queue is full and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    40ee:	f8 94       	cli
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    40f0:	89 81       	ldd	r24, Y+1	; 0x01
    40f2:	9a 81       	ldd	r25, Y+2	; 0x02
    40f4:	0e 94 21 20 	call	0x4042	; 0x4042 <prvIsQueueFull>
    40f8:	88 23       	and	r24, r24
    40fa:	a9 f0       	breq	.+42     	; 0x4126 <xQueueCRSend+0x60>
            {
                /* The queue is full - do we want to block or just leave without
                 * posting? */
                if( xTicksToWait > ( TickType_t ) 0 )
    40fc:	88 85       	ldd	r24, Y+8	; 0x08
    40fe:	99 85       	ldd	r25, Y+9	; 0x09
    4100:	00 97       	sbiw	r24, 0x00	; 0
    4102:	71 f0       	breq	.+28     	; 0x4120 <xQueueCRSend+0x5a>
                {
                    /* As this is called from a coroutine we cannot block directly, but
                     * return indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    4104:	89 81       	ldd	r24, Y+1	; 0x01
    4106:	9a 81       	ldd	r25, Y+2	; 0x02
    4108:	9c 01       	movw	r18, r24
    410a:	28 5f       	subi	r18, 0xF8	; 248
    410c:	3f 4f       	sbci	r19, 0xFF	; 255
    410e:	88 85       	ldd	r24, Y+8	; 0x08
    4110:	99 85       	ldd	r25, Y+9	; 0x09
    4112:	b9 01       	movw	r22, r18
    4114:	0e 94 2f 12 	call	0x245e	; 0x245e <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    4118:	78 94       	sei
                    return errQUEUE_BLOCKED;
    411a:	8c ef       	ldi	r24, 0xFC	; 252
    411c:	8a 87       	std	Y+10, r24	; 0x0a
    411e:	2a c0       	rjmp	.+84     	; 0x4174 <xQueueCRSend+0xae>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    4120:	78 94       	sei
                    return errQUEUE_FULL;
    4122:	1a 86       	std	Y+10, r1	; 0x0a
    4124:	27 c0       	rjmp	.+78     	; 0x4174 <xQueueCRSend+0xae>
                }
            }
        }
        portENABLE_INTERRUPTS();
    4126:	78 94       	sei

        portDISABLE_INTERRUPTS();
    4128:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    412a:	e9 81       	ldd	r30, Y+1	; 0x01
    412c:	fa 81       	ldd	r31, Y+2	; 0x02
    412e:	92 8d       	ldd	r25, Z+26	; 0x1a
    4130:	e9 81       	ldd	r30, Y+1	; 0x01
    4132:	fa 81       	ldd	r31, Y+2	; 0x02
    4134:	83 8d       	ldd	r24, Z+27	; 0x1b
    4136:	98 17       	cp	r25, r24
    4138:	c8 f4       	brcc	.+50     	; 0x416c <xQueueCRSend+0xa6>
            {
                /* There is room in the queue, copy the data into the queue. */
                prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    413a:	89 81       	ldd	r24, Y+1	; 0x01
    413c:	9a 81       	ldd	r25, Y+2	; 0x02
    413e:	2e 81       	ldd	r18, Y+6	; 0x06
    4140:	3f 81       	ldd	r19, Y+7	; 0x07
    4142:	b9 01       	movw	r22, r18
    4144:	40 e0       	ldi	r20, 0x00	; 0
    4146:	0e 94 a5 1e 	call	0x3d4a	; 0x3d4a <prvCopyDataToQueue>
                xReturn = pdPASS;
    414a:	81 e0       	ldi	r24, 0x01	; 1
    414c:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for data to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    414e:	e9 81       	ldd	r30, Y+1	; 0x01
    4150:	fa 81       	ldd	r31, Y+2	; 0x02
    4152:	81 89       	ldd	r24, Z+17	; 0x11
    4154:	88 23       	and	r24, r24
    4156:	59 f0       	breq	.+22     	; 0x416e <xQueueCRSend+0xa8>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4158:	89 81       	ldd	r24, Y+1	; 0x01
    415a:	9a 81       	ldd	r25, Y+2	; 0x02
    415c:	41 96       	adiw	r24, 0x11	; 17
    415e:	0e 94 42 14 	call	0x2884	; 0x2884 <xCoRoutineRemoveFromEventList>
    4162:	88 23       	and	r24, r24
    4164:	21 f0       	breq	.+8      	; 0x416e <xQueueCRSend+0xa8>
                    {
                        /* The co-routine waiting has a higher priority so record
                         * that a yield might be appropriate. */
                        xReturn = errQUEUE_YIELD;
    4166:	8b ef       	ldi	r24, 0xFB	; 251
    4168:	8b 83       	std	Y+3, r24	; 0x03
    416a:	01 c0       	rjmp	.+2      	; 0x416e <xQueueCRSend+0xa8>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = errQUEUE_FULL;
    416c:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    416e:	78 94       	sei

        return xReturn;
    4170:	8b 81       	ldd	r24, Y+3	; 0x03
    4172:	8a 87       	std	Y+10, r24	; 0x0a
    4174:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    4176:	2a 96       	adiw	r28, 0x0a	; 10
    4178:	0f b6       	in	r0, 0x3f	; 63
    417a:	f8 94       	cli
    417c:	de bf       	out	0x3e, r29	; 62
    417e:	0f be       	out	0x3f, r0	; 63
    4180:	cd bf       	out	0x3d, r28	; 61
    4182:	cf 91       	pop	r28
    4184:	df 91       	pop	r29
    4186:	08 95       	ret

00004188 <xQueueCRReceive>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceive( QueueHandle_t xQueue,
                                void * pvBuffer,
                                TickType_t xTicksToWait )
    {
    4188:	df 93       	push	r29
    418a:	cf 93       	push	r28
    418c:	cd b7       	in	r28, 0x3d	; 61
    418e:	de b7       	in	r29, 0x3e	; 62
    4190:	2a 97       	sbiw	r28, 0x0a	; 10
    4192:	0f b6       	in	r0, 0x3f	; 63
    4194:	f8 94       	cli
    4196:	de bf       	out	0x3e, r29	; 62
    4198:	0f be       	out	0x3f, r0	; 63
    419a:	cd bf       	out	0x3d, r28	; 61
    419c:	9d 83       	std	Y+5, r25	; 0x05
    419e:	8c 83       	std	Y+4, r24	; 0x04
    41a0:	7f 83       	std	Y+7, r23	; 0x07
    41a2:	6e 83       	std	Y+6, r22	; 0x06
    41a4:	59 87       	std	Y+9, r21	; 0x09
    41a6:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    41a8:	8c 81       	ldd	r24, Y+4	; 0x04
    41aa:	9d 81       	ldd	r25, Y+5	; 0x05
    41ac:	9a 83       	std	Y+2, r25	; 0x02
    41ae:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already empty we may have to block.  A critical section
         * is required to prevent an interrupt adding something to the queue
         * between the check to see if the queue is empty and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    41b0:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    41b2:	e9 81       	ldd	r30, Y+1	; 0x01
    41b4:	fa 81       	ldd	r31, Y+2	; 0x02
    41b6:	82 8d       	ldd	r24, Z+26	; 0x1a
    41b8:	88 23       	and	r24, r24
    41ba:	a9 f4       	brne	.+42     	; 0x41e6 <xQueueCRReceive+0x5e>
            {
                /* There are no messages in the queue, do we want to block or just
                 * leave with nothing? */
                if( xTicksToWait > ( TickType_t ) 0 )
    41bc:	88 85       	ldd	r24, Y+8	; 0x08
    41be:	99 85       	ldd	r25, Y+9	; 0x09
    41c0:	00 97       	sbiw	r24, 0x00	; 0
    41c2:	71 f0       	breq	.+28     	; 0x41e0 <xQueueCRReceive+0x58>
                {
                    /* As this is a co-routine we cannot block directly, but return
                     * indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    41c4:	89 81       	ldd	r24, Y+1	; 0x01
    41c6:	9a 81       	ldd	r25, Y+2	; 0x02
    41c8:	9c 01       	movw	r18, r24
    41ca:	2f 5e       	subi	r18, 0xEF	; 239
    41cc:	3f 4f       	sbci	r19, 0xFF	; 255
    41ce:	88 85       	ldd	r24, Y+8	; 0x08
    41d0:	99 85       	ldd	r25, Y+9	; 0x09
    41d2:	b9 01       	movw	r22, r18
    41d4:	0e 94 2f 12 	call	0x245e	; 0x245e <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    41d8:	78 94       	sei
                    return errQUEUE_BLOCKED;
    41da:	8c ef       	ldi	r24, 0xFC	; 252
    41dc:	8a 87       	std	Y+10, r24	; 0x0a
    41de:	58 c0       	rjmp	.+176    	; 0x4290 <xQueueCRReceive+0x108>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    41e0:	78 94       	sei
                    return errQUEUE_FULL;
    41e2:	1a 86       	std	Y+10, r1	; 0x0a
    41e4:	55 c0       	rjmp	.+170    	; 0x4290 <xQueueCRReceive+0x108>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portENABLE_INTERRUPTS();
    41e6:	78 94       	sei

        portDISABLE_INTERRUPTS();
    41e8:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    41ea:	e9 81       	ldd	r30, Y+1	; 0x01
    41ec:	fa 81       	ldd	r31, Y+2	; 0x02
    41ee:	82 8d       	ldd	r24, Z+26	; 0x1a
    41f0:	88 23       	and	r24, r24
    41f2:	09 f4       	brne	.+2      	; 0x41f6 <xQueueCRReceive+0x6e>
    41f4:	49 c0       	rjmp	.+146    	; 0x4288 <xQueueCRReceive+0x100>
            {
                /* Data is available from the queue. */
                pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    41f6:	e9 81       	ldd	r30, Y+1	; 0x01
    41f8:	fa 81       	ldd	r31, Y+2	; 0x02
    41fa:	26 81       	ldd	r18, Z+6	; 0x06
    41fc:	37 81       	ldd	r19, Z+7	; 0x07
    41fe:	e9 81       	ldd	r30, Y+1	; 0x01
    4200:	fa 81       	ldd	r31, Y+2	; 0x02
    4202:	84 8d       	ldd	r24, Z+28	; 0x1c
    4204:	88 2f       	mov	r24, r24
    4206:	90 e0       	ldi	r25, 0x00	; 0
    4208:	82 0f       	add	r24, r18
    420a:	93 1f       	adc	r25, r19
    420c:	e9 81       	ldd	r30, Y+1	; 0x01
    420e:	fa 81       	ldd	r31, Y+2	; 0x02
    4210:	97 83       	std	Z+7, r25	; 0x07
    4212:	86 83       	std	Z+6, r24	; 0x06

                if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    4214:	e9 81       	ldd	r30, Y+1	; 0x01
    4216:	fa 81       	ldd	r31, Y+2	; 0x02
    4218:	26 81       	ldd	r18, Z+6	; 0x06
    421a:	37 81       	ldd	r19, Z+7	; 0x07
    421c:	e9 81       	ldd	r30, Y+1	; 0x01
    421e:	fa 81       	ldd	r31, Y+2	; 0x02
    4220:	84 81       	ldd	r24, Z+4	; 0x04
    4222:	95 81       	ldd	r25, Z+5	; 0x05
    4224:	28 17       	cp	r18, r24
    4226:	39 07       	cpc	r19, r25
    4228:	40 f0       	brcs	.+16     	; 0x423a <xQueueCRReceive+0xb2>
                {
                    pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    422a:	e9 81       	ldd	r30, Y+1	; 0x01
    422c:	fa 81       	ldd	r31, Y+2	; 0x02
    422e:	80 81       	ld	r24, Z
    4230:	91 81       	ldd	r25, Z+1	; 0x01
    4232:	e9 81       	ldd	r30, Y+1	; 0x01
    4234:	fa 81       	ldd	r31, Y+2	; 0x02
    4236:	97 83       	std	Z+7, r25	; 0x07
    4238:	86 83       	std	Z+6, r24	; 0x06
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --( pxQueue->uxMessagesWaiting );
    423a:	e9 81       	ldd	r30, Y+1	; 0x01
    423c:	fa 81       	ldd	r31, Y+2	; 0x02
    423e:	82 8d       	ldd	r24, Z+26	; 0x1a
    4240:	81 50       	subi	r24, 0x01	; 1
    4242:	e9 81       	ldd	r30, Y+1	; 0x01
    4244:	fa 81       	ldd	r31, Y+2	; 0x02
    4246:	82 8f       	std	Z+26, r24	; 0x1a
                ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    4248:	e9 81       	ldd	r30, Y+1	; 0x01
    424a:	fa 81       	ldd	r31, Y+2	; 0x02
    424c:	46 81       	ldd	r20, Z+6	; 0x06
    424e:	57 81       	ldd	r21, Z+7	; 0x07
    4250:	e9 81       	ldd	r30, Y+1	; 0x01
    4252:	fa 81       	ldd	r31, Y+2	; 0x02
    4254:	84 8d       	ldd	r24, Z+28	; 0x1c
    4256:	28 2f       	mov	r18, r24
    4258:	30 e0       	ldi	r19, 0x00	; 0
    425a:	8e 81       	ldd	r24, Y+6	; 0x06
    425c:	9f 81       	ldd	r25, Y+7	; 0x07
    425e:	ba 01       	movw	r22, r20
    4260:	a9 01       	movw	r20, r18
    4262:	0e 94 e2 3b 	call	0x77c4	; 0x77c4 <memcpy>

                xReturn = pdPASS;
    4266:	81 e0       	ldi	r24, 0x01	; 1
    4268:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for space to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    426a:	e9 81       	ldd	r30, Y+1	; 0x01
    426c:	fa 81       	ldd	r31, Y+2	; 0x02
    426e:	80 85       	ldd	r24, Z+8	; 0x08
    4270:	88 23       	and	r24, r24
    4272:	59 f0       	breq	.+22     	; 0x428a <xQueueCRReceive+0x102>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4274:	89 81       	ldd	r24, Y+1	; 0x01
    4276:	9a 81       	ldd	r25, Y+2	; 0x02
    4278:	08 96       	adiw	r24, 0x08	; 8
    427a:	0e 94 42 14 	call	0x2884	; 0x2884 <xCoRoutineRemoveFromEventList>
    427e:	88 23       	and	r24, r24
    4280:	21 f0       	breq	.+8      	; 0x428a <xQueueCRReceive+0x102>
                    {
                        xReturn = errQUEUE_YIELD;
    4282:	8b ef       	ldi	r24, 0xFB	; 251
    4284:	8b 83       	std	Y+3, r24	; 0x03
    4286:	01 c0       	rjmp	.+2      	; 0x428a <xQueueCRReceive+0x102>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = pdFAIL;
    4288:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    428a:	78 94       	sei

        return xReturn;
    428c:	8b 81       	ldd	r24, Y+3	; 0x03
    428e:	8a 87       	std	Y+10, r24	; 0x0a
    4290:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    4292:	2a 96       	adiw	r28, 0x0a	; 10
    4294:	0f b6       	in	r0, 0x3f	; 63
    4296:	f8 94       	cli
    4298:	de bf       	out	0x3e, r29	; 62
    429a:	0f be       	out	0x3f, r0	; 63
    429c:	cd bf       	out	0x3d, r28	; 61
    429e:	cf 91       	pop	r28
    42a0:	df 91       	pop	r29
    42a2:	08 95       	ret

000042a4 <xQueueCRSendFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,
                                    const void * pvItemToQueue,
                                    BaseType_t xCoRoutinePreviouslyWoken )
    {
    42a4:	df 93       	push	r29
    42a6:	cf 93       	push	r28
    42a8:	cd b7       	in	r28, 0x3d	; 61
    42aa:	de b7       	in	r29, 0x3e	; 62
    42ac:	28 97       	sbiw	r28, 0x08	; 8
    42ae:	0f b6       	in	r0, 0x3f	; 63
    42b0:	f8 94       	cli
    42b2:	de bf       	out	0x3e, r29	; 62
    42b4:	0f be       	out	0x3f, r0	; 63
    42b6:	cd bf       	out	0x3d, r28	; 61
    42b8:	9c 83       	std	Y+4, r25	; 0x04
    42ba:	8b 83       	std	Y+3, r24	; 0x03
    42bc:	7e 83       	std	Y+6, r23	; 0x06
    42be:	6d 83       	std	Y+5, r22	; 0x05
    42c0:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    42c2:	8b 81       	ldd	r24, Y+3	; 0x03
    42c4:	9c 81       	ldd	r25, Y+4	; 0x04
    42c6:	9a 83       	std	Y+2, r25	; 0x02
    42c8:	89 83       	std	Y+1, r24	; 0x01

        /* Cannot block within an ISR so if there is no space on the queue then
         * exit without doing anything. */
        if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    42ca:	e9 81       	ldd	r30, Y+1	; 0x01
    42cc:	fa 81       	ldd	r31, Y+2	; 0x02
    42ce:	92 8d       	ldd	r25, Z+26	; 0x1a
    42d0:	e9 81       	ldd	r30, Y+1	; 0x01
    42d2:	fa 81       	ldd	r31, Y+2	; 0x02
    42d4:	83 8d       	ldd	r24, Z+27	; 0x1b
    42d6:	98 17       	cp	r25, r24
    42d8:	d0 f4       	brcc	.+52     	; 0x430e <xQueueCRSendFromISR+0x6a>
        {
            prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    42da:	89 81       	ldd	r24, Y+1	; 0x01
    42dc:	9a 81       	ldd	r25, Y+2	; 0x02
    42de:	2d 81       	ldd	r18, Y+5	; 0x05
    42e0:	3e 81       	ldd	r19, Y+6	; 0x06
    42e2:	b9 01       	movw	r22, r18
    42e4:	40 e0       	ldi	r20, 0x00	; 0
    42e6:	0e 94 a5 1e 	call	0x3d4a	; 0x3d4a <prvCopyDataToQueue>

            /* We only want to wake one co-routine per ISR, so check that a
             * co-routine has not already been woken. */
            if( xCoRoutinePreviouslyWoken == pdFALSE )
    42ea:	8f 81       	ldd	r24, Y+7	; 0x07
    42ec:	88 23       	and	r24, r24
    42ee:	79 f4       	brne	.+30     	; 0x430e <xQueueCRSendFromISR+0x6a>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    42f0:	e9 81       	ldd	r30, Y+1	; 0x01
    42f2:	fa 81       	ldd	r31, Y+2	; 0x02
    42f4:	81 89       	ldd	r24, Z+17	; 0x11
    42f6:	88 23       	and	r24, r24
    42f8:	51 f0       	breq	.+20     	; 0x430e <xQueueCRSendFromISR+0x6a>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    42fa:	89 81       	ldd	r24, Y+1	; 0x01
    42fc:	9a 81       	ldd	r25, Y+2	; 0x02
    42fe:	41 96       	adiw	r24, 0x11	; 17
    4300:	0e 94 42 14 	call	0x2884	; 0x2884 <xCoRoutineRemoveFromEventList>
    4304:	88 23       	and	r24, r24
    4306:	19 f0       	breq	.+6      	; 0x430e <xQueueCRSendFromISR+0x6a>
                    {
                        return pdTRUE;
    4308:	81 e0       	ldi	r24, 0x01	; 1
    430a:	88 87       	std	Y+8, r24	; 0x08
    430c:	02 c0       	rjmp	.+4      	; 0x4312 <xQueueCRSendFromISR+0x6e>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xCoRoutinePreviouslyWoken;
    430e:	8f 81       	ldd	r24, Y+7	; 0x07
    4310:	88 87       	std	Y+8, r24	; 0x08
    4312:	88 85       	ldd	r24, Y+8	; 0x08
    }
    4314:	28 96       	adiw	r28, 0x08	; 8
    4316:	0f b6       	in	r0, 0x3f	; 63
    4318:	f8 94       	cli
    431a:	de bf       	out	0x3e, r29	; 62
    431c:	0f be       	out	0x3f, r0	; 63
    431e:	cd bf       	out	0x3d, r28	; 61
    4320:	cf 91       	pop	r28
    4322:	df 91       	pop	r29
    4324:	08 95       	ret

00004326 <xQueueCRReceiveFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,
                                       void * pvBuffer,
                                       BaseType_t * pxCoRoutineWoken )
    {
    4326:	df 93       	push	r29
    4328:	cf 93       	push	r28
    432a:	cd b7       	in	r28, 0x3d	; 61
    432c:	de b7       	in	r29, 0x3e	; 62
    432e:	29 97       	sbiw	r28, 0x09	; 9
    4330:	0f b6       	in	r0, 0x3f	; 63
    4332:	f8 94       	cli
    4334:	de bf       	out	0x3e, r29	; 62
    4336:	0f be       	out	0x3f, r0	; 63
    4338:	cd bf       	out	0x3d, r28	; 61
    433a:	9d 83       	std	Y+5, r25	; 0x05
    433c:	8c 83       	std	Y+4, r24	; 0x04
    433e:	7f 83       	std	Y+7, r23	; 0x07
    4340:	6e 83       	std	Y+6, r22	; 0x06
    4342:	59 87       	std	Y+9, r21	; 0x09
    4344:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    4346:	8c 81       	ldd	r24, Y+4	; 0x04
    4348:	9d 81       	ldd	r25, Y+5	; 0x05
    434a:	9a 83       	std	Y+2, r25	; 0x02
    434c:	89 83       	std	Y+1, r24	; 0x01

        /* We cannot block from an ISR, so check there is data available. If
         * not then just leave without doing anything. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    434e:	e9 81       	ldd	r30, Y+1	; 0x01
    4350:	fa 81       	ldd	r31, Y+2	; 0x02
    4352:	82 8d       	ldd	r24, Z+26	; 0x1a
    4354:	88 23       	and	r24, r24
    4356:	09 f4       	brne	.+2      	; 0x435a <xQueueCRReceiveFromISR+0x34>
    4358:	50 c0       	rjmp	.+160    	; 0x43fa <xQueueCRReceiveFromISR+0xd4>
        {
            /* Copy the data from the queue. */
            pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    435a:	e9 81       	ldd	r30, Y+1	; 0x01
    435c:	fa 81       	ldd	r31, Y+2	; 0x02
    435e:	26 81       	ldd	r18, Z+6	; 0x06
    4360:	37 81       	ldd	r19, Z+7	; 0x07
    4362:	e9 81       	ldd	r30, Y+1	; 0x01
    4364:	fa 81       	ldd	r31, Y+2	; 0x02
    4366:	84 8d       	ldd	r24, Z+28	; 0x1c
    4368:	88 2f       	mov	r24, r24
    436a:	90 e0       	ldi	r25, 0x00	; 0
    436c:	82 0f       	add	r24, r18
    436e:	93 1f       	adc	r25, r19
    4370:	e9 81       	ldd	r30, Y+1	; 0x01
    4372:	fa 81       	ldd	r31, Y+2	; 0x02
    4374:	97 83       	std	Z+7, r25	; 0x07
    4376:	86 83       	std	Z+6, r24	; 0x06

            if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    4378:	e9 81       	ldd	r30, Y+1	; 0x01
    437a:	fa 81       	ldd	r31, Y+2	; 0x02
    437c:	26 81       	ldd	r18, Z+6	; 0x06
    437e:	37 81       	ldd	r19, Z+7	; 0x07
    4380:	e9 81       	ldd	r30, Y+1	; 0x01
    4382:	fa 81       	ldd	r31, Y+2	; 0x02
    4384:	84 81       	ldd	r24, Z+4	; 0x04
    4386:	95 81       	ldd	r25, Z+5	; 0x05
    4388:	28 17       	cp	r18, r24
    438a:	39 07       	cpc	r19, r25
    438c:	40 f0       	brcs	.+16     	; 0x439e <xQueueCRReceiveFromISR+0x78>
            {
                pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    438e:	e9 81       	ldd	r30, Y+1	; 0x01
    4390:	fa 81       	ldd	r31, Y+2	; 0x02
    4392:	80 81       	ld	r24, Z
    4394:	91 81       	ldd	r25, Z+1	; 0x01
    4396:	e9 81       	ldd	r30, Y+1	; 0x01
    4398:	fa 81       	ldd	r31, Y+2	; 0x02
    439a:	97 83       	std	Z+7, r25	; 0x07
    439c:	86 83       	std	Z+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            --( pxQueue->uxMessagesWaiting );
    439e:	e9 81       	ldd	r30, Y+1	; 0x01
    43a0:	fa 81       	ldd	r31, Y+2	; 0x02
    43a2:	82 8d       	ldd	r24, Z+26	; 0x1a
    43a4:	81 50       	subi	r24, 0x01	; 1
    43a6:	e9 81       	ldd	r30, Y+1	; 0x01
    43a8:	fa 81       	ldd	r31, Y+2	; 0x02
    43aa:	82 8f       	std	Z+26, r24	; 0x1a
            ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    43ac:	e9 81       	ldd	r30, Y+1	; 0x01
    43ae:	fa 81       	ldd	r31, Y+2	; 0x02
    43b0:	46 81       	ldd	r20, Z+6	; 0x06
    43b2:	57 81       	ldd	r21, Z+7	; 0x07
    43b4:	e9 81       	ldd	r30, Y+1	; 0x01
    43b6:	fa 81       	ldd	r31, Y+2	; 0x02
    43b8:	84 8d       	ldd	r24, Z+28	; 0x1c
    43ba:	28 2f       	mov	r18, r24
    43bc:	30 e0       	ldi	r19, 0x00	; 0
    43be:	8e 81       	ldd	r24, Y+6	; 0x06
    43c0:	9f 81       	ldd	r25, Y+7	; 0x07
    43c2:	ba 01       	movw	r22, r20
    43c4:	a9 01       	movw	r20, r18
    43c6:	0e 94 e2 3b 	call	0x77c4	; 0x77c4 <memcpy>

            if( ( *pxCoRoutineWoken ) == pdFALSE )
    43ca:	e8 85       	ldd	r30, Y+8	; 0x08
    43cc:	f9 85       	ldd	r31, Y+9	; 0x09
    43ce:	80 81       	ld	r24, Z
    43d0:	88 23       	and	r24, r24
    43d2:	81 f4       	brne	.+32     	; 0x43f4 <xQueueCRReceiveFromISR+0xce>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    43d4:	e9 81       	ldd	r30, Y+1	; 0x01
    43d6:	fa 81       	ldd	r31, Y+2	; 0x02
    43d8:	80 85       	ldd	r24, Z+8	; 0x08
    43da:	88 23       	and	r24, r24
    43dc:	59 f0       	breq	.+22     	; 0x43f4 <xQueueCRReceiveFromISR+0xce>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    43de:	89 81       	ldd	r24, Y+1	; 0x01
    43e0:	9a 81       	ldd	r25, Y+2	; 0x02
    43e2:	08 96       	adiw	r24, 0x08	; 8
    43e4:	0e 94 42 14 	call	0x2884	; 0x2884 <xCoRoutineRemoveFromEventList>
    43e8:	88 23       	and	r24, r24
    43ea:	21 f0       	breq	.+8      	; 0x43f4 <xQueueCRReceiveFromISR+0xce>
                    {
                        *pxCoRoutineWoken = pdTRUE;
    43ec:	e8 85       	ldd	r30, Y+8	; 0x08
    43ee:	f9 85       	ldd	r31, Y+9	; 0x09
    43f0:	81 e0       	ldi	r24, 0x01	; 1
    43f2:	80 83       	st	Z, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            xReturn = pdPASS;
    43f4:	81 e0       	ldi	r24, 0x01	; 1
    43f6:	8b 83       	std	Y+3, r24	; 0x03
    43f8:	01 c0       	rjmp	.+2      	; 0x43fc <xQueueCRReceiveFromISR+0xd6>
        }
        else
        {
            xReturn = pdFAIL;
    43fa:	1b 82       	std	Y+3, r1	; 0x03
        }

        return xReturn;
    43fc:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    43fe:	29 96       	adiw	r28, 0x09	; 9
    4400:	0f b6       	in	r0, 0x3f	; 63
    4402:	f8 94       	cli
    4404:	de bf       	out	0x3e, r29	; 62
    4406:	0f be       	out	0x3f, r0	; 63
    4408:	cd bf       	out	0x3d, r28	; 61
    440a:	cf 91       	pop	r28
    440c:	df 91       	pop	r29
    440e:	08 95       	ret

00004410 <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
    4410:	df 93       	push	r29
    4412:	cf 93       	push	r28
    4414:	cd b7       	in	r28, 0x3d	; 61
    4416:	de b7       	in	r29, 0x3e	; 62
    4418:	27 97       	sbiw	r28, 0x07	; 7
    441a:	0f b6       	in	r0, 0x3f	; 63
    441c:	f8 94       	cli
    441e:	de bf       	out	0x3e, r29	; 62
    4420:	0f be       	out	0x3f, r0	; 63
    4422:	cd bf       	out	0x3d, r28	; 61
    4424:	9c 83       	std	Y+4, r25	; 0x04
    4426:	8b 83       	std	Y+3, r24	; 0x03
    4428:	7e 83       	std	Y+6, r23	; 0x06
    442a:	6d 83       	std	Y+5, r22	; 0x05
    442c:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    442e:	8b 81       	ldd	r24, Y+3	; 0x03
    4430:	9c 81       	ldd	r25, Y+4	; 0x04
    4432:	9a 83       	std	Y+2, r25	; 0x02
    4434:	89 83       	std	Y+1, r24	; 0x01
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    4436:	0f b6       	in	r0, 0x3f	; 63
    4438:	f8 94       	cli
    443a:	0f 92       	push	r0
    443c:	e9 81       	ldd	r30, Y+1	; 0x01
    443e:	fa 81       	ldd	r31, Y+2	; 0x02
    4440:	85 8d       	ldd	r24, Z+29	; 0x1d
    4442:	8f 3f       	cpi	r24, 0xFF	; 255
    4444:	19 f4       	brne	.+6      	; 0x444c <vQueueWaitForMessageRestricted+0x3c>
    4446:	e9 81       	ldd	r30, Y+1	; 0x01
    4448:	fa 81       	ldd	r31, Y+2	; 0x02
    444a:	15 8e       	std	Z+29, r1	; 0x1d
    444c:	e9 81       	ldd	r30, Y+1	; 0x01
    444e:	fa 81       	ldd	r31, Y+2	; 0x02
    4450:	86 8d       	ldd	r24, Z+30	; 0x1e
    4452:	8f 3f       	cpi	r24, 0xFF	; 255
    4454:	19 f4       	brne	.+6      	; 0x445c <vQueueWaitForMessageRestricted+0x4c>
    4456:	e9 81       	ldd	r30, Y+1	; 0x01
    4458:	fa 81       	ldd	r31, Y+2	; 0x02
    445a:	16 8e       	std	Z+30, r1	; 0x1e
    445c:	0f 90       	pop	r0
    445e:	0f be       	out	0x3f, r0	; 63

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    4460:	e9 81       	ldd	r30, Y+1	; 0x01
    4462:	fa 81       	ldd	r31, Y+2	; 0x02
    4464:	82 8d       	ldd	r24, Z+26	; 0x1a
    4466:	88 23       	and	r24, r24
    4468:	49 f4       	brne	.+18     	; 0x447c <vQueueWaitForMessageRestricted+0x6c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    446a:	89 81       	ldd	r24, Y+1	; 0x01
    446c:	9a 81       	ldd	r25, Y+2	; 0x02
    446e:	41 96       	adiw	r24, 0x11	; 17
    4470:	2d 81       	ldd	r18, Y+5	; 0x05
    4472:	3e 81       	ldd	r19, Y+6	; 0x06
    4474:	b9 01       	movw	r22, r18
    4476:	4f 81       	ldd	r20, Y+7	; 0x07
    4478:	0e 94 00 2a 	call	0x5400	; 0x5400 <vTaskPlaceOnEventListRestricted>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
    447c:	89 81       	ldd	r24, Y+1	; 0x01
    447e:	9a 81       	ldd	r25, Y+2	; 0x02
    4480:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <prvUnlockQueue>
    }
    4484:	27 96       	adiw	r28, 0x07	; 7
    4486:	0f b6       	in	r0, 0x3f	; 63
    4488:	f8 94       	cli
    448a:	de bf       	out	0x3e, r29	; 62
    448c:	0f be       	out	0x3f, r0	; 63
    448e:	cd bf       	out	0x3d, r28	; 61
    4490:	cf 91       	pop	r28
    4492:	df 91       	pop	r29
    4494:	08 95       	ret

00004496 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    4496:	8f 92       	push	r8
    4498:	9f 92       	push	r9
    449a:	af 92       	push	r10
    449c:	bf 92       	push	r11
    449e:	cf 92       	push	r12
    44a0:	df 92       	push	r13
    44a2:	ef 92       	push	r14
    44a4:	ff 92       	push	r15
    44a6:	0f 93       	push	r16
    44a8:	1f 93       	push	r17
    44aa:	df 93       	push	r29
    44ac:	cf 93       	push	r28
    44ae:	cd b7       	in	r28, 0x3d	; 61
    44b0:	de b7       	in	r29, 0x3e	; 62
    44b2:	60 97       	sbiw	r28, 0x10	; 16
    44b4:	0f b6       	in	r0, 0x3f	; 63
    44b6:	f8 94       	cli
    44b8:	de bf       	out	0x3e, r29	; 62
    44ba:	0f be       	out	0x3f, r0	; 63
    44bc:	cd bf       	out	0x3d, r28	; 61
    44be:	9f 83       	std	Y+7, r25	; 0x07
    44c0:	8e 83       	std	Y+6, r24	; 0x06
    44c2:	79 87       	std	Y+9, r23	; 0x09
    44c4:	68 87       	std	Y+8, r22	; 0x08
    44c6:	5b 87       	std	Y+11, r21	; 0x0b
    44c8:	4a 87       	std	Y+10, r20	; 0x0a
    44ca:	3d 87       	std	Y+13, r19	; 0x0d
    44cc:	2c 87       	std	Y+12, r18	; 0x0c
    44ce:	0e 87       	std	Y+14, r16	; 0x0e
    44d0:	f8 8a       	std	Y+16, r15	; 0x10
    44d2:	ef 86       	std	Y+15, r14	; 0x0f
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    44d4:	8a 85       	ldd	r24, Y+10	; 0x0a
    44d6:	9b 85       	ldd	r25, Y+11	; 0x0b
    44d8:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <pvPortMalloc>
    44dc:	9a 83       	std	Y+2, r25	; 0x02
    44de:	89 83       	std	Y+1, r24	; 0x01

                if( pxStack != NULL )
    44e0:	89 81       	ldd	r24, Y+1	; 0x01
    44e2:	9a 81       	ldd	r25, Y+2	; 0x02
    44e4:	00 97       	sbiw	r24, 0x00	; 0
    44e6:	b1 f0       	breq	.+44     	; 0x4514 <xTaskCreate+0x7e>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    44e8:	86 e2       	ldi	r24, 0x26	; 38
    44ea:	90 e0       	ldi	r25, 0x00	; 0
    44ec:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <pvPortMalloc>
    44f0:	9d 83       	std	Y+5, r25	; 0x05
    44f2:	8c 83       	std	Y+4, r24	; 0x04

                    if( pxNewTCB != NULL )
    44f4:	8c 81       	ldd	r24, Y+4	; 0x04
    44f6:	9d 81       	ldd	r25, Y+5	; 0x05
    44f8:	00 97       	sbiw	r24, 0x00	; 0
    44fa:	39 f0       	breq	.+14     	; 0x450a <xTaskCreate+0x74>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
    44fc:	ec 81       	ldd	r30, Y+4	; 0x04
    44fe:	fd 81       	ldd	r31, Y+5	; 0x05
    4500:	89 81       	ldd	r24, Y+1	; 0x01
    4502:	9a 81       	ldd	r25, Y+2	; 0x02
    4504:	90 8f       	std	Z+24, r25	; 0x18
    4506:	87 8b       	std	Z+23, r24	; 0x17
    4508:	07 c0       	rjmp	.+14     	; 0x4518 <xTaskCreate+0x82>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFreeStack( pxStack );
    450a:	89 81       	ldd	r24, Y+1	; 0x01
    450c:	9a 81       	ldd	r25, Y+2	; 0x02
    450e:	0e 94 a1 0e 	call	0x1d42	; 0x1d42 <vPortFree>
    4512:	02 c0       	rjmp	.+4      	; 0x4518 <xTaskCreate+0x82>
                    }
                }
                else
                {
                    pxNewTCB = NULL;
    4514:	1d 82       	std	Y+5, r1	; 0x05
    4516:	1c 82       	std	Y+4, r1	; 0x04
                }
            }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
    4518:	8c 81       	ldd	r24, Y+4	; 0x04
    451a:	9d 81       	ldd	r25, Y+5	; 0x05
    451c:	00 97       	sbiw	r24, 0x00	; 0
    451e:	e9 f0       	breq	.+58     	; 0x455a <xTaskCreate+0xc4>
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    4520:	8a 85       	ldd	r24, Y+10	; 0x0a
    4522:	9b 85       	ldd	r25, Y+11	; 0x0b
    4524:	9c 01       	movw	r18, r24
    4526:	40 e0       	ldi	r20, 0x00	; 0
    4528:	50 e0       	ldi	r21, 0x00	; 0
    452a:	8e 81       	ldd	r24, Y+6	; 0x06
    452c:	9f 81       	ldd	r25, Y+7	; 0x07
    452e:	68 85       	ldd	r22, Y+8	; 0x08
    4530:	79 85       	ldd	r23, Y+9	; 0x09
    4532:	ec 85       	ldd	r30, Y+12	; 0x0c
    4534:	fd 85       	ldd	r31, Y+13	; 0x0d
    4536:	af 85       	ldd	r26, Y+15	; 0x0f
    4538:	b8 89       	ldd	r27, Y+16	; 0x10
    453a:	ac 80       	ldd	r10, Y+4	; 0x04
    453c:	bd 80       	ldd	r11, Y+5	; 0x05
    453e:	8f 01       	movw	r16, r30
    4540:	ee 84       	ldd	r14, Y+14	; 0x0e
    4542:	6d 01       	movw	r12, r26
    4544:	88 24       	eor	r8, r8
    4546:	99 24       	eor	r9, r9
    4548:	0e 94 c3 22 	call	0x4586	; 0x4586 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
    454c:	8c 81       	ldd	r24, Y+4	; 0x04
    454e:	9d 81       	ldd	r25, Y+5	; 0x05
    4550:	0e 94 88 23 	call	0x4710	; 0x4710 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
    4554:	81 e0       	ldi	r24, 0x01	; 1
    4556:	8b 83       	std	Y+3, r24	; 0x03
    4558:	02 c0       	rjmp	.+4      	; 0x455e <xTaskCreate+0xc8>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    455a:	8f ef       	ldi	r24, 0xFF	; 255
    455c:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    455e:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    4560:	60 96       	adiw	r28, 0x10	; 16
    4562:	0f b6       	in	r0, 0x3f	; 63
    4564:	f8 94       	cli
    4566:	de bf       	out	0x3e, r29	; 62
    4568:	0f be       	out	0x3f, r0	; 63
    456a:	cd bf       	out	0x3d, r28	; 61
    456c:	cf 91       	pop	r28
    456e:	df 91       	pop	r29
    4570:	1f 91       	pop	r17
    4572:	0f 91       	pop	r16
    4574:	ff 90       	pop	r15
    4576:	ef 90       	pop	r14
    4578:	df 90       	pop	r13
    457a:	cf 90       	pop	r12
    457c:	bf 90       	pop	r11
    457e:	af 90       	pop	r10
    4580:	9f 90       	pop	r9
    4582:	8f 90       	pop	r8
    4584:	08 95       	ret

00004586 <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
    4586:	8f 92       	push	r8
    4588:	9f 92       	push	r9
    458a:	af 92       	push	r10
    458c:	bf 92       	push	r11
    458e:	cf 92       	push	r12
    4590:	df 92       	push	r13
    4592:	ef 92       	push	r14
    4594:	0f 93       	push	r16
    4596:	1f 93       	push	r17
    4598:	df 93       	push	r29
    459a:	cf 93       	push	r28
    459c:	cd b7       	in	r28, 0x3d	; 61
    459e:	de b7       	in	r29, 0x3e	; 62
    45a0:	64 97       	sbiw	r28, 0x14	; 20
    45a2:	0f b6       	in	r0, 0x3f	; 63
    45a4:	f8 94       	cli
    45a6:	de bf       	out	0x3e, r29	; 62
    45a8:	0f be       	out	0x3f, r0	; 63
    45aa:	cd bf       	out	0x3d, r28	; 61
    45ac:	9d 83       	std	Y+5, r25	; 0x05
    45ae:	8c 83       	std	Y+4, r24	; 0x04
    45b0:	7f 83       	std	Y+7, r23	; 0x07
    45b2:	6e 83       	std	Y+6, r22	; 0x06
    45b4:	28 87       	std	Y+8, r18	; 0x08
    45b6:	39 87       	std	Y+9, r19	; 0x09
    45b8:	4a 87       	std	Y+10, r20	; 0x0a
    45ba:	5b 87       	std	Y+11, r21	; 0x0b
    45bc:	1d 87       	std	Y+13, r17	; 0x0d
    45be:	0c 87       	std	Y+12, r16	; 0x0c
    45c0:	ee 86       	std	Y+14, r14	; 0x0e
    45c2:	d8 8a       	std	Y+16, r13	; 0x10
    45c4:	cf 86       	std	Y+15, r12	; 0x0f
    45c6:	ba 8a       	std	Y+18, r11	; 0x12
    45c8:	a9 8a       	std	Y+17, r10	; 0x11
    45ca:	9c 8a       	std	Y+20, r9	; 0x14
    45cc:	8b 8a       	std	Y+19, r8	; 0x13
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    45ce:	e9 89       	ldd	r30, Y+17	; 0x11
    45d0:	fa 89       	ldd	r31, Y+18	; 0x12
    45d2:	27 89       	ldd	r18, Z+23	; 0x17
    45d4:	30 8d       	ldd	r19, Z+24	; 0x18
    45d6:	88 85       	ldd	r24, Y+8	; 0x08
    45d8:	99 85       	ldd	r25, Y+9	; 0x09
    45da:	01 97       	sbiw	r24, 0x01	; 1
    45dc:	82 0f       	add	r24, r18
    45de:	93 1f       	adc	r25, r19
    45e0:	9b 83       	std	Y+3, r25	; 0x03
    45e2:	8a 83       	std	Y+2, r24	; 0x02
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    45e4:	8e 81       	ldd	r24, Y+6	; 0x06
    45e6:	9f 81       	ldd	r25, Y+7	; 0x07
    45e8:	00 97       	sbiw	r24, 0x00	; 0
    45ea:	51 f1       	breq	.+84     	; 0x4640 <prvInitialiseNewTask+0xba>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    45ec:	19 82       	std	Y+1, r1	; 0x01
    45ee:	21 c0       	rjmp	.+66     	; 0x4632 <prvInitialiseNewTask+0xac>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    45f0:	89 81       	ldd	r24, Y+1	; 0x01
    45f2:	48 2f       	mov	r20, r24
    45f4:	50 e0       	ldi	r21, 0x00	; 0
    45f6:	89 81       	ldd	r24, Y+1	; 0x01
    45f8:	28 2f       	mov	r18, r24
    45fa:	30 e0       	ldi	r19, 0x00	; 0
    45fc:	8e 81       	ldd	r24, Y+6	; 0x06
    45fe:	9f 81       	ldd	r25, Y+7	; 0x07
    4600:	fc 01       	movw	r30, r24
    4602:	e2 0f       	add	r30, r18
    4604:	f3 1f       	adc	r31, r19
    4606:	20 81       	ld	r18, Z
    4608:	89 89       	ldd	r24, Y+17	; 0x11
    460a:	9a 89       	ldd	r25, Y+18	; 0x12
    460c:	84 0f       	add	r24, r20
    460e:	95 1f       	adc	r25, r21
    4610:	fc 01       	movw	r30, r24
    4612:	79 96       	adiw	r30, 0x19	; 25
    4614:	20 83       	st	Z, r18

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    4616:	89 81       	ldd	r24, Y+1	; 0x01
    4618:	28 2f       	mov	r18, r24
    461a:	30 e0       	ldi	r19, 0x00	; 0
    461c:	8e 81       	ldd	r24, Y+6	; 0x06
    461e:	9f 81       	ldd	r25, Y+7	; 0x07
    4620:	fc 01       	movw	r30, r24
    4622:	e2 0f       	add	r30, r18
    4624:	f3 1f       	adc	r31, r19
    4626:	80 81       	ld	r24, Z
    4628:	88 23       	and	r24, r24
    462a:	31 f0       	breq	.+12     	; 0x4638 <prvInitialiseNewTask+0xb2>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    462c:	89 81       	ldd	r24, Y+1	; 0x01
    462e:	8f 5f       	subi	r24, 0xFF	; 255
    4630:	89 83       	std	Y+1, r24	; 0x01
    4632:	89 81       	ldd	r24, Y+1	; 0x01
    4634:	88 30       	cpi	r24, 0x08	; 8
    4636:	e0 f2       	brcs	.-72     	; 0x45f0 <prvInitialiseNewTask+0x6a>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    4638:	e9 89       	ldd	r30, Y+17	; 0x11
    463a:	fa 89       	ldd	r31, Y+18	; 0x12
    463c:	10 a2       	std	Z+32, r1	; 0x20
    463e:	03 c0       	rjmp	.+6      	; 0x4646 <prvInitialiseNewTask+0xc0>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
    4640:	e9 89       	ldd	r30, Y+17	; 0x11
    4642:	fa 89       	ldd	r31, Y+18	; 0x12
    4644:	11 8e       	std	Z+25, r1	; 0x19
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    4646:	8e 85       	ldd	r24, Y+14	; 0x0e
    4648:	84 30       	cpi	r24, 0x04	; 4
    464a:	10 f0       	brcs	.+4      	; 0x4650 <prvInitialiseNewTask+0xca>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    464c:	83 e0       	ldi	r24, 0x03	; 3
    464e:	8e 87       	std	Y+14, r24	; 0x0e
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    4650:	e9 89       	ldd	r30, Y+17	; 0x11
    4652:	fa 89       	ldd	r31, Y+18	; 0x12
    4654:	8e 85       	ldd	r24, Y+14	; 0x0e
    4656:	86 8b       	std	Z+22, r24	; 0x16
            pxNewTCB->uxBasePriority = uxPriority;
            pxNewTCB->uxMutexesHeld = 0;
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    4658:	89 89       	ldd	r24, Y+17	; 0x11
    465a:	9a 89       	ldd	r25, Y+18	; 0x12
    465c:	02 96       	adiw	r24, 0x02	; 2
    465e:	0e 94 e9 17 	call	0x2fd2	; 0x2fd2 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    4662:	89 89       	ldd	r24, Y+17	; 0x11
    4664:	9a 89       	ldd	r25, Y+18	; 0x12
    4666:	0c 96       	adiw	r24, 0x0c	; 12
    4668:	0e 94 e9 17 	call	0x2fd2	; 0x2fd2 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    466c:	e9 89       	ldd	r30, Y+17	; 0x11
    466e:	fa 89       	ldd	r31, Y+18	; 0x12
    4670:	89 89       	ldd	r24, Y+17	; 0x11
    4672:	9a 89       	ldd	r25, Y+18	; 0x12
    4674:	91 87       	std	Z+9, r25	; 0x09
    4676:	80 87       	std	Z+8, r24	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4678:	8e 85       	ldd	r24, Y+14	; 0x0e
    467a:	28 2f       	mov	r18, r24
    467c:	30 e0       	ldi	r19, 0x00	; 0
    467e:	84 e0       	ldi	r24, 0x04	; 4
    4680:	90 e0       	ldi	r25, 0x00	; 0
    4682:	82 1b       	sub	r24, r18
    4684:	93 0b       	sbc	r25, r19
    4686:	e9 89       	ldd	r30, Y+17	; 0x11
    4688:	fa 89       	ldd	r31, Y+18	; 0x12
    468a:	95 87       	std	Z+13, r25	; 0x0d
    468c:	84 87       	std	Z+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    468e:	e9 89       	ldd	r30, Y+17	; 0x11
    4690:	fa 89       	ldd	r31, Y+18	; 0x12
    4692:	89 89       	ldd	r24, Y+17	; 0x11
    4694:	9a 89       	ldd	r25, Y+18	; 0x12
    4696:	93 8b       	std	Z+19, r25	; 0x13
    4698:	82 8b       	std	Z+18, r24	; 0x12
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
    469a:	89 89       	ldd	r24, Y+17	; 0x11
    469c:	9a 89       	ldd	r25, Y+18	; 0x12
    469e:	81 96       	adiw	r24, 0x21	; 33
    46a0:	60 e0       	ldi	r22, 0x00	; 0
    46a2:	70 e0       	ldi	r23, 0x00	; 0
    46a4:	44 e0       	ldi	r20, 0x04	; 4
    46a6:	50 e0       	ldi	r21, 0x00	; 0
    46a8:	0e 94 eb 3b 	call	0x77d6	; 0x77d6 <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
    46ac:	89 89       	ldd	r24, Y+17	; 0x11
    46ae:	9a 89       	ldd	r25, Y+18	; 0x12
    46b0:	85 96       	adiw	r24, 0x25	; 37
    46b2:	60 e0       	ldi	r22, 0x00	; 0
    46b4:	70 e0       	ldi	r23, 0x00	; 0
    46b6:	41 e0       	ldi	r20, 0x01	; 1
    46b8:	50 e0       	ldi	r21, 0x00	; 0
    46ba:	0e 94 eb 3b 	call	0x77d6	; 0x77d6 <memset>
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    46be:	8a 81       	ldd	r24, Y+2	; 0x02
    46c0:	9b 81       	ldd	r25, Y+3	; 0x03
    46c2:	2c 81       	ldd	r18, Y+4	; 0x04
    46c4:	3d 81       	ldd	r19, Y+5	; 0x05
    46c6:	4c 85       	ldd	r20, Y+12	; 0x0c
    46c8:	5d 85       	ldd	r21, Y+13	; 0x0d
    46ca:	b9 01       	movw	r22, r18
    46cc:	0e 94 c7 0e 	call	0x1d8e	; 0x1d8e <pxPortInitialiseStack>
    46d0:	e9 89       	ldd	r30, Y+17	; 0x11
    46d2:	fa 89       	ldd	r31, Y+18	; 0x12
    46d4:	91 83       	std	Z+1, r25	; 0x01
    46d6:	80 83       	st	Z, r24
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    46d8:	8f 85       	ldd	r24, Y+15	; 0x0f
    46da:	98 89       	ldd	r25, Y+16	; 0x10
    46dc:	00 97       	sbiw	r24, 0x00	; 0
    46de:	31 f0       	breq	.+12     	; 0x46ec <prvInitialiseNewTask+0x166>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    46e0:	ef 85       	ldd	r30, Y+15	; 0x0f
    46e2:	f8 89       	ldd	r31, Y+16	; 0x10
    46e4:	89 89       	ldd	r24, Y+17	; 0x11
    46e6:	9a 89       	ldd	r25, Y+18	; 0x12
    46e8:	91 83       	std	Z+1, r25	; 0x01
    46ea:	80 83       	st	Z, r24
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    46ec:	64 96       	adiw	r28, 0x14	; 20
    46ee:	0f b6       	in	r0, 0x3f	; 63
    46f0:	f8 94       	cli
    46f2:	de bf       	out	0x3e, r29	; 62
    46f4:	0f be       	out	0x3f, r0	; 63
    46f6:	cd bf       	out	0x3d, r28	; 61
    46f8:	cf 91       	pop	r28
    46fa:	df 91       	pop	r29
    46fc:	1f 91       	pop	r17
    46fe:	0f 91       	pop	r16
    4700:	ef 90       	pop	r14
    4702:	df 90       	pop	r13
    4704:	cf 90       	pop	r12
    4706:	bf 90       	pop	r11
    4708:	af 90       	pop	r10
    470a:	9f 90       	pop	r9
    470c:	8f 90       	pop	r8
    470e:	08 95       	ret

00004710 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    4710:	df 93       	push	r29
    4712:	cf 93       	push	r28
    4714:	00 d0       	rcall	.+0      	; 0x4716 <prvAddNewTaskToReadyList+0x6>
    4716:	00 d0       	rcall	.+0      	; 0x4718 <prvAddNewTaskToReadyList+0x8>
    4718:	cd b7       	in	r28, 0x3d	; 61
    471a:	de b7       	in	r29, 0x3e	; 62
    471c:	9c 83       	std	Y+4, r25	; 0x04
    471e:	8b 83       	std	Y+3, r24	; 0x03
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    4720:	0f b6       	in	r0, 0x3f	; 63
    4722:	f8 94       	cli
    4724:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    4726:	80 91 49 07 	lds	r24, 0x0749
    472a:	8f 5f       	subi	r24, 0xFF	; 255
    472c:	80 93 49 07 	sts	0x0749, r24

        if( pxCurrentTCB == NULL )
    4730:	80 91 46 07 	lds	r24, 0x0746
    4734:	90 91 47 07 	lds	r25, 0x0747
    4738:	00 97       	sbiw	r24, 0x00	; 0
    473a:	69 f4       	brne	.+26     	; 0x4756 <prvAddNewTaskToReadyList+0x46>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    473c:	8b 81       	ldd	r24, Y+3	; 0x03
    473e:	9c 81       	ldd	r25, Y+4	; 0x04
    4740:	90 93 47 07 	sts	0x0747, r25
    4744:	80 93 46 07 	sts	0x0746, r24

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    4748:	80 91 49 07 	lds	r24, 0x0749
    474c:	81 30       	cpi	r24, 0x01	; 1
    474e:	b9 f4       	brne	.+46     	; 0x477e <prvAddNewTaskToReadyList+0x6e>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
    4750:	0e 94 6c 2d 	call	0x5ad8	; 0x5ad8 <prvInitialiseTaskLists>
    4754:	14 c0       	rjmp	.+40     	; 0x477e <prvAddNewTaskToReadyList+0x6e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    4756:	80 91 4d 07 	lds	r24, 0x074D
    475a:	88 23       	and	r24, r24
    475c:	81 f4       	brne	.+32     	; 0x477e <prvAddNewTaskToReadyList+0x6e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    475e:	e0 91 46 07 	lds	r30, 0x0746
    4762:	f0 91 47 07 	lds	r31, 0x0747
    4766:	96 89       	ldd	r25, Z+22	; 0x16
    4768:	eb 81       	ldd	r30, Y+3	; 0x03
    476a:	fc 81       	ldd	r31, Y+4	; 0x04
    476c:	86 89       	ldd	r24, Z+22	; 0x16
    476e:	89 17       	cp	r24, r25
    4770:	30 f0       	brcs	.+12     	; 0x477e <prvAddNewTaskToReadyList+0x6e>
                {
                    pxCurrentTCB = pxNewTCB;
    4772:	8b 81       	ldd	r24, Y+3	; 0x03
    4774:	9c 81       	ldd	r25, Y+4	; 0x04
    4776:	90 93 47 07 	sts	0x0747, r25
    477a:	80 93 46 07 	sts	0x0746, r24
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    477e:	80 91 52 07 	lds	r24, 0x0752
    4782:	8f 5f       	subi	r24, 0xFF	; 255
    4784:	80 93 52 07 	sts	0x0752, r24
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    4788:	eb 81       	ldd	r30, Y+3	; 0x03
    478a:	fc 81       	ldd	r31, Y+4	; 0x04
    478c:	96 89       	ldd	r25, Z+22	; 0x16
    478e:	80 91 4c 07 	lds	r24, 0x074C
    4792:	89 17       	cp	r24, r25
    4794:	28 f4       	brcc	.+10     	; 0x47a0 <prvAddNewTaskToReadyList+0x90>
    4796:	eb 81       	ldd	r30, Y+3	; 0x03
    4798:	fc 81       	ldd	r31, Y+4	; 0x04
    479a:	86 89       	ldd	r24, Z+22	; 0x16
    479c:	80 93 4c 07 	sts	0x074C, r24
    47a0:	eb 81       	ldd	r30, Y+3	; 0x03
    47a2:	fc 81       	ldd	r31, Y+4	; 0x04
    47a4:	86 89       	ldd	r24, Z+22	; 0x16
    47a6:	28 2f       	mov	r18, r24
    47a8:	30 e0       	ldi	r19, 0x00	; 0
    47aa:	c9 01       	movw	r24, r18
    47ac:	88 0f       	add	r24, r24
    47ae:	99 1f       	adc	r25, r25
    47b0:	88 0f       	add	r24, r24
    47b2:	99 1f       	adc	r25, r25
    47b4:	88 0f       	add	r24, r24
    47b6:	99 1f       	adc	r25, r25
    47b8:	82 0f       	add	r24, r18
    47ba:	93 1f       	adc	r25, r19
    47bc:	fc 01       	movw	r30, r24
    47be:	e8 5a       	subi	r30, 0xA8	; 168
    47c0:	f8 4f       	sbci	r31, 0xF8	; 248
    47c2:	81 81       	ldd	r24, Z+1	; 0x01
    47c4:	92 81       	ldd	r25, Z+2	; 0x02
    47c6:	9a 83       	std	Y+2, r25	; 0x02
    47c8:	89 83       	std	Y+1, r24	; 0x01
    47ca:	eb 81       	ldd	r30, Y+3	; 0x03
    47cc:	fc 81       	ldd	r31, Y+4	; 0x04
    47ce:	89 81       	ldd	r24, Y+1	; 0x01
    47d0:	9a 81       	ldd	r25, Y+2	; 0x02
    47d2:	95 83       	std	Z+5, r25	; 0x05
    47d4:	84 83       	std	Z+4, r24	; 0x04
    47d6:	e9 81       	ldd	r30, Y+1	; 0x01
    47d8:	fa 81       	ldd	r31, Y+2	; 0x02
    47da:	84 81       	ldd	r24, Z+4	; 0x04
    47dc:	95 81       	ldd	r25, Z+5	; 0x05
    47de:	eb 81       	ldd	r30, Y+3	; 0x03
    47e0:	fc 81       	ldd	r31, Y+4	; 0x04
    47e2:	97 83       	std	Z+7, r25	; 0x07
    47e4:	86 83       	std	Z+6, r24	; 0x06
    47e6:	e9 81       	ldd	r30, Y+1	; 0x01
    47e8:	fa 81       	ldd	r31, Y+2	; 0x02
    47ea:	04 80       	ldd	r0, Z+4	; 0x04
    47ec:	f5 81       	ldd	r31, Z+5	; 0x05
    47ee:	e0 2d       	mov	r30, r0
    47f0:	8b 81       	ldd	r24, Y+3	; 0x03
    47f2:	9c 81       	ldd	r25, Y+4	; 0x04
    47f4:	02 96       	adiw	r24, 0x02	; 2
    47f6:	93 83       	std	Z+3, r25	; 0x03
    47f8:	82 83       	std	Z+2, r24	; 0x02
    47fa:	8b 81       	ldd	r24, Y+3	; 0x03
    47fc:	9c 81       	ldd	r25, Y+4	; 0x04
    47fe:	02 96       	adiw	r24, 0x02	; 2
    4800:	e9 81       	ldd	r30, Y+1	; 0x01
    4802:	fa 81       	ldd	r31, Y+2	; 0x02
    4804:	95 83       	std	Z+5, r25	; 0x05
    4806:	84 83       	std	Z+4, r24	; 0x04
    4808:	eb 81       	ldd	r30, Y+3	; 0x03
    480a:	fc 81       	ldd	r31, Y+4	; 0x04
    480c:	86 89       	ldd	r24, Z+22	; 0x16
    480e:	28 2f       	mov	r18, r24
    4810:	30 e0       	ldi	r19, 0x00	; 0
    4812:	c9 01       	movw	r24, r18
    4814:	88 0f       	add	r24, r24
    4816:	99 1f       	adc	r25, r25
    4818:	88 0f       	add	r24, r24
    481a:	99 1f       	adc	r25, r25
    481c:	88 0f       	add	r24, r24
    481e:	99 1f       	adc	r25, r25
    4820:	82 0f       	add	r24, r18
    4822:	93 1f       	adc	r25, r19
    4824:	88 5a       	subi	r24, 0xA8	; 168
    4826:	98 4f       	sbci	r25, 0xF8	; 248
    4828:	eb 81       	ldd	r30, Y+3	; 0x03
    482a:	fc 81       	ldd	r31, Y+4	; 0x04
    482c:	93 87       	std	Z+11, r25	; 0x0b
    482e:	82 87       	std	Z+10, r24	; 0x0a
    4830:	eb 81       	ldd	r30, Y+3	; 0x03
    4832:	fc 81       	ldd	r31, Y+4	; 0x04
    4834:	86 89       	ldd	r24, Z+22	; 0x16
    4836:	28 2f       	mov	r18, r24
    4838:	30 e0       	ldi	r19, 0x00	; 0
    483a:	c9 01       	movw	r24, r18
    483c:	88 0f       	add	r24, r24
    483e:	99 1f       	adc	r25, r25
    4840:	88 0f       	add	r24, r24
    4842:	99 1f       	adc	r25, r25
    4844:	88 0f       	add	r24, r24
    4846:	99 1f       	adc	r25, r25
    4848:	82 0f       	add	r24, r18
    484a:	93 1f       	adc	r25, r19
    484c:	fc 01       	movw	r30, r24
    484e:	e8 5a       	subi	r30, 0xA8	; 168
    4850:	f8 4f       	sbci	r31, 0xF8	; 248
    4852:	80 81       	ld	r24, Z
    4854:	8f 5f       	subi	r24, 0xFF	; 255
    4856:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    4858:	0f 90       	pop	r0
    485a:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    485c:	80 91 4d 07 	lds	r24, 0x074D
    4860:	88 23       	and	r24, r24
    4862:	61 f0       	breq	.+24     	; 0x487c <prvAddNewTaskToReadyList+0x16c>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    4864:	e0 91 46 07 	lds	r30, 0x0746
    4868:	f0 91 47 07 	lds	r31, 0x0747
    486c:	96 89       	ldd	r25, Z+22	; 0x16
    486e:	eb 81       	ldd	r30, Y+3	; 0x03
    4870:	fc 81       	ldd	r31, Y+4	; 0x04
    4872:	86 89       	ldd	r24, Z+22	; 0x16
    4874:	98 17       	cp	r25, r24
    4876:	10 f4       	brcc	.+4      	; 0x487c <prvAddNewTaskToReadyList+0x16c>
        {
            taskYIELD_IF_USING_PREEMPTION();
    4878:	0e 94 86 10 	call	0x210c	; 0x210c <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    487c:	0f 90       	pop	r0
    487e:	0f 90       	pop	r0
    4880:	0f 90       	pop	r0
    4882:	0f 90       	pop	r0
    4884:	cf 91       	pop	r28
    4886:	df 91       	pop	r29
    4888:	08 95       	ret

0000488a <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    488a:	df 93       	push	r29
    488c:	cf 93       	push	r28
    488e:	00 d0       	rcall	.+0      	; 0x4890 <vTaskDelete+0x6>
    4890:	00 d0       	rcall	.+0      	; 0x4892 <vTaskDelete+0x8>
    4892:	00 d0       	rcall	.+0      	; 0x4894 <vTaskDelete+0xa>
    4894:	cd b7       	in	r28, 0x3d	; 61
    4896:	de b7       	in	r29, 0x3e	; 62
    4898:	9c 83       	std	Y+4, r25	; 0x04
    489a:	8b 83       	std	Y+3, r24	; 0x03
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    489c:	0f b6       	in	r0, 0x3f	; 63
    489e:	f8 94       	cli
    48a0:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    48a2:	8b 81       	ldd	r24, Y+3	; 0x03
    48a4:	9c 81       	ldd	r25, Y+4	; 0x04
    48a6:	00 97       	sbiw	r24, 0x00	; 0
    48a8:	39 f4       	brne	.+14     	; 0x48b8 <vTaskDelete+0x2e>
    48aa:	80 91 46 07 	lds	r24, 0x0746
    48ae:	90 91 47 07 	lds	r25, 0x0747
    48b2:	9e 83       	std	Y+6, r25	; 0x06
    48b4:	8d 83       	std	Y+5, r24	; 0x05
    48b6:	04 c0       	rjmp	.+8      	; 0x48c0 <vTaskDelete+0x36>
    48b8:	8b 81       	ldd	r24, Y+3	; 0x03
    48ba:	9c 81       	ldd	r25, Y+4	; 0x04
    48bc:	9e 83       	std	Y+6, r25	; 0x06
    48be:	8d 83       	std	Y+5, r24	; 0x05
    48c0:	8d 81       	ldd	r24, Y+5	; 0x05
    48c2:	9e 81       	ldd	r25, Y+6	; 0x06
    48c4:	9a 83       	std	Y+2, r25	; 0x02
    48c6:	89 83       	std	Y+1, r24	; 0x01

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    48c8:	89 81       	ldd	r24, Y+1	; 0x01
    48ca:	9a 81       	ldd	r25, Y+2	; 0x02
    48cc:	02 96       	adiw	r24, 0x02	; 2
    48ce:	0e 94 a9 18 	call	0x3152	; 0x3152 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    48d2:	e9 81       	ldd	r30, Y+1	; 0x01
    48d4:	fa 81       	ldd	r31, Y+2	; 0x02
    48d6:	84 89       	ldd	r24, Z+20	; 0x14
    48d8:	95 89       	ldd	r25, Z+21	; 0x15
    48da:	00 97       	sbiw	r24, 0x00	; 0
    48dc:	29 f0       	breq	.+10     	; 0x48e8 <vTaskDelete+0x5e>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    48de:	89 81       	ldd	r24, Y+1	; 0x01
    48e0:	9a 81       	ldd	r25, Y+2	; 0x02
    48e2:	0c 96       	adiw	r24, 0x0c	; 12
    48e4:	0e 94 a9 18 	call	0x3152	; 0x3152 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    48e8:	80 91 52 07 	lds	r24, 0x0752
    48ec:	8f 5f       	subi	r24, 0xFF	; 255
    48ee:	80 93 52 07 	sts	0x0752, r24

            if( pxTCB == pxCurrentTCB )
    48f2:	20 91 46 07 	lds	r18, 0x0746
    48f6:	30 91 47 07 	lds	r19, 0x0747
    48fa:	89 81       	ldd	r24, Y+1	; 0x01
    48fc:	9a 81       	ldd	r25, Y+2	; 0x02
    48fe:	82 17       	cp	r24, r18
    4900:	93 07       	cpc	r25, r19
    4902:	81 f4       	brne	.+32     	; 0x4924 <vTaskDelete+0x9a>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    4904:	89 81       	ldd	r24, Y+1	; 0x01
    4906:	9a 81       	ldd	r25, Y+2	; 0x02
    4908:	9c 01       	movw	r18, r24
    490a:	2e 5f       	subi	r18, 0xFE	; 254
    490c:	3f 4f       	sbci	r19, 0xFF	; 255
    490e:	8b e9       	ldi	r24, 0x9B	; 155
    4910:	97 e0       	ldi	r25, 0x07	; 7
    4912:	b9 01       	movw	r22, r18
    4914:	0e 94 f9 17 	call	0x2ff2	; 0x2ff2 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    4918:	80 91 48 07 	lds	r24, 0x0748
    491c:	8f 5f       	subi	r24, 0xFF	; 255
    491e:	80 93 48 07 	sts	0x0748, r24
    4922:	07 c0       	rjmp	.+14     	; 0x4932 <vTaskDelete+0xa8>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    4924:	80 91 49 07 	lds	r24, 0x0749
    4928:	81 50       	subi	r24, 0x01	; 1
    492a:	80 93 49 07 	sts	0x0749, r24
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
    492e:	0e 94 ee 2d 	call	0x5bdc	; 0x5bdc <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
    4932:	0f 90       	pop	r0
    4934:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    4936:	20 91 46 07 	lds	r18, 0x0746
    493a:	30 91 47 07 	lds	r19, 0x0747
    493e:	89 81       	ldd	r24, Y+1	; 0x01
    4940:	9a 81       	ldd	r25, Y+2	; 0x02
    4942:	82 17       	cp	r24, r18
    4944:	93 07       	cpc	r25, r19
    4946:	21 f0       	breq	.+8      	; 0x4950 <vTaskDelete+0xc6>
        {
            prvDeleteTCB( pxTCB );
    4948:	89 81       	ldd	r24, Y+1	; 0x01
    494a:	9a 81       	ldd	r25, Y+2	; 0x02
    494c:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    4950:	80 91 4d 07 	lds	r24, 0x074D
    4954:	88 23       	and	r24, r24
    4956:	59 f0       	breq	.+22     	; 0x496e <vTaskDelete+0xe4>
        {
            if( pxTCB == pxCurrentTCB )
    4958:	20 91 46 07 	lds	r18, 0x0746
    495c:	30 91 47 07 	lds	r19, 0x0747
    4960:	89 81       	ldd	r24, Y+1	; 0x01
    4962:	9a 81       	ldd	r25, Y+2	; 0x02
    4964:	82 17       	cp	r24, r18
    4966:	93 07       	cpc	r25, r19
    4968:	11 f4       	brne	.+4      	; 0x496e <vTaskDelete+0xe4>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    496a:	0e 94 86 10 	call	0x210c	; 0x210c <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    496e:	26 96       	adiw	r28, 0x06	; 6
    4970:	0f b6       	in	r0, 0x3f	; 63
    4972:	f8 94       	cli
    4974:	de bf       	out	0x3e, r29	; 62
    4976:	0f be       	out	0x3f, r0	; 63
    4978:	cd bf       	out	0x3d, r28	; 61
    497a:	cf 91       	pop	r28
    497c:	df 91       	pop	r29
    497e:	08 95       	ret

00004980 <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    4980:	df 93       	push	r29
    4982:	cf 93       	push	r28
    4984:	cd b7       	in	r28, 0x3d	; 61
    4986:	de b7       	in	r29, 0x3e	; 62
    4988:	2a 97       	sbiw	r28, 0x0a	; 10
    498a:	0f b6       	in	r0, 0x3f	; 63
    498c:	f8 94       	cli
    498e:	de bf       	out	0x3e, r29	; 62
    4990:	0f be       	out	0x3f, r0	; 63
    4992:	cd bf       	out	0x3d, r28	; 61
    4994:	98 87       	std	Y+8, r25	; 0x08
    4996:	8f 83       	std	Y+7, r24	; 0x07
    4998:	7a 87       	std	Y+10, r23	; 0x0a
    499a:	69 87       	std	Y+9, r22	; 0x09
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    499c:	1b 82       	std	Y+3, r1	; 0x03

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
    499e:	0e 94 9c 25 	call	0x4b38	; 0x4b38 <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    49a2:	80 91 4a 07 	lds	r24, 0x074A
    49a6:	90 91 4b 07 	lds	r25, 0x074B
    49aa:	9a 83       	std	Y+2, r25	; 0x02
    49ac:	89 83       	std	Y+1, r24	; 0x01

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    49ae:	ef 81       	ldd	r30, Y+7	; 0x07
    49b0:	f8 85       	ldd	r31, Y+8	; 0x08
    49b2:	20 81       	ld	r18, Z
    49b4:	31 81       	ldd	r19, Z+1	; 0x01
    49b6:	89 85       	ldd	r24, Y+9	; 0x09
    49b8:	9a 85       	ldd	r25, Y+10	; 0x0a
    49ba:	82 0f       	add	r24, r18
    49bc:	93 1f       	adc	r25, r19
    49be:	9e 83       	std	Y+6, r25	; 0x06
    49c0:	8d 83       	std	Y+5, r24	; 0x05

            if( xConstTickCount < *pxPreviousWakeTime )
    49c2:	ef 81       	ldd	r30, Y+7	; 0x07
    49c4:	f8 85       	ldd	r31, Y+8	; 0x08
    49c6:	20 81       	ld	r18, Z
    49c8:	31 81       	ldd	r19, Z+1	; 0x01
    49ca:	89 81       	ldd	r24, Y+1	; 0x01
    49cc:	9a 81       	ldd	r25, Y+2	; 0x02
    49ce:	82 17       	cp	r24, r18
    49d0:	93 07       	cpc	r25, r19
    49d2:	98 f4       	brcc	.+38     	; 0x49fa <xTaskDelayUntil+0x7a>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    49d4:	ef 81       	ldd	r30, Y+7	; 0x07
    49d6:	f8 85       	ldd	r31, Y+8	; 0x08
    49d8:	20 81       	ld	r18, Z
    49da:	31 81       	ldd	r19, Z+1	; 0x01
    49dc:	8d 81       	ldd	r24, Y+5	; 0x05
    49de:	9e 81       	ldd	r25, Y+6	; 0x06
    49e0:	82 17       	cp	r24, r18
    49e2:	93 07       	cpc	r25, r19
    49e4:	e0 f4       	brcc	.+56     	; 0x4a1e <xTaskDelayUntil+0x9e>
    49e6:	2d 81       	ldd	r18, Y+5	; 0x05
    49e8:	3e 81       	ldd	r19, Y+6	; 0x06
    49ea:	89 81       	ldd	r24, Y+1	; 0x01
    49ec:	9a 81       	ldd	r25, Y+2	; 0x02
    49ee:	82 17       	cp	r24, r18
    49f0:	93 07       	cpc	r25, r19
    49f2:	a8 f4       	brcc	.+42     	; 0x4a1e <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    49f4:	81 e0       	ldi	r24, 0x01	; 1
    49f6:	8b 83       	std	Y+3, r24	; 0x03
    49f8:	12 c0       	rjmp	.+36     	; 0x4a1e <xTaskDelayUntil+0x9e>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    49fa:	ef 81       	ldd	r30, Y+7	; 0x07
    49fc:	f8 85       	ldd	r31, Y+8	; 0x08
    49fe:	20 81       	ld	r18, Z
    4a00:	31 81       	ldd	r19, Z+1	; 0x01
    4a02:	8d 81       	ldd	r24, Y+5	; 0x05
    4a04:	9e 81       	ldd	r25, Y+6	; 0x06
    4a06:	82 17       	cp	r24, r18
    4a08:	93 07       	cpc	r25, r19
    4a0a:	38 f0       	brcs	.+14     	; 0x4a1a <xTaskDelayUntil+0x9a>
    4a0c:	2d 81       	ldd	r18, Y+5	; 0x05
    4a0e:	3e 81       	ldd	r19, Y+6	; 0x06
    4a10:	89 81       	ldd	r24, Y+1	; 0x01
    4a12:	9a 81       	ldd	r25, Y+2	; 0x02
    4a14:	82 17       	cp	r24, r18
    4a16:	93 07       	cpc	r25, r19
    4a18:	10 f4       	brcc	.+4      	; 0x4a1e <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    4a1a:	81 e0       	ldi	r24, 0x01	; 1
    4a1c:	8b 83       	std	Y+3, r24	; 0x03
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    4a1e:	ef 81       	ldd	r30, Y+7	; 0x07
    4a20:	f8 85       	ldd	r31, Y+8	; 0x08
    4a22:	8d 81       	ldd	r24, Y+5	; 0x05
    4a24:	9e 81       	ldd	r25, Y+6	; 0x06
    4a26:	91 83       	std	Z+1, r25	; 0x01
    4a28:	80 83       	st	Z, r24

            if( xShouldDelay != pdFALSE )
    4a2a:	8b 81       	ldd	r24, Y+3	; 0x03
    4a2c:	88 23       	and	r24, r24
    4a2e:	49 f0       	breq	.+18     	; 0x4a42 <xTaskDelayUntil+0xc2>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    4a30:	8d 81       	ldd	r24, Y+5	; 0x05
    4a32:	9e 81       	ldd	r25, Y+6	; 0x06
    4a34:	29 81       	ldd	r18, Y+1	; 0x01
    4a36:	3a 81       	ldd	r19, Y+2	; 0x02
    4a38:	82 1b       	sub	r24, r18
    4a3a:	93 0b       	sbc	r25, r19
    4a3c:	60 e0       	ldi	r22, 0x00	; 0
    4a3e:	0e 94 d5 35 	call	0x6baa	; 0x6baa <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    4a42:	0e 94 a8 25 	call	0x4b50	; 0x4b50 <xTaskResumeAll>
    4a46:	8c 83       	std	Y+4, r24	; 0x04

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    4a48:	8c 81       	ldd	r24, Y+4	; 0x04
    4a4a:	88 23       	and	r24, r24
    4a4c:	11 f4       	brne	.+4      	; 0x4a52 <xTaskDelayUntil+0xd2>
        {
            portYIELD_WITHIN_API();
    4a4e:	0e 94 86 10 	call	0x210c	; 0x210c <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    4a52:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    4a54:	2a 96       	adiw	r28, 0x0a	; 10
    4a56:	0f b6       	in	r0, 0x3f	; 63
    4a58:	f8 94       	cli
    4a5a:	de bf       	out	0x3e, r29	; 62
    4a5c:	0f be       	out	0x3f, r0	; 63
    4a5e:	cd bf       	out	0x3d, r28	; 61
    4a60:	cf 91       	pop	r28
    4a62:	df 91       	pop	r29
    4a64:	08 95       	ret

00004a66 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    4a66:	df 93       	push	r29
    4a68:	cf 93       	push	r28
    4a6a:	00 d0       	rcall	.+0      	; 0x4a6c <vTaskDelay+0x6>
    4a6c:	0f 92       	push	r0
    4a6e:	cd b7       	in	r28, 0x3d	; 61
    4a70:	de b7       	in	r29, 0x3e	; 62
    4a72:	9b 83       	std	Y+3, r25	; 0x03
    4a74:	8a 83       	std	Y+2, r24	; 0x02
        BaseType_t xAlreadyYielded = pdFALSE;
    4a76:	19 82       	std	Y+1, r1	; 0x01

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    4a78:	8a 81       	ldd	r24, Y+2	; 0x02
    4a7a:	9b 81       	ldd	r25, Y+3	; 0x03
    4a7c:	00 97       	sbiw	r24, 0x00	; 0
    4a7e:	51 f0       	breq	.+20     	; 0x4a94 <vTaskDelay+0x2e>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    4a80:	0e 94 9c 25 	call	0x4b38	; 0x4b38 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    4a84:	8a 81       	ldd	r24, Y+2	; 0x02
    4a86:	9b 81       	ldd	r25, Y+3	; 0x03
    4a88:	60 e0       	ldi	r22, 0x00	; 0
    4a8a:	0e 94 d5 35 	call	0x6baa	; 0x6baa <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    4a8e:	0e 94 a8 25 	call	0x4b50	; 0x4b50 <xTaskResumeAll>
    4a92:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    4a94:	89 81       	ldd	r24, Y+1	; 0x01
    4a96:	88 23       	and	r24, r24
    4a98:	11 f4       	brne	.+4      	; 0x4a9e <vTaskDelay+0x38>
        {
            portYIELD_WITHIN_API();
    4a9a:	0e 94 86 10 	call	0x210c	; 0x210c <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    4a9e:	0f 90       	pop	r0
    4aa0:	0f 90       	pop	r0
    4aa2:	0f 90       	pop	r0
    4aa4:	cf 91       	pop	r28
    4aa6:	df 91       	pop	r29
    4aa8:	08 95       	ret

00004aaa <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    4aaa:	ef 92       	push	r14
    4aac:	ff 92       	push	r15
    4aae:	0f 93       	push	r16
    4ab0:	df 93       	push	r29
    4ab2:	cf 93       	push	r28
    4ab4:	00 d0       	rcall	.+0      	; 0x4ab6 <vTaskStartScheduler+0xc>
    4ab6:	cd b7       	in	r28, 0x3d	; 61
    4ab8:	de b7       	in	r29, 0x3e	; 62
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
    4aba:	8c e5       	ldi	r24, 0x5C	; 92
    4abc:	9d e2       	ldi	r25, 0x2D	; 45
    4abe:	23 e7       	ldi	r18, 0x73	; 115
    4ac0:	30 e0       	ldi	r19, 0x00	; 0
    4ac2:	e5 e5       	ldi	r30, 0x55	; 85
    4ac4:	f7 e0       	ldi	r31, 0x07	; 7
    4ac6:	b9 01       	movw	r22, r18
    4ac8:	45 e5       	ldi	r20, 0x55	; 85
    4aca:	50 e0       	ldi	r21, 0x00	; 0
    4acc:	20 e0       	ldi	r18, 0x00	; 0
    4ace:	30 e0       	ldi	r19, 0x00	; 0
    4ad0:	00 e0       	ldi	r16, 0x00	; 0
    4ad2:	7f 01       	movw	r14, r30
    4ad4:	0e 94 4b 22 	call	0x4496	; 0x4496 <xTaskCreate>
    4ad8:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif /* configSUPPORT_STATIC_ALLOCATION */

    #if ( configUSE_TIMERS == 1 )
        {
            if( xReturn == pdPASS )
    4ada:	89 81       	ldd	r24, Y+1	; 0x01
    4adc:	81 30       	cpi	r24, 0x01	; 1
    4ade:	19 f4       	brne	.+6      	; 0x4ae6 <vTaskStartScheduler+0x3c>
            {
                xReturn = xTimerCreateTimerTask();
    4ae0:	0e 94 3b 36 	call	0x6c76	; 0x6c76 <xTimerCreateTimerTask>
    4ae4:	89 83       	std	Y+1, r24	; 0x01
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    4ae6:	89 81       	ldd	r24, Y+1	; 0x01
    4ae8:	81 30       	cpi	r24, 0x01	; 1
    4aea:	81 f4       	brne	.+32     	; 0x4b0c <vTaskStartScheduler+0x62>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    4aec:	f8 94       	cli
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
    4aee:	8f ef       	ldi	r24, 0xFF	; 255
    4af0:	9f ef       	ldi	r25, 0xFF	; 255
    4af2:	90 93 54 07 	sts	0x0754, r25
    4af6:	80 93 53 07 	sts	0x0753, r24
        xSchedulerRunning = pdTRUE;
    4afa:	81 e0       	ldi	r24, 0x01	; 1
    4afc:	80 93 4d 07 	sts	0x074D, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    4b00:	10 92 4b 07 	sts	0x074B, r1
    4b04:	10 92 4a 07 	sts	0x074A, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
    4b08:	0e 94 4a 10 	call	0x2094	; 0x2094 <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    4b0c:	80 91 88 00 	lds	r24, 0x0088
}
    4b10:	0f 90       	pop	r0
    4b12:	0f 90       	pop	r0
    4b14:	cf 91       	pop	r28
    4b16:	df 91       	pop	r29
    4b18:	0f 91       	pop	r16
    4b1a:	ff 90       	pop	r15
    4b1c:	ef 90       	pop	r14
    4b1e:	08 95       	ret

00004b20 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    4b20:	df 93       	push	r29
    4b22:	cf 93       	push	r28
    4b24:	cd b7       	in	r28, 0x3d	; 61
    4b26:	de b7       	in	r29, 0x3e	; 62
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    4b28:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    4b2a:	10 92 4d 07 	sts	0x074D, r1
    vPortEndScheduler();
    4b2e:	0e 94 7f 10 	call	0x20fe	; 0x20fe <vPortEndScheduler>
}
    4b32:	cf 91       	pop	r28
    4b34:	df 91       	pop	r29
    4b36:	08 95       	ret

00004b38 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    4b38:	df 93       	push	r29
    4b3a:	cf 93       	push	r28
    4b3c:	cd b7       	in	r28, 0x3d	; 61
    4b3e:	de b7       	in	r29, 0x3e	; 62
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    4b40:	80 91 57 07 	lds	r24, 0x0757
    4b44:	8f 5f       	subi	r24, 0xFF	; 255
    4b46:	80 93 57 07 	sts	0x0757, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    4b4a:	cf 91       	pop	r28
    4b4c:	df 91       	pop	r29
    4b4e:	08 95       	ret

00004b50 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    4b50:	df 93       	push	r29
    4b52:	cf 93       	push	r28
    4b54:	cd b7       	in	r28, 0x3d	; 61
    4b56:	de b7       	in	r29, 0x3e	; 62
    4b58:	2b 97       	sbiw	r28, 0x0b	; 11
    4b5a:	0f b6       	in	r0, 0x3f	; 63
    4b5c:	f8 94       	cli
    4b5e:	de bf       	out	0x3e, r29	; 62
    4b60:	0f be       	out	0x3f, r0	; 63
    4b62:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB = NULL;
    4b64:	1b 86       	std	Y+11, r1	; 0x0b
    4b66:	1a 86       	std	Y+10, r1	; 0x0a
    BaseType_t xAlreadyYielded = pdFALSE;
    4b68:	19 86       	std	Y+9, r1	; 0x09
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    4b6a:	0f b6       	in	r0, 0x3f	; 63
    4b6c:	f8 94       	cli
    4b6e:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    4b70:	80 91 57 07 	lds	r24, 0x0757
    4b74:	81 50       	subi	r24, 0x01	; 1
    4b76:	80 93 57 07 	sts	0x0757, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4b7a:	80 91 57 07 	lds	r24, 0x0757
    4b7e:	88 23       	and	r24, r24
    4b80:	09 f0       	breq	.+2      	; 0x4b84 <xTaskResumeAll+0x34>
    4b82:	2a c1       	rjmp	.+596    	; 0x4dd8 <xTaskResumeAll+0x288>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    4b84:	80 91 49 07 	lds	r24, 0x0749
    4b88:	88 23       	and	r24, r24
    4b8a:	09 f4       	brne	.+2      	; 0x4b8e <xTaskResumeAll+0x3e>
    4b8c:	25 c1       	rjmp	.+586    	; 0x4dd8 <xTaskResumeAll+0x288>
    4b8e:	f3 c0       	rjmp	.+486    	; 0x4d76 <xTaskResumeAll+0x226>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4b90:	e0 91 97 07 	lds	r30, 0x0797
    4b94:	f0 91 98 07 	lds	r31, 0x0798
    4b98:	86 81       	ldd	r24, Z+6	; 0x06
    4b9a:	97 81       	ldd	r25, Z+7	; 0x07
    4b9c:	9b 87       	std	Y+11, r25	; 0x0b
    4b9e:	8a 87       	std	Y+10, r24	; 0x0a
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    4ba0:	ea 85       	ldd	r30, Y+10	; 0x0a
    4ba2:	fb 85       	ldd	r31, Y+11	; 0x0b
    4ba4:	84 89       	ldd	r24, Z+20	; 0x14
    4ba6:	95 89       	ldd	r25, Z+21	; 0x15
    4ba8:	98 87       	std	Y+8, r25	; 0x08
    4baa:	8f 83       	std	Y+7, r24	; 0x07
    4bac:	ea 85       	ldd	r30, Y+10	; 0x0a
    4bae:	fb 85       	ldd	r31, Y+11	; 0x0b
    4bb0:	a6 85       	ldd	r26, Z+14	; 0x0e
    4bb2:	b7 85       	ldd	r27, Z+15	; 0x0f
    4bb4:	ea 85       	ldd	r30, Y+10	; 0x0a
    4bb6:	fb 85       	ldd	r31, Y+11	; 0x0b
    4bb8:	80 89       	ldd	r24, Z+16	; 0x10
    4bba:	91 89       	ldd	r25, Z+17	; 0x11
    4bbc:	15 96       	adiw	r26, 0x05	; 5
    4bbe:	9c 93       	st	X, r25
    4bc0:	8e 93       	st	-X, r24
    4bc2:	14 97       	sbiw	r26, 0x04	; 4
    4bc4:	ea 85       	ldd	r30, Y+10	; 0x0a
    4bc6:	fb 85       	ldd	r31, Y+11	; 0x0b
    4bc8:	a0 89       	ldd	r26, Z+16	; 0x10
    4bca:	b1 89       	ldd	r27, Z+17	; 0x11
    4bcc:	ea 85       	ldd	r30, Y+10	; 0x0a
    4bce:	fb 85       	ldd	r31, Y+11	; 0x0b
    4bd0:	86 85       	ldd	r24, Z+14	; 0x0e
    4bd2:	97 85       	ldd	r25, Z+15	; 0x0f
    4bd4:	13 96       	adiw	r26, 0x03	; 3
    4bd6:	9c 93       	st	X, r25
    4bd8:	8e 93       	st	-X, r24
    4bda:	12 97       	sbiw	r26, 0x02	; 2
    4bdc:	ef 81       	ldd	r30, Y+7	; 0x07
    4bde:	f8 85       	ldd	r31, Y+8	; 0x08
    4be0:	21 81       	ldd	r18, Z+1	; 0x01
    4be2:	32 81       	ldd	r19, Z+2	; 0x02
    4be4:	8a 85       	ldd	r24, Y+10	; 0x0a
    4be6:	9b 85       	ldd	r25, Y+11	; 0x0b
    4be8:	0c 96       	adiw	r24, 0x0c	; 12
    4bea:	28 17       	cp	r18, r24
    4bec:	39 07       	cpc	r19, r25
    4bee:	41 f4       	brne	.+16     	; 0x4c00 <xTaskResumeAll+0xb0>
    4bf0:	ea 85       	ldd	r30, Y+10	; 0x0a
    4bf2:	fb 85       	ldd	r31, Y+11	; 0x0b
    4bf4:	80 89       	ldd	r24, Z+16	; 0x10
    4bf6:	91 89       	ldd	r25, Z+17	; 0x11
    4bf8:	ef 81       	ldd	r30, Y+7	; 0x07
    4bfa:	f8 85       	ldd	r31, Y+8	; 0x08
    4bfc:	92 83       	std	Z+2, r25	; 0x02
    4bfe:	81 83       	std	Z+1, r24	; 0x01
    4c00:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c02:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c04:	15 8a       	std	Z+21, r1	; 0x15
    4c06:	14 8a       	std	Z+20, r1	; 0x14
    4c08:	ef 81       	ldd	r30, Y+7	; 0x07
    4c0a:	f8 85       	ldd	r31, Y+8	; 0x08
    4c0c:	80 81       	ld	r24, Z
    4c0e:	81 50       	subi	r24, 0x01	; 1
    4c10:	ef 81       	ldd	r30, Y+7	; 0x07
    4c12:	f8 85       	ldd	r31, Y+8	; 0x08
    4c14:	80 83       	st	Z, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    4c16:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c18:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c1a:	82 85       	ldd	r24, Z+10	; 0x0a
    4c1c:	93 85       	ldd	r25, Z+11	; 0x0b
    4c1e:	9e 83       	std	Y+6, r25	; 0x06
    4c20:	8d 83       	std	Y+5, r24	; 0x05
    4c22:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c24:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c26:	a4 81       	ldd	r26, Z+4	; 0x04
    4c28:	b5 81       	ldd	r27, Z+5	; 0x05
    4c2a:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c2c:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c2e:	86 81       	ldd	r24, Z+6	; 0x06
    4c30:	97 81       	ldd	r25, Z+7	; 0x07
    4c32:	15 96       	adiw	r26, 0x05	; 5
    4c34:	9c 93       	st	X, r25
    4c36:	8e 93       	st	-X, r24
    4c38:	14 97       	sbiw	r26, 0x04	; 4
    4c3a:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c3c:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c3e:	a6 81       	ldd	r26, Z+6	; 0x06
    4c40:	b7 81       	ldd	r27, Z+7	; 0x07
    4c42:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c44:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c46:	84 81       	ldd	r24, Z+4	; 0x04
    4c48:	95 81       	ldd	r25, Z+5	; 0x05
    4c4a:	13 96       	adiw	r26, 0x03	; 3
    4c4c:	9c 93       	st	X, r25
    4c4e:	8e 93       	st	-X, r24
    4c50:	12 97       	sbiw	r26, 0x02	; 2
    4c52:	ed 81       	ldd	r30, Y+5	; 0x05
    4c54:	fe 81       	ldd	r31, Y+6	; 0x06
    4c56:	21 81       	ldd	r18, Z+1	; 0x01
    4c58:	32 81       	ldd	r19, Z+2	; 0x02
    4c5a:	8a 85       	ldd	r24, Y+10	; 0x0a
    4c5c:	9b 85       	ldd	r25, Y+11	; 0x0b
    4c5e:	02 96       	adiw	r24, 0x02	; 2
    4c60:	28 17       	cp	r18, r24
    4c62:	39 07       	cpc	r19, r25
    4c64:	41 f4       	brne	.+16     	; 0x4c76 <xTaskResumeAll+0x126>
    4c66:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c68:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c6a:	86 81       	ldd	r24, Z+6	; 0x06
    4c6c:	97 81       	ldd	r25, Z+7	; 0x07
    4c6e:	ed 81       	ldd	r30, Y+5	; 0x05
    4c70:	fe 81       	ldd	r31, Y+6	; 0x06
    4c72:	92 83       	std	Z+2, r25	; 0x02
    4c74:	81 83       	std	Z+1, r24	; 0x01
    4c76:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c78:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c7a:	13 86       	std	Z+11, r1	; 0x0b
    4c7c:	12 86       	std	Z+10, r1	; 0x0a
    4c7e:	ed 81       	ldd	r30, Y+5	; 0x05
    4c80:	fe 81       	ldd	r31, Y+6	; 0x06
    4c82:	80 81       	ld	r24, Z
    4c84:	81 50       	subi	r24, 0x01	; 1
    4c86:	ed 81       	ldd	r30, Y+5	; 0x05
    4c88:	fe 81       	ldd	r31, Y+6	; 0x06
    4c8a:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    4c8c:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c8e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c90:	96 89       	ldd	r25, Z+22	; 0x16
    4c92:	80 91 4c 07 	lds	r24, 0x074C
    4c96:	89 17       	cp	r24, r25
    4c98:	28 f4       	brcc	.+10     	; 0x4ca4 <xTaskResumeAll+0x154>
    4c9a:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c9c:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c9e:	86 89       	ldd	r24, Z+22	; 0x16
    4ca0:	80 93 4c 07 	sts	0x074C, r24
    4ca4:	ea 85       	ldd	r30, Y+10	; 0x0a
    4ca6:	fb 85       	ldd	r31, Y+11	; 0x0b
    4ca8:	86 89       	ldd	r24, Z+22	; 0x16
    4caa:	28 2f       	mov	r18, r24
    4cac:	30 e0       	ldi	r19, 0x00	; 0
    4cae:	c9 01       	movw	r24, r18
    4cb0:	88 0f       	add	r24, r24
    4cb2:	99 1f       	adc	r25, r25
    4cb4:	88 0f       	add	r24, r24
    4cb6:	99 1f       	adc	r25, r25
    4cb8:	88 0f       	add	r24, r24
    4cba:	99 1f       	adc	r25, r25
    4cbc:	82 0f       	add	r24, r18
    4cbe:	93 1f       	adc	r25, r19
    4cc0:	fc 01       	movw	r30, r24
    4cc2:	e8 5a       	subi	r30, 0xA8	; 168
    4cc4:	f8 4f       	sbci	r31, 0xF8	; 248
    4cc6:	81 81       	ldd	r24, Z+1	; 0x01
    4cc8:	92 81       	ldd	r25, Z+2	; 0x02
    4cca:	9c 83       	std	Y+4, r25	; 0x04
    4ccc:	8b 83       	std	Y+3, r24	; 0x03
    4cce:	ea 85       	ldd	r30, Y+10	; 0x0a
    4cd0:	fb 85       	ldd	r31, Y+11	; 0x0b
    4cd2:	8b 81       	ldd	r24, Y+3	; 0x03
    4cd4:	9c 81       	ldd	r25, Y+4	; 0x04
    4cd6:	95 83       	std	Z+5, r25	; 0x05
    4cd8:	84 83       	std	Z+4, r24	; 0x04
    4cda:	eb 81       	ldd	r30, Y+3	; 0x03
    4cdc:	fc 81       	ldd	r31, Y+4	; 0x04
    4cde:	84 81       	ldd	r24, Z+4	; 0x04
    4ce0:	95 81       	ldd	r25, Z+5	; 0x05
    4ce2:	ea 85       	ldd	r30, Y+10	; 0x0a
    4ce4:	fb 85       	ldd	r31, Y+11	; 0x0b
    4ce6:	97 83       	std	Z+7, r25	; 0x07
    4ce8:	86 83       	std	Z+6, r24	; 0x06
    4cea:	eb 81       	ldd	r30, Y+3	; 0x03
    4cec:	fc 81       	ldd	r31, Y+4	; 0x04
    4cee:	04 80       	ldd	r0, Z+4	; 0x04
    4cf0:	f5 81       	ldd	r31, Z+5	; 0x05
    4cf2:	e0 2d       	mov	r30, r0
    4cf4:	8a 85       	ldd	r24, Y+10	; 0x0a
    4cf6:	9b 85       	ldd	r25, Y+11	; 0x0b
    4cf8:	02 96       	adiw	r24, 0x02	; 2
    4cfa:	93 83       	std	Z+3, r25	; 0x03
    4cfc:	82 83       	std	Z+2, r24	; 0x02
    4cfe:	8a 85       	ldd	r24, Y+10	; 0x0a
    4d00:	9b 85       	ldd	r25, Y+11	; 0x0b
    4d02:	02 96       	adiw	r24, 0x02	; 2
    4d04:	eb 81       	ldd	r30, Y+3	; 0x03
    4d06:	fc 81       	ldd	r31, Y+4	; 0x04
    4d08:	95 83       	std	Z+5, r25	; 0x05
    4d0a:	84 83       	std	Z+4, r24	; 0x04
    4d0c:	ea 85       	ldd	r30, Y+10	; 0x0a
    4d0e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4d10:	86 89       	ldd	r24, Z+22	; 0x16
    4d12:	28 2f       	mov	r18, r24
    4d14:	30 e0       	ldi	r19, 0x00	; 0
    4d16:	c9 01       	movw	r24, r18
    4d18:	88 0f       	add	r24, r24
    4d1a:	99 1f       	adc	r25, r25
    4d1c:	88 0f       	add	r24, r24
    4d1e:	99 1f       	adc	r25, r25
    4d20:	88 0f       	add	r24, r24
    4d22:	99 1f       	adc	r25, r25
    4d24:	82 0f       	add	r24, r18
    4d26:	93 1f       	adc	r25, r19
    4d28:	88 5a       	subi	r24, 0xA8	; 168
    4d2a:	98 4f       	sbci	r25, 0xF8	; 248
    4d2c:	ea 85       	ldd	r30, Y+10	; 0x0a
    4d2e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4d30:	93 87       	std	Z+11, r25	; 0x0b
    4d32:	82 87       	std	Z+10, r24	; 0x0a
    4d34:	ea 85       	ldd	r30, Y+10	; 0x0a
    4d36:	fb 85       	ldd	r31, Y+11	; 0x0b
    4d38:	86 89       	ldd	r24, Z+22	; 0x16
    4d3a:	28 2f       	mov	r18, r24
    4d3c:	30 e0       	ldi	r19, 0x00	; 0
    4d3e:	c9 01       	movw	r24, r18
    4d40:	88 0f       	add	r24, r24
    4d42:	99 1f       	adc	r25, r25
    4d44:	88 0f       	add	r24, r24
    4d46:	99 1f       	adc	r25, r25
    4d48:	88 0f       	add	r24, r24
    4d4a:	99 1f       	adc	r25, r25
    4d4c:	82 0f       	add	r24, r18
    4d4e:	93 1f       	adc	r25, r19
    4d50:	fc 01       	movw	r30, r24
    4d52:	e8 5a       	subi	r30, 0xA8	; 168
    4d54:	f8 4f       	sbci	r31, 0xF8	; 248
    4d56:	80 81       	ld	r24, Z
    4d58:	8f 5f       	subi	r24, 0xFF	; 255
    4d5a:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4d5c:	ea 85       	ldd	r30, Y+10	; 0x0a
    4d5e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4d60:	96 89       	ldd	r25, Z+22	; 0x16
    4d62:	e0 91 46 07 	lds	r30, 0x0746
    4d66:	f0 91 47 07 	lds	r31, 0x0747
    4d6a:	86 89       	ldd	r24, Z+22	; 0x16
    4d6c:	98 17       	cp	r25, r24
    4d6e:	18 f0       	brcs	.+6      	; 0x4d76 <xTaskResumeAll+0x226>
                    {
                        xYieldPending = pdTRUE;
    4d70:	81 e0       	ldi	r24, 0x01	; 1
    4d72:	80 93 50 07 	sts	0x0750, r24
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    4d76:	80 91 92 07 	lds	r24, 0x0792
    4d7a:	88 23       	and	r24, r24
    4d7c:	09 f0       	breq	.+2      	; 0x4d80 <xTaskResumeAll+0x230>
    4d7e:	08 cf       	rjmp	.-496    	; 0x4b90 <xTaskResumeAll+0x40>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    4d80:	8a 85       	ldd	r24, Y+10	; 0x0a
    4d82:	9b 85       	ldd	r25, Y+11	; 0x0b
    4d84:	00 97       	sbiw	r24, 0x00	; 0
    4d86:	11 f0       	breq	.+4      	; 0x4d8c <xTaskResumeAll+0x23c>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    4d88:	0e 94 ee 2d 	call	0x5bdc	; 0x5bdc <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    4d8c:	80 91 4e 07 	lds	r24, 0x074E
    4d90:	90 91 4f 07 	lds	r25, 0x074F
    4d94:	9a 83       	std	Y+2, r25	; 0x02
    4d96:	89 83       	std	Y+1, r24	; 0x01

                    if( xPendedCounts > ( TickType_t ) 0U )
    4d98:	89 81       	ldd	r24, Y+1	; 0x01
    4d9a:	9a 81       	ldd	r25, Y+2	; 0x02
    4d9c:	00 97       	sbiw	r24, 0x00	; 0
    4d9e:	a1 f0       	breq	.+40     	; 0x4dc8 <xTaskResumeAll+0x278>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    4da0:	0e 94 75 27 	call	0x4eea	; 0x4eea <xTaskIncrementTick>
    4da4:	88 23       	and	r24, r24
    4da6:	19 f0       	breq	.+6      	; 0x4dae <xTaskResumeAll+0x25e>
                            {
                                xYieldPending = pdTRUE;
    4da8:	81 e0       	ldi	r24, 0x01	; 1
    4daa:	80 93 50 07 	sts	0x0750, r24
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    4dae:	89 81       	ldd	r24, Y+1	; 0x01
    4db0:	9a 81       	ldd	r25, Y+2	; 0x02
    4db2:	01 97       	sbiw	r24, 0x01	; 1
    4db4:	9a 83       	std	Y+2, r25	; 0x02
    4db6:	89 83       	std	Y+1, r24	; 0x01
                        } while( xPendedCounts > ( TickType_t ) 0U );
    4db8:	89 81       	ldd	r24, Y+1	; 0x01
    4dba:	9a 81       	ldd	r25, Y+2	; 0x02
    4dbc:	00 97       	sbiw	r24, 0x00	; 0
    4dbe:	81 f7       	brne	.-32     	; 0x4da0 <xTaskResumeAll+0x250>

                        xPendedTicks = 0;
    4dc0:	10 92 4f 07 	sts	0x074F, r1
    4dc4:	10 92 4e 07 	sts	0x074E, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    4dc8:	80 91 50 07 	lds	r24, 0x0750
    4dcc:	88 23       	and	r24, r24
    4dce:	21 f0       	breq	.+8      	; 0x4dd8 <xTaskResumeAll+0x288>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
    4dd0:	81 e0       	ldi	r24, 0x01	; 1
    4dd2:	89 87       	std	Y+9, r24	; 0x09
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    4dd4:	0e 94 86 10 	call	0x210c	; 0x210c <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    4dd8:	0f 90       	pop	r0
    4dda:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
    4ddc:	89 85       	ldd	r24, Y+9	; 0x09
}
    4dde:	2b 96       	adiw	r28, 0x0b	; 11
    4de0:	0f b6       	in	r0, 0x3f	; 63
    4de2:	f8 94       	cli
    4de4:	de bf       	out	0x3e, r29	; 62
    4de6:	0f be       	out	0x3f, r0	; 63
    4de8:	cd bf       	out	0x3d, r28	; 61
    4dea:	cf 91       	pop	r28
    4dec:	df 91       	pop	r29
    4dee:	08 95       	ret

00004df0 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    4df0:	df 93       	push	r29
    4df2:	cf 93       	push	r28
    4df4:	00 d0       	rcall	.+0      	; 0x4df6 <xTaskGetTickCount+0x6>
    4df6:	cd b7       	in	r28, 0x3d	; 61
    4df8:	de b7       	in	r29, 0x3e	; 62
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    4dfa:	0f b6       	in	r0, 0x3f	; 63
    4dfc:	f8 94       	cli
    4dfe:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    4e00:	80 91 4a 07 	lds	r24, 0x074A
    4e04:	90 91 4b 07 	lds	r25, 0x074B
    4e08:	9a 83       	std	Y+2, r25	; 0x02
    4e0a:	89 83       	std	Y+1, r24	; 0x01
    }
    portTICK_TYPE_EXIT_CRITICAL();
    4e0c:	0f 90       	pop	r0
    4e0e:	0f be       	out	0x3f, r0	; 63

    return xTicks;
    4e10:	89 81       	ldd	r24, Y+1	; 0x01
    4e12:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4e14:	0f 90       	pop	r0
    4e16:	0f 90       	pop	r0
    4e18:	cf 91       	pop	r28
    4e1a:	df 91       	pop	r29
    4e1c:	08 95       	ret

00004e1e <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    4e1e:	df 93       	push	r29
    4e20:	cf 93       	push	r28
    4e22:	00 d0       	rcall	.+0      	; 0x4e24 <xTaskGetTickCountFromISR+0x6>
    4e24:	0f 92       	push	r0
    4e26:	cd b7       	in	r28, 0x3d	; 61
    4e28:	de b7       	in	r29, 0x3e	; 62
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    4e2a:	19 82       	std	Y+1, r1	; 0x01
    {
        xReturn = xTickCount;
    4e2c:	80 91 4a 07 	lds	r24, 0x074A
    4e30:	90 91 4b 07 	lds	r25, 0x074B
    4e34:	9b 83       	std	Y+3, r25	; 0x03
    4e36:	8a 83       	std	Y+2, r24	; 0x02
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    4e38:	8a 81       	ldd	r24, Y+2	; 0x02
    4e3a:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4e3c:	0f 90       	pop	r0
    4e3e:	0f 90       	pop	r0
    4e40:	0f 90       	pop	r0
    4e42:	cf 91       	pop	r28
    4e44:	df 91       	pop	r29
    4e46:	08 95       	ret

00004e48 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    4e48:	df 93       	push	r29
    4e4a:	cf 93       	push	r28
    4e4c:	cd b7       	in	r28, 0x3d	; 61
    4e4e:	de b7       	in	r29, 0x3e	; 62
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    4e50:	80 91 49 07 	lds	r24, 0x0749
}
    4e54:	cf 91       	pop	r28
    4e56:	df 91       	pop	r29
    4e58:	08 95       	ret

00004e5a <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    4e5a:	df 93       	push	r29
    4e5c:	cf 93       	push	r28
    4e5e:	00 d0       	rcall	.+0      	; 0x4e60 <pcTaskGetName+0x6>
    4e60:	00 d0       	rcall	.+0      	; 0x4e62 <pcTaskGetName+0x8>
    4e62:	00 d0       	rcall	.+0      	; 0x4e64 <pcTaskGetName+0xa>
    4e64:	cd b7       	in	r28, 0x3d	; 61
    4e66:	de b7       	in	r29, 0x3e	; 62
    4e68:	9c 83       	std	Y+4, r25	; 0x04
    4e6a:	8b 83       	std	Y+3, r24	; 0x03
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    4e6c:	8b 81       	ldd	r24, Y+3	; 0x03
    4e6e:	9c 81       	ldd	r25, Y+4	; 0x04
    4e70:	00 97       	sbiw	r24, 0x00	; 0
    4e72:	39 f4       	brne	.+14     	; 0x4e82 <pcTaskGetName+0x28>
    4e74:	80 91 46 07 	lds	r24, 0x0746
    4e78:	90 91 47 07 	lds	r25, 0x0747
    4e7c:	9e 83       	std	Y+6, r25	; 0x06
    4e7e:	8d 83       	std	Y+5, r24	; 0x05
    4e80:	04 c0       	rjmp	.+8      	; 0x4e8a <pcTaskGetName+0x30>
    4e82:	8b 81       	ldd	r24, Y+3	; 0x03
    4e84:	9c 81       	ldd	r25, Y+4	; 0x04
    4e86:	9e 83       	std	Y+6, r25	; 0x06
    4e88:	8d 83       	std	Y+5, r24	; 0x05
    4e8a:	8d 81       	ldd	r24, Y+5	; 0x05
    4e8c:	9e 81       	ldd	r25, Y+6	; 0x06
    4e8e:	9a 83       	std	Y+2, r25	; 0x02
    4e90:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
    4e92:	89 81       	ldd	r24, Y+1	; 0x01
    4e94:	9a 81       	ldd	r25, Y+2	; 0x02
    4e96:	49 96       	adiw	r24, 0x19	; 25
}
    4e98:	26 96       	adiw	r28, 0x06	; 6
    4e9a:	0f b6       	in	r0, 0x3f	; 63
    4e9c:	f8 94       	cli
    4e9e:	de bf       	out	0x3e, r29	; 62
    4ea0:	0f be       	out	0x3f, r0	; 63
    4ea2:	cd bf       	out	0x3d, r28	; 61
    4ea4:	cf 91       	pop	r28
    4ea6:	df 91       	pop	r29
    4ea8:	08 95       	ret

00004eaa <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    4eaa:	df 93       	push	r29
    4eac:	cf 93       	push	r28
    4eae:	00 d0       	rcall	.+0      	; 0x4eb0 <xTaskCatchUpTicks+0x6>
    4eb0:	0f 92       	push	r0
    4eb2:	cd b7       	in	r28, 0x3d	; 61
    4eb4:	de b7       	in	r29, 0x3e	; 62
    4eb6:	9b 83       	std	Y+3, r25	; 0x03
    4eb8:	8a 83       	std	Y+2, r24	; 0x02
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    4eba:	0e 94 9c 25 	call	0x4b38	; 0x4b38 <vTaskSuspendAll>
    xPendedTicks += xTicksToCatchUp;
    4ebe:	20 91 4e 07 	lds	r18, 0x074E
    4ec2:	30 91 4f 07 	lds	r19, 0x074F
    4ec6:	8a 81       	ldd	r24, Y+2	; 0x02
    4ec8:	9b 81       	ldd	r25, Y+3	; 0x03
    4eca:	82 0f       	add	r24, r18
    4ecc:	93 1f       	adc	r25, r19
    4ece:	90 93 4f 07 	sts	0x074F, r25
    4ed2:	80 93 4e 07 	sts	0x074E, r24
    xYieldOccurred = xTaskResumeAll();
    4ed6:	0e 94 a8 25 	call	0x4b50	; 0x4b50 <xTaskResumeAll>
    4eda:	89 83       	std	Y+1, r24	; 0x01

    return xYieldOccurred;
    4edc:	89 81       	ldd	r24, Y+1	; 0x01
}
    4ede:	0f 90       	pop	r0
    4ee0:	0f 90       	pop	r0
    4ee2:	0f 90       	pop	r0
    4ee4:	cf 91       	pop	r28
    4ee6:	df 91       	pop	r29
    4ee8:	08 95       	ret

00004eea <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    4eea:	df 93       	push	r29
    4eec:	cf 93       	push	r28
    4eee:	cd b7       	in	r28, 0x3d	; 61
    4ef0:	de b7       	in	r29, 0x3e	; 62
    4ef2:	2f 97       	sbiw	r28, 0x0f	; 15
    4ef4:	0f b6       	in	r0, 0x3f	; 63
    4ef6:	f8 94       	cli
    4ef8:	de bf       	out	0x3e, r29	; 62
    4efa:	0f be       	out	0x3f, r0	; 63
    4efc:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    4efe:	1b 86       	std	Y+11, r1	; 0x0b
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4f00:	80 91 57 07 	lds	r24, 0x0757
    4f04:	88 23       	and	r24, r24
    4f06:	09 f0       	breq	.+2      	; 0x4f0a <xTaskIncrementTick+0x20>
    4f08:	74 c1       	rjmp	.+744    	; 0x51f2 <xTaskIncrementTick+0x308>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    4f0a:	80 91 4a 07 	lds	r24, 0x074A
    4f0e:	90 91 4b 07 	lds	r25, 0x074B
    4f12:	01 96       	adiw	r24, 0x01	; 1
    4f14:	9a 87       	std	Y+10, r25	; 0x0a
    4f16:	89 87       	std	Y+9, r24	; 0x09

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    4f18:	89 85       	ldd	r24, Y+9	; 0x09
    4f1a:	9a 85       	ldd	r25, Y+10	; 0x0a
    4f1c:	90 93 4b 07 	sts	0x074B, r25
    4f20:	80 93 4a 07 	sts	0x074A, r24

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    4f24:	89 85       	ldd	r24, Y+9	; 0x09
    4f26:	9a 85       	ldd	r25, Y+10	; 0x0a
    4f28:	00 97       	sbiw	r24, 0x00	; 0
    4f2a:	d9 f4       	brne	.+54     	; 0x4f62 <xTaskIncrementTick+0x78>
        {
            taskSWITCH_DELAYED_LISTS();
    4f2c:	80 91 8e 07 	lds	r24, 0x078E
    4f30:	90 91 8f 07 	lds	r25, 0x078F
    4f34:	98 87       	std	Y+8, r25	; 0x08
    4f36:	8f 83       	std	Y+7, r24	; 0x07
    4f38:	80 91 90 07 	lds	r24, 0x0790
    4f3c:	90 91 91 07 	lds	r25, 0x0791
    4f40:	90 93 8f 07 	sts	0x078F, r25
    4f44:	80 93 8e 07 	sts	0x078E, r24
    4f48:	8f 81       	ldd	r24, Y+7	; 0x07
    4f4a:	98 85       	ldd	r25, Y+8	; 0x08
    4f4c:	90 93 91 07 	sts	0x0791, r25
    4f50:	80 93 90 07 	sts	0x0790, r24
    4f54:	80 91 51 07 	lds	r24, 0x0751
    4f58:	8f 5f       	subi	r24, 0xFF	; 255
    4f5a:	80 93 51 07 	sts	0x0751, r24
    4f5e:	0e 94 ee 2d 	call	0x5bdc	; 0x5bdc <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    4f62:	20 91 53 07 	lds	r18, 0x0753
    4f66:	30 91 54 07 	lds	r19, 0x0754
    4f6a:	89 85       	ldd	r24, Y+9	; 0x09
    4f6c:	9a 85       	ldd	r25, Y+10	; 0x0a
    4f6e:	82 17       	cp	r24, r18
    4f70:	93 07       	cpc	r25, r19
    4f72:	08 f4       	brcc	.+2      	; 0x4f76 <xTaskIncrementTick+0x8c>
    4f74:	1f c1       	rjmp	.+574    	; 0x51b4 <xTaskIncrementTick+0x2ca>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4f76:	e0 91 8e 07 	lds	r30, 0x078E
    4f7a:	f0 91 8f 07 	lds	r31, 0x078F
    4f7e:	80 81       	ld	r24, Z
    4f80:	88 23       	and	r24, r24
    4f82:	39 f4       	brne	.+14     	; 0x4f92 <xTaskIncrementTick+0xa8>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4f84:	8f ef       	ldi	r24, 0xFF	; 255
    4f86:	9f ef       	ldi	r25, 0xFF	; 255
    4f88:	90 93 54 07 	sts	0x0754, r25
    4f8c:	80 93 53 07 	sts	0x0753, r24
    4f90:	11 c1       	rjmp	.+546    	; 0x51b4 <xTaskIncrementTick+0x2ca>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4f92:	e0 91 8e 07 	lds	r30, 0x078E
    4f96:	f0 91 8f 07 	lds	r31, 0x078F
    4f9a:	05 80       	ldd	r0, Z+5	; 0x05
    4f9c:	f6 81       	ldd	r31, Z+6	; 0x06
    4f9e:	e0 2d       	mov	r30, r0
    4fa0:	86 81       	ldd	r24, Z+6	; 0x06
    4fa2:	97 81       	ldd	r25, Z+7	; 0x07
    4fa4:	9f 87       	std	Y+15, r25	; 0x0f
    4fa6:	8e 87       	std	Y+14, r24	; 0x0e
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    4fa8:	ee 85       	ldd	r30, Y+14	; 0x0e
    4faa:	ff 85       	ldd	r31, Y+15	; 0x0f
    4fac:	82 81       	ldd	r24, Z+2	; 0x02
    4fae:	93 81       	ldd	r25, Z+3	; 0x03
    4fb0:	9d 87       	std	Y+13, r25	; 0x0d
    4fb2:	8c 87       	std	Y+12, r24	; 0x0c

                    if( xConstTickCount < xItemValue )
    4fb4:	29 85       	ldd	r18, Y+9	; 0x09
    4fb6:	3a 85       	ldd	r19, Y+10	; 0x0a
    4fb8:	8c 85       	ldd	r24, Y+12	; 0x0c
    4fba:	9d 85       	ldd	r25, Y+13	; 0x0d
    4fbc:	28 17       	cp	r18, r24
    4fbe:	39 07       	cpc	r19, r25
    4fc0:	38 f4       	brcc	.+14     	; 0x4fd0 <xTaskIncrementTick+0xe6>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    4fc2:	8c 85       	ldd	r24, Y+12	; 0x0c
    4fc4:	9d 85       	ldd	r25, Y+13	; 0x0d
    4fc6:	90 93 54 07 	sts	0x0754, r25
    4fca:	80 93 53 07 	sts	0x0753, r24
    4fce:	f2 c0       	rjmp	.+484    	; 0x51b4 <xTaskIncrementTick+0x2ca>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    4fd0:	ee 85       	ldd	r30, Y+14	; 0x0e
    4fd2:	ff 85       	ldd	r31, Y+15	; 0x0f
    4fd4:	82 85       	ldd	r24, Z+10	; 0x0a
    4fd6:	93 85       	ldd	r25, Z+11	; 0x0b
    4fd8:	9e 83       	std	Y+6, r25	; 0x06
    4fda:	8d 83       	std	Y+5, r24	; 0x05
    4fdc:	ee 85       	ldd	r30, Y+14	; 0x0e
    4fde:	ff 85       	ldd	r31, Y+15	; 0x0f
    4fe0:	a4 81       	ldd	r26, Z+4	; 0x04
    4fe2:	b5 81       	ldd	r27, Z+5	; 0x05
    4fe4:	ee 85       	ldd	r30, Y+14	; 0x0e
    4fe6:	ff 85       	ldd	r31, Y+15	; 0x0f
    4fe8:	86 81       	ldd	r24, Z+6	; 0x06
    4fea:	97 81       	ldd	r25, Z+7	; 0x07
    4fec:	15 96       	adiw	r26, 0x05	; 5
    4fee:	9c 93       	st	X, r25
    4ff0:	8e 93       	st	-X, r24
    4ff2:	14 97       	sbiw	r26, 0x04	; 4
    4ff4:	ee 85       	ldd	r30, Y+14	; 0x0e
    4ff6:	ff 85       	ldd	r31, Y+15	; 0x0f
    4ff8:	a6 81       	ldd	r26, Z+6	; 0x06
    4ffa:	b7 81       	ldd	r27, Z+7	; 0x07
    4ffc:	ee 85       	ldd	r30, Y+14	; 0x0e
    4ffe:	ff 85       	ldd	r31, Y+15	; 0x0f
    5000:	84 81       	ldd	r24, Z+4	; 0x04
    5002:	95 81       	ldd	r25, Z+5	; 0x05
    5004:	13 96       	adiw	r26, 0x03	; 3
    5006:	9c 93       	st	X, r25
    5008:	8e 93       	st	-X, r24
    500a:	12 97       	sbiw	r26, 0x02	; 2
    500c:	ed 81       	ldd	r30, Y+5	; 0x05
    500e:	fe 81       	ldd	r31, Y+6	; 0x06
    5010:	21 81       	ldd	r18, Z+1	; 0x01
    5012:	32 81       	ldd	r19, Z+2	; 0x02
    5014:	8e 85       	ldd	r24, Y+14	; 0x0e
    5016:	9f 85       	ldd	r25, Y+15	; 0x0f
    5018:	02 96       	adiw	r24, 0x02	; 2
    501a:	28 17       	cp	r18, r24
    501c:	39 07       	cpc	r19, r25
    501e:	41 f4       	brne	.+16     	; 0x5030 <xTaskIncrementTick+0x146>
    5020:	ee 85       	ldd	r30, Y+14	; 0x0e
    5022:	ff 85       	ldd	r31, Y+15	; 0x0f
    5024:	86 81       	ldd	r24, Z+6	; 0x06
    5026:	97 81       	ldd	r25, Z+7	; 0x07
    5028:	ed 81       	ldd	r30, Y+5	; 0x05
    502a:	fe 81       	ldd	r31, Y+6	; 0x06
    502c:	92 83       	std	Z+2, r25	; 0x02
    502e:	81 83       	std	Z+1, r24	; 0x01
    5030:	ee 85       	ldd	r30, Y+14	; 0x0e
    5032:	ff 85       	ldd	r31, Y+15	; 0x0f
    5034:	13 86       	std	Z+11, r1	; 0x0b
    5036:	12 86       	std	Z+10, r1	; 0x0a
    5038:	ed 81       	ldd	r30, Y+5	; 0x05
    503a:	fe 81       	ldd	r31, Y+6	; 0x06
    503c:	80 81       	ld	r24, Z
    503e:	81 50       	subi	r24, 0x01	; 1
    5040:	ed 81       	ldd	r30, Y+5	; 0x05
    5042:	fe 81       	ldd	r31, Y+6	; 0x06
    5044:	80 83       	st	Z, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    5046:	ee 85       	ldd	r30, Y+14	; 0x0e
    5048:	ff 85       	ldd	r31, Y+15	; 0x0f
    504a:	84 89       	ldd	r24, Z+20	; 0x14
    504c:	95 89       	ldd	r25, Z+21	; 0x15
    504e:	00 97       	sbiw	r24, 0x00	; 0
    5050:	d9 f1       	breq	.+118    	; 0x50c8 <xTaskIncrementTick+0x1de>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    5052:	ee 85       	ldd	r30, Y+14	; 0x0e
    5054:	ff 85       	ldd	r31, Y+15	; 0x0f
    5056:	84 89       	ldd	r24, Z+20	; 0x14
    5058:	95 89       	ldd	r25, Z+21	; 0x15
    505a:	9c 83       	std	Y+4, r25	; 0x04
    505c:	8b 83       	std	Y+3, r24	; 0x03
    505e:	ee 85       	ldd	r30, Y+14	; 0x0e
    5060:	ff 85       	ldd	r31, Y+15	; 0x0f
    5062:	a6 85       	ldd	r26, Z+14	; 0x0e
    5064:	b7 85       	ldd	r27, Z+15	; 0x0f
    5066:	ee 85       	ldd	r30, Y+14	; 0x0e
    5068:	ff 85       	ldd	r31, Y+15	; 0x0f
    506a:	80 89       	ldd	r24, Z+16	; 0x10
    506c:	91 89       	ldd	r25, Z+17	; 0x11
    506e:	15 96       	adiw	r26, 0x05	; 5
    5070:	9c 93       	st	X, r25
    5072:	8e 93       	st	-X, r24
    5074:	14 97       	sbiw	r26, 0x04	; 4
    5076:	ee 85       	ldd	r30, Y+14	; 0x0e
    5078:	ff 85       	ldd	r31, Y+15	; 0x0f
    507a:	a0 89       	ldd	r26, Z+16	; 0x10
    507c:	b1 89       	ldd	r27, Z+17	; 0x11
    507e:	ee 85       	ldd	r30, Y+14	; 0x0e
    5080:	ff 85       	ldd	r31, Y+15	; 0x0f
    5082:	86 85       	ldd	r24, Z+14	; 0x0e
    5084:	97 85       	ldd	r25, Z+15	; 0x0f
    5086:	13 96       	adiw	r26, 0x03	; 3
    5088:	9c 93       	st	X, r25
    508a:	8e 93       	st	-X, r24
    508c:	12 97       	sbiw	r26, 0x02	; 2
    508e:	eb 81       	ldd	r30, Y+3	; 0x03
    5090:	fc 81       	ldd	r31, Y+4	; 0x04
    5092:	21 81       	ldd	r18, Z+1	; 0x01
    5094:	32 81       	ldd	r19, Z+2	; 0x02
    5096:	8e 85       	ldd	r24, Y+14	; 0x0e
    5098:	9f 85       	ldd	r25, Y+15	; 0x0f
    509a:	0c 96       	adiw	r24, 0x0c	; 12
    509c:	28 17       	cp	r18, r24
    509e:	39 07       	cpc	r19, r25
    50a0:	41 f4       	brne	.+16     	; 0x50b2 <xTaskIncrementTick+0x1c8>
    50a2:	ee 85       	ldd	r30, Y+14	; 0x0e
    50a4:	ff 85       	ldd	r31, Y+15	; 0x0f
    50a6:	80 89       	ldd	r24, Z+16	; 0x10
    50a8:	91 89       	ldd	r25, Z+17	; 0x11
    50aa:	eb 81       	ldd	r30, Y+3	; 0x03
    50ac:	fc 81       	ldd	r31, Y+4	; 0x04
    50ae:	92 83       	std	Z+2, r25	; 0x02
    50b0:	81 83       	std	Z+1, r24	; 0x01
    50b2:	ee 85       	ldd	r30, Y+14	; 0x0e
    50b4:	ff 85       	ldd	r31, Y+15	; 0x0f
    50b6:	15 8a       	std	Z+21, r1	; 0x15
    50b8:	14 8a       	std	Z+20, r1	; 0x14
    50ba:	eb 81       	ldd	r30, Y+3	; 0x03
    50bc:	fc 81       	ldd	r31, Y+4	; 0x04
    50be:	80 81       	ld	r24, Z
    50c0:	81 50       	subi	r24, 0x01	; 1
    50c2:	eb 81       	ldd	r30, Y+3	; 0x03
    50c4:	fc 81       	ldd	r31, Y+4	; 0x04
    50c6:	80 83       	st	Z, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    50c8:	ee 85       	ldd	r30, Y+14	; 0x0e
    50ca:	ff 85       	ldd	r31, Y+15	; 0x0f
    50cc:	96 89       	ldd	r25, Z+22	; 0x16
    50ce:	80 91 4c 07 	lds	r24, 0x074C
    50d2:	89 17       	cp	r24, r25
    50d4:	28 f4       	brcc	.+10     	; 0x50e0 <xTaskIncrementTick+0x1f6>
    50d6:	ee 85       	ldd	r30, Y+14	; 0x0e
    50d8:	ff 85       	ldd	r31, Y+15	; 0x0f
    50da:	86 89       	ldd	r24, Z+22	; 0x16
    50dc:	80 93 4c 07 	sts	0x074C, r24
    50e0:	ee 85       	ldd	r30, Y+14	; 0x0e
    50e2:	ff 85       	ldd	r31, Y+15	; 0x0f
    50e4:	86 89       	ldd	r24, Z+22	; 0x16
    50e6:	28 2f       	mov	r18, r24
    50e8:	30 e0       	ldi	r19, 0x00	; 0
    50ea:	c9 01       	movw	r24, r18
    50ec:	88 0f       	add	r24, r24
    50ee:	99 1f       	adc	r25, r25
    50f0:	88 0f       	add	r24, r24
    50f2:	99 1f       	adc	r25, r25
    50f4:	88 0f       	add	r24, r24
    50f6:	99 1f       	adc	r25, r25
    50f8:	82 0f       	add	r24, r18
    50fa:	93 1f       	adc	r25, r19
    50fc:	fc 01       	movw	r30, r24
    50fe:	e8 5a       	subi	r30, 0xA8	; 168
    5100:	f8 4f       	sbci	r31, 0xF8	; 248
    5102:	81 81       	ldd	r24, Z+1	; 0x01
    5104:	92 81       	ldd	r25, Z+2	; 0x02
    5106:	9a 83       	std	Y+2, r25	; 0x02
    5108:	89 83       	std	Y+1, r24	; 0x01
    510a:	ee 85       	ldd	r30, Y+14	; 0x0e
    510c:	ff 85       	ldd	r31, Y+15	; 0x0f
    510e:	89 81       	ldd	r24, Y+1	; 0x01
    5110:	9a 81       	ldd	r25, Y+2	; 0x02
    5112:	95 83       	std	Z+5, r25	; 0x05
    5114:	84 83       	std	Z+4, r24	; 0x04
    5116:	e9 81       	ldd	r30, Y+1	; 0x01
    5118:	fa 81       	ldd	r31, Y+2	; 0x02
    511a:	84 81       	ldd	r24, Z+4	; 0x04
    511c:	95 81       	ldd	r25, Z+5	; 0x05
    511e:	ee 85       	ldd	r30, Y+14	; 0x0e
    5120:	ff 85       	ldd	r31, Y+15	; 0x0f
    5122:	97 83       	std	Z+7, r25	; 0x07
    5124:	86 83       	std	Z+6, r24	; 0x06
    5126:	e9 81       	ldd	r30, Y+1	; 0x01
    5128:	fa 81       	ldd	r31, Y+2	; 0x02
    512a:	04 80       	ldd	r0, Z+4	; 0x04
    512c:	f5 81       	ldd	r31, Z+5	; 0x05
    512e:	e0 2d       	mov	r30, r0
    5130:	8e 85       	ldd	r24, Y+14	; 0x0e
    5132:	9f 85       	ldd	r25, Y+15	; 0x0f
    5134:	02 96       	adiw	r24, 0x02	; 2
    5136:	93 83       	std	Z+3, r25	; 0x03
    5138:	82 83       	std	Z+2, r24	; 0x02
    513a:	8e 85       	ldd	r24, Y+14	; 0x0e
    513c:	9f 85       	ldd	r25, Y+15	; 0x0f
    513e:	02 96       	adiw	r24, 0x02	; 2
    5140:	e9 81       	ldd	r30, Y+1	; 0x01
    5142:	fa 81       	ldd	r31, Y+2	; 0x02
    5144:	95 83       	std	Z+5, r25	; 0x05
    5146:	84 83       	std	Z+4, r24	; 0x04
    5148:	ee 85       	ldd	r30, Y+14	; 0x0e
    514a:	ff 85       	ldd	r31, Y+15	; 0x0f
    514c:	86 89       	ldd	r24, Z+22	; 0x16
    514e:	28 2f       	mov	r18, r24
    5150:	30 e0       	ldi	r19, 0x00	; 0
    5152:	c9 01       	movw	r24, r18
    5154:	88 0f       	add	r24, r24
    5156:	99 1f       	adc	r25, r25
    5158:	88 0f       	add	r24, r24
    515a:	99 1f       	adc	r25, r25
    515c:	88 0f       	add	r24, r24
    515e:	99 1f       	adc	r25, r25
    5160:	82 0f       	add	r24, r18
    5162:	93 1f       	adc	r25, r19
    5164:	88 5a       	subi	r24, 0xA8	; 168
    5166:	98 4f       	sbci	r25, 0xF8	; 248
    5168:	ee 85       	ldd	r30, Y+14	; 0x0e
    516a:	ff 85       	ldd	r31, Y+15	; 0x0f
    516c:	93 87       	std	Z+11, r25	; 0x0b
    516e:	82 87       	std	Z+10, r24	; 0x0a
    5170:	ee 85       	ldd	r30, Y+14	; 0x0e
    5172:	ff 85       	ldd	r31, Y+15	; 0x0f
    5174:	86 89       	ldd	r24, Z+22	; 0x16
    5176:	28 2f       	mov	r18, r24
    5178:	30 e0       	ldi	r19, 0x00	; 0
    517a:	c9 01       	movw	r24, r18
    517c:	88 0f       	add	r24, r24
    517e:	99 1f       	adc	r25, r25
    5180:	88 0f       	add	r24, r24
    5182:	99 1f       	adc	r25, r25
    5184:	88 0f       	add	r24, r24
    5186:	99 1f       	adc	r25, r25
    5188:	82 0f       	add	r24, r18
    518a:	93 1f       	adc	r25, r19
    518c:	fc 01       	movw	r30, r24
    518e:	e8 5a       	subi	r30, 0xA8	; 168
    5190:	f8 4f       	sbci	r31, 0xF8	; 248
    5192:	80 81       	ld	r24, Z
    5194:	8f 5f       	subi	r24, 0xFF	; 255
    5196:	80 83       	st	Z, r24
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5198:	ee 85       	ldd	r30, Y+14	; 0x0e
    519a:	ff 85       	ldd	r31, Y+15	; 0x0f
    519c:	96 89       	ldd	r25, Z+22	; 0x16
    519e:	e0 91 46 07 	lds	r30, 0x0746
    51a2:	f0 91 47 07 	lds	r31, 0x0747
    51a6:	86 89       	ldd	r24, Z+22	; 0x16
    51a8:	98 17       	cp	r25, r24
    51aa:	08 f4       	brcc	.+2      	; 0x51ae <xTaskIncrementTick+0x2c4>
    51ac:	e4 ce       	rjmp	.-568    	; 0x4f76 <xTaskIncrementTick+0x8c>
                            {
                                xSwitchRequired = pdTRUE;
    51ae:	81 e0       	ldi	r24, 0x01	; 1
    51b0:	8b 87       	std	Y+11, r24	; 0x0b
    51b2:	e1 ce       	rjmp	.-574    	; 0x4f76 <xTaskIncrementTick+0x8c>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    51b4:	e0 91 46 07 	lds	r30, 0x0746
    51b8:	f0 91 47 07 	lds	r31, 0x0747
    51bc:	86 89       	ldd	r24, Z+22	; 0x16
    51be:	28 2f       	mov	r18, r24
    51c0:	30 e0       	ldi	r19, 0x00	; 0
    51c2:	c9 01       	movw	r24, r18
    51c4:	88 0f       	add	r24, r24
    51c6:	99 1f       	adc	r25, r25
    51c8:	88 0f       	add	r24, r24
    51ca:	99 1f       	adc	r25, r25
    51cc:	88 0f       	add	r24, r24
    51ce:	99 1f       	adc	r25, r25
    51d0:	82 0f       	add	r24, r18
    51d2:	93 1f       	adc	r25, r19
    51d4:	fc 01       	movw	r30, r24
    51d6:	e8 5a       	subi	r30, 0xA8	; 168
    51d8:	f8 4f       	sbci	r31, 0xF8	; 248
    51da:	80 81       	ld	r24, Z
    51dc:	82 30       	cpi	r24, 0x02	; 2
    51de:	10 f0       	brcs	.+4      	; 0x51e4 <xTaskIncrementTick+0x2fa>
                {
                    xSwitchRequired = pdTRUE;
    51e0:	81 e0       	ldi	r24, 0x01	; 1
    51e2:	8b 87       	std	Y+11, r24	; 0x0b
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
    51e4:	80 91 50 07 	lds	r24, 0x0750
    51e8:	88 23       	and	r24, r24
    51ea:	61 f0       	breq	.+24     	; 0x5204 <xTaskIncrementTick+0x31a>
                {
                    xSwitchRequired = pdTRUE;
    51ec:	81 e0       	ldi	r24, 0x01	; 1
    51ee:	8b 87       	std	Y+11, r24	; 0x0b
    51f0:	09 c0       	rjmp	.+18     	; 0x5204 <xTaskIncrementTick+0x31a>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    51f2:	80 91 4e 07 	lds	r24, 0x074E
    51f6:	90 91 4f 07 	lds	r25, 0x074F
    51fa:	01 96       	adiw	r24, 0x01	; 1
    51fc:	90 93 4f 07 	sts	0x074F, r25
    5200:	80 93 4e 07 	sts	0x074E, r24
                vApplicationTickHook();
            }
        #endif
    }

    return xSwitchRequired;
    5204:	8b 85       	ldd	r24, Y+11	; 0x0b
}
    5206:	2f 96       	adiw	r28, 0x0f	; 15
    5208:	0f b6       	in	r0, 0x3f	; 63
    520a:	f8 94       	cli
    520c:	de bf       	out	0x3e, r29	; 62
    520e:	0f be       	out	0x3f, r0	; 63
    5210:	cd bf       	out	0x3d, r28	; 61
    5212:	cf 91       	pop	r28
    5214:	df 91       	pop	r29
    5216:	08 95       	ret

00005218 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    5218:	df 93       	push	r29
    521a:	cf 93       	push	r28
    521c:	00 d0       	rcall	.+0      	; 0x521e <vTaskSwitchContext+0x6>
    521e:	0f 92       	push	r0
    5220:	cd b7       	in	r28, 0x3d	; 61
    5222:	de b7       	in	r29, 0x3e	; 62
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    5224:	80 91 57 07 	lds	r24, 0x0757
    5228:	88 23       	and	r24, r24
    522a:	21 f0       	breq	.+8      	; 0x5234 <vTaskSwitchContext+0x1c>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    522c:	81 e0       	ldi	r24, 0x01	; 1
    522e:	80 93 50 07 	sts	0x0750, r24
    5232:	59 c0       	rjmp	.+178    	; 0x52e6 <vTaskSwitchContext+0xce>
    }
    else
    {
        xYieldPending = pdFALSE;
    5234:	10 92 50 07 	sts	0x0750, r1
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5238:	80 91 4c 07 	lds	r24, 0x074C
    523c:	8b 83       	std	Y+3, r24	; 0x03
    523e:	03 c0       	rjmp	.+6      	; 0x5246 <vTaskSwitchContext+0x2e>
    5240:	8b 81       	ldd	r24, Y+3	; 0x03
    5242:	81 50       	subi	r24, 0x01	; 1
    5244:	8b 83       	std	Y+3, r24	; 0x03
    5246:	8b 81       	ldd	r24, Y+3	; 0x03
    5248:	28 2f       	mov	r18, r24
    524a:	30 e0       	ldi	r19, 0x00	; 0
    524c:	c9 01       	movw	r24, r18
    524e:	88 0f       	add	r24, r24
    5250:	99 1f       	adc	r25, r25
    5252:	88 0f       	add	r24, r24
    5254:	99 1f       	adc	r25, r25
    5256:	88 0f       	add	r24, r24
    5258:	99 1f       	adc	r25, r25
    525a:	82 0f       	add	r24, r18
    525c:	93 1f       	adc	r25, r19
    525e:	fc 01       	movw	r30, r24
    5260:	e8 5a       	subi	r30, 0xA8	; 168
    5262:	f8 4f       	sbci	r31, 0xF8	; 248
    5264:	80 81       	ld	r24, Z
    5266:	88 23       	and	r24, r24
    5268:	59 f3       	breq	.-42     	; 0x5240 <vTaskSwitchContext+0x28>
    526a:	8b 81       	ldd	r24, Y+3	; 0x03
    526c:	28 2f       	mov	r18, r24
    526e:	30 e0       	ldi	r19, 0x00	; 0
    5270:	c9 01       	movw	r24, r18
    5272:	88 0f       	add	r24, r24
    5274:	99 1f       	adc	r25, r25
    5276:	88 0f       	add	r24, r24
    5278:	99 1f       	adc	r25, r25
    527a:	88 0f       	add	r24, r24
    527c:	99 1f       	adc	r25, r25
    527e:	82 0f       	add	r24, r18
    5280:	93 1f       	adc	r25, r19
    5282:	88 5a       	subi	r24, 0xA8	; 168
    5284:	98 4f       	sbci	r25, 0xF8	; 248
    5286:	9a 83       	std	Y+2, r25	; 0x02
    5288:	89 83       	std	Y+1, r24	; 0x01
    528a:	e9 81       	ldd	r30, Y+1	; 0x01
    528c:	fa 81       	ldd	r31, Y+2	; 0x02
    528e:	01 80       	ldd	r0, Z+1	; 0x01
    5290:	f2 81       	ldd	r31, Z+2	; 0x02
    5292:	e0 2d       	mov	r30, r0
    5294:	82 81       	ldd	r24, Z+2	; 0x02
    5296:	93 81       	ldd	r25, Z+3	; 0x03
    5298:	e9 81       	ldd	r30, Y+1	; 0x01
    529a:	fa 81       	ldd	r31, Y+2	; 0x02
    529c:	92 83       	std	Z+2, r25	; 0x02
    529e:	81 83       	std	Z+1, r24	; 0x01
    52a0:	e9 81       	ldd	r30, Y+1	; 0x01
    52a2:	fa 81       	ldd	r31, Y+2	; 0x02
    52a4:	21 81       	ldd	r18, Z+1	; 0x01
    52a6:	32 81       	ldd	r19, Z+2	; 0x02
    52a8:	89 81       	ldd	r24, Y+1	; 0x01
    52aa:	9a 81       	ldd	r25, Y+2	; 0x02
    52ac:	03 96       	adiw	r24, 0x03	; 3
    52ae:	28 17       	cp	r18, r24
    52b0:	39 07       	cpc	r19, r25
    52b2:	59 f4       	brne	.+22     	; 0x52ca <vTaskSwitchContext+0xb2>
    52b4:	e9 81       	ldd	r30, Y+1	; 0x01
    52b6:	fa 81       	ldd	r31, Y+2	; 0x02
    52b8:	01 80       	ldd	r0, Z+1	; 0x01
    52ba:	f2 81       	ldd	r31, Z+2	; 0x02
    52bc:	e0 2d       	mov	r30, r0
    52be:	82 81       	ldd	r24, Z+2	; 0x02
    52c0:	93 81       	ldd	r25, Z+3	; 0x03
    52c2:	e9 81       	ldd	r30, Y+1	; 0x01
    52c4:	fa 81       	ldd	r31, Y+2	; 0x02
    52c6:	92 83       	std	Z+2, r25	; 0x02
    52c8:	81 83       	std	Z+1, r24	; 0x01
    52ca:	e9 81       	ldd	r30, Y+1	; 0x01
    52cc:	fa 81       	ldd	r31, Y+2	; 0x02
    52ce:	01 80       	ldd	r0, Z+1	; 0x01
    52d0:	f2 81       	ldd	r31, Z+2	; 0x02
    52d2:	e0 2d       	mov	r30, r0
    52d4:	86 81       	ldd	r24, Z+6	; 0x06
    52d6:	97 81       	ldd	r25, Z+7	; 0x07
    52d8:	90 93 47 07 	sts	0x0747, r25
    52dc:	80 93 46 07 	sts	0x0746, r24
    52e0:	8b 81       	ldd	r24, Y+3	; 0x03
    52e2:	80 93 4c 07 	sts	0x074C, r24
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */
    }
}
    52e6:	0f 90       	pop	r0
    52e8:	0f 90       	pop	r0
    52ea:	0f 90       	pop	r0
    52ec:	cf 91       	pop	r28
    52ee:	df 91       	pop	r29
    52f0:	08 95       	ret

000052f2 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    52f2:	df 93       	push	r29
    52f4:	cf 93       	push	r28
    52f6:	00 d0       	rcall	.+0      	; 0x52f8 <vTaskPlaceOnEventList+0x6>
    52f8:	00 d0       	rcall	.+0      	; 0x52fa <vTaskPlaceOnEventList+0x8>
    52fa:	cd b7       	in	r28, 0x3d	; 61
    52fc:	de b7       	in	r29, 0x3e	; 62
    52fe:	9a 83       	std	Y+2, r25	; 0x02
    5300:	89 83       	std	Y+1, r24	; 0x01
    5302:	7c 83       	std	Y+4, r23	; 0x04
    5304:	6b 83       	std	Y+3, r22	; 0x03
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    5306:	80 91 46 07 	lds	r24, 0x0746
    530a:	90 91 47 07 	lds	r25, 0x0747
    530e:	9c 01       	movw	r18, r24
    5310:	24 5f       	subi	r18, 0xF4	; 244
    5312:	3f 4f       	sbci	r19, 0xFF	; 255
    5314:	89 81       	ldd	r24, Y+1	; 0x01
    5316:	9a 81       	ldd	r25, Y+2	; 0x02
    5318:	b9 01       	movw	r22, r18
    531a:	0e 94 3d 18 	call	0x307a	; 0x307a <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    531e:	8b 81       	ldd	r24, Y+3	; 0x03
    5320:	9c 81       	ldd	r25, Y+4	; 0x04
    5322:	61 e0       	ldi	r22, 0x01	; 1
    5324:	0e 94 d5 35 	call	0x6baa	; 0x6baa <prvAddCurrentTaskToDelayedList>
}
    5328:	0f 90       	pop	r0
    532a:	0f 90       	pop	r0
    532c:	0f 90       	pop	r0
    532e:	0f 90       	pop	r0
    5330:	cf 91       	pop	r28
    5332:	df 91       	pop	r29
    5334:	08 95       	ret

00005336 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    5336:	df 93       	push	r29
    5338:	cf 93       	push	r28
    533a:	cd b7       	in	r28, 0x3d	; 61
    533c:	de b7       	in	r29, 0x3e	; 62
    533e:	28 97       	sbiw	r28, 0x08	; 8
    5340:	0f b6       	in	r0, 0x3f	; 63
    5342:	f8 94       	cli
    5344:	de bf       	out	0x3e, r29	; 62
    5346:	0f be       	out	0x3f, r0	; 63
    5348:	cd bf       	out	0x3d, r28	; 61
    534a:	9c 83       	std	Y+4, r25	; 0x04
    534c:	8b 83       	std	Y+3, r24	; 0x03
    534e:	7e 83       	std	Y+6, r23	; 0x06
    5350:	6d 83       	std	Y+5, r22	; 0x05
    5352:	58 87       	std	Y+8, r21	; 0x08
    5354:	4f 83       	std	Y+7, r20	; 0x07
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5356:	e0 91 46 07 	lds	r30, 0x0746
    535a:	f0 91 47 07 	lds	r31, 0x0747
    535e:	8d 81       	ldd	r24, Y+5	; 0x05
    5360:	9e 81       	ldd	r25, Y+6	; 0x06
    5362:	90 68       	ori	r25, 0x80	; 128
    5364:	95 87       	std	Z+13, r25	; 0x0d
    5366:	84 87       	std	Z+12, r24	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    5368:	eb 81       	ldd	r30, Y+3	; 0x03
    536a:	fc 81       	ldd	r31, Y+4	; 0x04
    536c:	81 81       	ldd	r24, Z+1	; 0x01
    536e:	92 81       	ldd	r25, Z+2	; 0x02
    5370:	9a 83       	std	Y+2, r25	; 0x02
    5372:	89 83       	std	Y+1, r24	; 0x01
    5374:	e0 91 46 07 	lds	r30, 0x0746
    5378:	f0 91 47 07 	lds	r31, 0x0747
    537c:	89 81       	ldd	r24, Y+1	; 0x01
    537e:	9a 81       	ldd	r25, Y+2	; 0x02
    5380:	97 87       	std	Z+15, r25	; 0x0f
    5382:	86 87       	std	Z+14, r24	; 0x0e
    5384:	a0 91 46 07 	lds	r26, 0x0746
    5388:	b0 91 47 07 	lds	r27, 0x0747
    538c:	e9 81       	ldd	r30, Y+1	; 0x01
    538e:	fa 81       	ldd	r31, Y+2	; 0x02
    5390:	84 81       	ldd	r24, Z+4	; 0x04
    5392:	95 81       	ldd	r25, Z+5	; 0x05
    5394:	51 96       	adiw	r26, 0x11	; 17
    5396:	9c 93       	st	X, r25
    5398:	8e 93       	st	-X, r24
    539a:	50 97       	sbiw	r26, 0x10	; 16
    539c:	e9 81       	ldd	r30, Y+1	; 0x01
    539e:	fa 81       	ldd	r31, Y+2	; 0x02
    53a0:	04 80       	ldd	r0, Z+4	; 0x04
    53a2:	f5 81       	ldd	r31, Z+5	; 0x05
    53a4:	e0 2d       	mov	r30, r0
    53a6:	80 91 46 07 	lds	r24, 0x0746
    53aa:	90 91 47 07 	lds	r25, 0x0747
    53ae:	0c 96       	adiw	r24, 0x0c	; 12
    53b0:	93 83       	std	Z+3, r25	; 0x03
    53b2:	82 83       	std	Z+2, r24	; 0x02
    53b4:	80 91 46 07 	lds	r24, 0x0746
    53b8:	90 91 47 07 	lds	r25, 0x0747
    53bc:	0c 96       	adiw	r24, 0x0c	; 12
    53be:	e9 81       	ldd	r30, Y+1	; 0x01
    53c0:	fa 81       	ldd	r31, Y+2	; 0x02
    53c2:	95 83       	std	Z+5, r25	; 0x05
    53c4:	84 83       	std	Z+4, r24	; 0x04
    53c6:	e0 91 46 07 	lds	r30, 0x0746
    53ca:	f0 91 47 07 	lds	r31, 0x0747
    53ce:	8b 81       	ldd	r24, Y+3	; 0x03
    53d0:	9c 81       	ldd	r25, Y+4	; 0x04
    53d2:	95 8b       	std	Z+21, r25	; 0x15
    53d4:	84 8b       	std	Z+20, r24	; 0x14
    53d6:	eb 81       	ldd	r30, Y+3	; 0x03
    53d8:	fc 81       	ldd	r31, Y+4	; 0x04
    53da:	80 81       	ld	r24, Z
    53dc:	8f 5f       	subi	r24, 0xFF	; 255
    53de:	eb 81       	ldd	r30, Y+3	; 0x03
    53e0:	fc 81       	ldd	r31, Y+4	; 0x04
    53e2:	80 83       	st	Z, r24

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    53e4:	8f 81       	ldd	r24, Y+7	; 0x07
    53e6:	98 85       	ldd	r25, Y+8	; 0x08
    53e8:	61 e0       	ldi	r22, 0x01	; 1
    53ea:	0e 94 d5 35 	call	0x6baa	; 0x6baa <prvAddCurrentTaskToDelayedList>
}
    53ee:	28 96       	adiw	r28, 0x08	; 8
    53f0:	0f b6       	in	r0, 0x3f	; 63
    53f2:	f8 94       	cli
    53f4:	de bf       	out	0x3e, r29	; 62
    53f6:	0f be       	out	0x3f, r0	; 63
    53f8:	cd bf       	out	0x3d, r28	; 61
    53fa:	cf 91       	pop	r28
    53fc:	df 91       	pop	r29
    53fe:	08 95       	ret

00005400 <vTaskPlaceOnEventListRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
                                          TickType_t xTicksToWait,
                                          const BaseType_t xWaitIndefinitely )
    {
    5400:	df 93       	push	r29
    5402:	cf 93       	push	r28
    5404:	cd b7       	in	r28, 0x3d	; 61
    5406:	de b7       	in	r29, 0x3e	; 62
    5408:	27 97       	sbiw	r28, 0x07	; 7
    540a:	0f b6       	in	r0, 0x3f	; 63
    540c:	f8 94       	cli
    540e:	de bf       	out	0x3e, r29	; 62
    5410:	0f be       	out	0x3f, r0	; 63
    5412:	cd bf       	out	0x3d, r28	; 61
    5414:	9c 83       	std	Y+4, r25	; 0x04
    5416:	8b 83       	std	Y+3, r24	; 0x03
    5418:	7e 83       	std	Y+6, r23	; 0x06
    541a:	6d 83       	std	Y+5, r22	; 0x05
    541c:	4f 83       	std	Y+7, r20	; 0x07

        /* Place the event list item of the TCB in the appropriate event list.
         * In this case it is assume that this is the only task that is going to
         * be waiting on this event list, so the faster vListInsertEnd() function
         * can be used in place of vListInsert. */
        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    541e:	eb 81       	ldd	r30, Y+3	; 0x03
    5420:	fc 81       	ldd	r31, Y+4	; 0x04
    5422:	81 81       	ldd	r24, Z+1	; 0x01
    5424:	92 81       	ldd	r25, Z+2	; 0x02
    5426:	9a 83       	std	Y+2, r25	; 0x02
    5428:	89 83       	std	Y+1, r24	; 0x01
    542a:	e0 91 46 07 	lds	r30, 0x0746
    542e:	f0 91 47 07 	lds	r31, 0x0747
    5432:	89 81       	ldd	r24, Y+1	; 0x01
    5434:	9a 81       	ldd	r25, Y+2	; 0x02
    5436:	97 87       	std	Z+15, r25	; 0x0f
    5438:	86 87       	std	Z+14, r24	; 0x0e
    543a:	a0 91 46 07 	lds	r26, 0x0746
    543e:	b0 91 47 07 	lds	r27, 0x0747
    5442:	e9 81       	ldd	r30, Y+1	; 0x01
    5444:	fa 81       	ldd	r31, Y+2	; 0x02
    5446:	84 81       	ldd	r24, Z+4	; 0x04
    5448:	95 81       	ldd	r25, Z+5	; 0x05
    544a:	51 96       	adiw	r26, 0x11	; 17
    544c:	9c 93       	st	X, r25
    544e:	8e 93       	st	-X, r24
    5450:	50 97       	sbiw	r26, 0x10	; 16
    5452:	e9 81       	ldd	r30, Y+1	; 0x01
    5454:	fa 81       	ldd	r31, Y+2	; 0x02
    5456:	04 80       	ldd	r0, Z+4	; 0x04
    5458:	f5 81       	ldd	r31, Z+5	; 0x05
    545a:	e0 2d       	mov	r30, r0
    545c:	80 91 46 07 	lds	r24, 0x0746
    5460:	90 91 47 07 	lds	r25, 0x0747
    5464:	0c 96       	adiw	r24, 0x0c	; 12
    5466:	93 83       	std	Z+3, r25	; 0x03
    5468:	82 83       	std	Z+2, r24	; 0x02
    546a:	80 91 46 07 	lds	r24, 0x0746
    546e:	90 91 47 07 	lds	r25, 0x0747
    5472:	0c 96       	adiw	r24, 0x0c	; 12
    5474:	e9 81       	ldd	r30, Y+1	; 0x01
    5476:	fa 81       	ldd	r31, Y+2	; 0x02
    5478:	95 83       	std	Z+5, r25	; 0x05
    547a:	84 83       	std	Z+4, r24	; 0x04
    547c:	e0 91 46 07 	lds	r30, 0x0746
    5480:	f0 91 47 07 	lds	r31, 0x0747
    5484:	8b 81       	ldd	r24, Y+3	; 0x03
    5486:	9c 81       	ldd	r25, Y+4	; 0x04
    5488:	95 8b       	std	Z+21, r25	; 0x15
    548a:	84 8b       	std	Z+20, r24	; 0x14
    548c:	eb 81       	ldd	r30, Y+3	; 0x03
    548e:	fc 81       	ldd	r31, Y+4	; 0x04
    5490:	80 81       	ld	r24, Z
    5492:	8f 5f       	subi	r24, 0xFF	; 255
    5494:	eb 81       	ldd	r30, Y+3	; 0x03
    5496:	fc 81       	ldd	r31, Y+4	; 0x04
    5498:	80 83       	st	Z, r24

        /* If the task should block indefinitely then set the block time to a
         * value that will be recognised as an indefinite delay inside the
         * prvAddCurrentTaskToDelayedList() function. */
        if( xWaitIndefinitely != pdFALSE )
    549a:	8f 81       	ldd	r24, Y+7	; 0x07
    549c:	88 23       	and	r24, r24
    549e:	21 f0       	breq	.+8      	; 0x54a8 <vTaskPlaceOnEventListRestricted+0xa8>
        {
            xTicksToWait = portMAX_DELAY;
    54a0:	8f ef       	ldi	r24, 0xFF	; 255
    54a2:	9f ef       	ldi	r25, 0xFF	; 255
    54a4:	9e 83       	std	Y+6, r25	; 0x06
    54a6:	8d 83       	std	Y+5, r24	; 0x05
        }

        traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    54a8:	8d 81       	ldd	r24, Y+5	; 0x05
    54aa:	9e 81       	ldd	r25, Y+6	; 0x06
    54ac:	6f 81       	ldd	r22, Y+7	; 0x07
    54ae:	0e 94 d5 35 	call	0x6baa	; 0x6baa <prvAddCurrentTaskToDelayedList>
    }
    54b2:	27 96       	adiw	r28, 0x07	; 7
    54b4:	0f b6       	in	r0, 0x3f	; 63
    54b6:	f8 94       	cli
    54b8:	de bf       	out	0x3e, r29	; 62
    54ba:	0f be       	out	0x3f, r0	; 63
    54bc:	cd bf       	out	0x3d, r28	; 61
    54be:	cf 91       	pop	r28
    54c0:	df 91       	pop	r29
    54c2:	08 95       	ret

000054c4 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    54c4:	df 93       	push	r29
    54c6:	cf 93       	push	r28
    54c8:	cd b7       	in	r28, 0x3d	; 61
    54ca:	de b7       	in	r29, 0x3e	; 62
    54cc:	2d 97       	sbiw	r28, 0x0d	; 13
    54ce:	0f b6       	in	r0, 0x3f	; 63
    54d0:	f8 94       	cli
    54d2:	de bf       	out	0x3e, r29	; 62
    54d4:	0f be       	out	0x3f, r0	; 63
    54d6:	cd bf       	out	0x3d, r28	; 61
    54d8:	9d 87       	std	Y+13, r25	; 0x0d
    54da:	8c 87       	std	Y+12, r24	; 0x0c
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    54dc:	ec 85       	ldd	r30, Y+12	; 0x0c
    54de:	fd 85       	ldd	r31, Y+13	; 0x0d
    54e0:	05 80       	ldd	r0, Z+5	; 0x05
    54e2:	f6 81       	ldd	r31, Z+6	; 0x06
    54e4:	e0 2d       	mov	r30, r0
    54e6:	86 81       	ldd	r24, Z+6	; 0x06
    54e8:	97 81       	ldd	r25, Z+7	; 0x07
    54ea:	9b 87       	std	Y+11, r25	; 0x0b
    54ec:	8a 87       	std	Y+10, r24	; 0x0a
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    54ee:	ea 85       	ldd	r30, Y+10	; 0x0a
    54f0:	fb 85       	ldd	r31, Y+11	; 0x0b
    54f2:	84 89       	ldd	r24, Z+20	; 0x14
    54f4:	95 89       	ldd	r25, Z+21	; 0x15
    54f6:	98 87       	std	Y+8, r25	; 0x08
    54f8:	8f 83       	std	Y+7, r24	; 0x07
    54fa:	ea 85       	ldd	r30, Y+10	; 0x0a
    54fc:	fb 85       	ldd	r31, Y+11	; 0x0b
    54fe:	a6 85       	ldd	r26, Z+14	; 0x0e
    5500:	b7 85       	ldd	r27, Z+15	; 0x0f
    5502:	ea 85       	ldd	r30, Y+10	; 0x0a
    5504:	fb 85       	ldd	r31, Y+11	; 0x0b
    5506:	80 89       	ldd	r24, Z+16	; 0x10
    5508:	91 89       	ldd	r25, Z+17	; 0x11
    550a:	15 96       	adiw	r26, 0x05	; 5
    550c:	9c 93       	st	X, r25
    550e:	8e 93       	st	-X, r24
    5510:	14 97       	sbiw	r26, 0x04	; 4
    5512:	ea 85       	ldd	r30, Y+10	; 0x0a
    5514:	fb 85       	ldd	r31, Y+11	; 0x0b
    5516:	a0 89       	ldd	r26, Z+16	; 0x10
    5518:	b1 89       	ldd	r27, Z+17	; 0x11
    551a:	ea 85       	ldd	r30, Y+10	; 0x0a
    551c:	fb 85       	ldd	r31, Y+11	; 0x0b
    551e:	86 85       	ldd	r24, Z+14	; 0x0e
    5520:	97 85       	ldd	r25, Z+15	; 0x0f
    5522:	13 96       	adiw	r26, 0x03	; 3
    5524:	9c 93       	st	X, r25
    5526:	8e 93       	st	-X, r24
    5528:	12 97       	sbiw	r26, 0x02	; 2
    552a:	ef 81       	ldd	r30, Y+7	; 0x07
    552c:	f8 85       	ldd	r31, Y+8	; 0x08
    552e:	21 81       	ldd	r18, Z+1	; 0x01
    5530:	32 81       	ldd	r19, Z+2	; 0x02
    5532:	8a 85       	ldd	r24, Y+10	; 0x0a
    5534:	9b 85       	ldd	r25, Y+11	; 0x0b
    5536:	0c 96       	adiw	r24, 0x0c	; 12
    5538:	28 17       	cp	r18, r24
    553a:	39 07       	cpc	r19, r25
    553c:	41 f4       	brne	.+16     	; 0x554e <xTaskRemoveFromEventList+0x8a>
    553e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5540:	fb 85       	ldd	r31, Y+11	; 0x0b
    5542:	80 89       	ldd	r24, Z+16	; 0x10
    5544:	91 89       	ldd	r25, Z+17	; 0x11
    5546:	ef 81       	ldd	r30, Y+7	; 0x07
    5548:	f8 85       	ldd	r31, Y+8	; 0x08
    554a:	92 83       	std	Z+2, r25	; 0x02
    554c:	81 83       	std	Z+1, r24	; 0x01
    554e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5550:	fb 85       	ldd	r31, Y+11	; 0x0b
    5552:	15 8a       	std	Z+21, r1	; 0x15
    5554:	14 8a       	std	Z+20, r1	; 0x14
    5556:	ef 81       	ldd	r30, Y+7	; 0x07
    5558:	f8 85       	ldd	r31, Y+8	; 0x08
    555a:	80 81       	ld	r24, Z
    555c:	81 50       	subi	r24, 0x01	; 1
    555e:	ef 81       	ldd	r30, Y+7	; 0x07
    5560:	f8 85       	ldd	r31, Y+8	; 0x08
    5562:	80 83       	st	Z, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5564:	80 91 57 07 	lds	r24, 0x0757
    5568:	88 23       	and	r24, r24
    556a:	09 f0       	breq	.+2      	; 0x556e <xTaskRemoveFromEventList+0xaa>
    556c:	a4 c0       	rjmp	.+328    	; 0x56b6 <xTaskRemoveFromEventList+0x1f2>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    556e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5570:	fb 85       	ldd	r31, Y+11	; 0x0b
    5572:	82 85       	ldd	r24, Z+10	; 0x0a
    5574:	93 85       	ldd	r25, Z+11	; 0x0b
    5576:	9e 83       	std	Y+6, r25	; 0x06
    5578:	8d 83       	std	Y+5, r24	; 0x05
    557a:	ea 85       	ldd	r30, Y+10	; 0x0a
    557c:	fb 85       	ldd	r31, Y+11	; 0x0b
    557e:	a4 81       	ldd	r26, Z+4	; 0x04
    5580:	b5 81       	ldd	r27, Z+5	; 0x05
    5582:	ea 85       	ldd	r30, Y+10	; 0x0a
    5584:	fb 85       	ldd	r31, Y+11	; 0x0b
    5586:	86 81       	ldd	r24, Z+6	; 0x06
    5588:	97 81       	ldd	r25, Z+7	; 0x07
    558a:	15 96       	adiw	r26, 0x05	; 5
    558c:	9c 93       	st	X, r25
    558e:	8e 93       	st	-X, r24
    5590:	14 97       	sbiw	r26, 0x04	; 4
    5592:	ea 85       	ldd	r30, Y+10	; 0x0a
    5594:	fb 85       	ldd	r31, Y+11	; 0x0b
    5596:	a6 81       	ldd	r26, Z+6	; 0x06
    5598:	b7 81       	ldd	r27, Z+7	; 0x07
    559a:	ea 85       	ldd	r30, Y+10	; 0x0a
    559c:	fb 85       	ldd	r31, Y+11	; 0x0b
    559e:	84 81       	ldd	r24, Z+4	; 0x04
    55a0:	95 81       	ldd	r25, Z+5	; 0x05
    55a2:	13 96       	adiw	r26, 0x03	; 3
    55a4:	9c 93       	st	X, r25
    55a6:	8e 93       	st	-X, r24
    55a8:	12 97       	sbiw	r26, 0x02	; 2
    55aa:	ed 81       	ldd	r30, Y+5	; 0x05
    55ac:	fe 81       	ldd	r31, Y+6	; 0x06
    55ae:	21 81       	ldd	r18, Z+1	; 0x01
    55b0:	32 81       	ldd	r19, Z+2	; 0x02
    55b2:	8a 85       	ldd	r24, Y+10	; 0x0a
    55b4:	9b 85       	ldd	r25, Y+11	; 0x0b
    55b6:	02 96       	adiw	r24, 0x02	; 2
    55b8:	28 17       	cp	r18, r24
    55ba:	39 07       	cpc	r19, r25
    55bc:	41 f4       	brne	.+16     	; 0x55ce <xTaskRemoveFromEventList+0x10a>
    55be:	ea 85       	ldd	r30, Y+10	; 0x0a
    55c0:	fb 85       	ldd	r31, Y+11	; 0x0b
    55c2:	86 81       	ldd	r24, Z+6	; 0x06
    55c4:	97 81       	ldd	r25, Z+7	; 0x07
    55c6:	ed 81       	ldd	r30, Y+5	; 0x05
    55c8:	fe 81       	ldd	r31, Y+6	; 0x06
    55ca:	92 83       	std	Z+2, r25	; 0x02
    55cc:	81 83       	std	Z+1, r24	; 0x01
    55ce:	ea 85       	ldd	r30, Y+10	; 0x0a
    55d0:	fb 85       	ldd	r31, Y+11	; 0x0b
    55d2:	13 86       	std	Z+11, r1	; 0x0b
    55d4:	12 86       	std	Z+10, r1	; 0x0a
    55d6:	ed 81       	ldd	r30, Y+5	; 0x05
    55d8:	fe 81       	ldd	r31, Y+6	; 0x06
    55da:	80 81       	ld	r24, Z
    55dc:	81 50       	subi	r24, 0x01	; 1
    55de:	ed 81       	ldd	r30, Y+5	; 0x05
    55e0:	fe 81       	ldd	r31, Y+6	; 0x06
    55e2:	80 83       	st	Z, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    55e4:	ea 85       	ldd	r30, Y+10	; 0x0a
    55e6:	fb 85       	ldd	r31, Y+11	; 0x0b
    55e8:	96 89       	ldd	r25, Z+22	; 0x16
    55ea:	80 91 4c 07 	lds	r24, 0x074C
    55ee:	89 17       	cp	r24, r25
    55f0:	28 f4       	brcc	.+10     	; 0x55fc <xTaskRemoveFromEventList+0x138>
    55f2:	ea 85       	ldd	r30, Y+10	; 0x0a
    55f4:	fb 85       	ldd	r31, Y+11	; 0x0b
    55f6:	86 89       	ldd	r24, Z+22	; 0x16
    55f8:	80 93 4c 07 	sts	0x074C, r24
    55fc:	ea 85       	ldd	r30, Y+10	; 0x0a
    55fe:	fb 85       	ldd	r31, Y+11	; 0x0b
    5600:	86 89       	ldd	r24, Z+22	; 0x16
    5602:	28 2f       	mov	r18, r24
    5604:	30 e0       	ldi	r19, 0x00	; 0
    5606:	c9 01       	movw	r24, r18
    5608:	88 0f       	add	r24, r24
    560a:	99 1f       	adc	r25, r25
    560c:	88 0f       	add	r24, r24
    560e:	99 1f       	adc	r25, r25
    5610:	88 0f       	add	r24, r24
    5612:	99 1f       	adc	r25, r25
    5614:	82 0f       	add	r24, r18
    5616:	93 1f       	adc	r25, r19
    5618:	fc 01       	movw	r30, r24
    561a:	e8 5a       	subi	r30, 0xA8	; 168
    561c:	f8 4f       	sbci	r31, 0xF8	; 248
    561e:	81 81       	ldd	r24, Z+1	; 0x01
    5620:	92 81       	ldd	r25, Z+2	; 0x02
    5622:	9c 83       	std	Y+4, r25	; 0x04
    5624:	8b 83       	std	Y+3, r24	; 0x03
    5626:	ea 85       	ldd	r30, Y+10	; 0x0a
    5628:	fb 85       	ldd	r31, Y+11	; 0x0b
    562a:	8b 81       	ldd	r24, Y+3	; 0x03
    562c:	9c 81       	ldd	r25, Y+4	; 0x04
    562e:	95 83       	std	Z+5, r25	; 0x05
    5630:	84 83       	std	Z+4, r24	; 0x04
    5632:	eb 81       	ldd	r30, Y+3	; 0x03
    5634:	fc 81       	ldd	r31, Y+4	; 0x04
    5636:	84 81       	ldd	r24, Z+4	; 0x04
    5638:	95 81       	ldd	r25, Z+5	; 0x05
    563a:	ea 85       	ldd	r30, Y+10	; 0x0a
    563c:	fb 85       	ldd	r31, Y+11	; 0x0b
    563e:	97 83       	std	Z+7, r25	; 0x07
    5640:	86 83       	std	Z+6, r24	; 0x06
    5642:	eb 81       	ldd	r30, Y+3	; 0x03
    5644:	fc 81       	ldd	r31, Y+4	; 0x04
    5646:	04 80       	ldd	r0, Z+4	; 0x04
    5648:	f5 81       	ldd	r31, Z+5	; 0x05
    564a:	e0 2d       	mov	r30, r0
    564c:	8a 85       	ldd	r24, Y+10	; 0x0a
    564e:	9b 85       	ldd	r25, Y+11	; 0x0b
    5650:	02 96       	adiw	r24, 0x02	; 2
    5652:	93 83       	std	Z+3, r25	; 0x03
    5654:	82 83       	std	Z+2, r24	; 0x02
    5656:	8a 85       	ldd	r24, Y+10	; 0x0a
    5658:	9b 85       	ldd	r25, Y+11	; 0x0b
    565a:	02 96       	adiw	r24, 0x02	; 2
    565c:	eb 81       	ldd	r30, Y+3	; 0x03
    565e:	fc 81       	ldd	r31, Y+4	; 0x04
    5660:	95 83       	std	Z+5, r25	; 0x05
    5662:	84 83       	std	Z+4, r24	; 0x04
    5664:	ea 85       	ldd	r30, Y+10	; 0x0a
    5666:	fb 85       	ldd	r31, Y+11	; 0x0b
    5668:	86 89       	ldd	r24, Z+22	; 0x16
    566a:	28 2f       	mov	r18, r24
    566c:	30 e0       	ldi	r19, 0x00	; 0
    566e:	c9 01       	movw	r24, r18
    5670:	88 0f       	add	r24, r24
    5672:	99 1f       	adc	r25, r25
    5674:	88 0f       	add	r24, r24
    5676:	99 1f       	adc	r25, r25
    5678:	88 0f       	add	r24, r24
    567a:	99 1f       	adc	r25, r25
    567c:	82 0f       	add	r24, r18
    567e:	93 1f       	adc	r25, r19
    5680:	88 5a       	subi	r24, 0xA8	; 168
    5682:	98 4f       	sbci	r25, 0xF8	; 248
    5684:	ea 85       	ldd	r30, Y+10	; 0x0a
    5686:	fb 85       	ldd	r31, Y+11	; 0x0b
    5688:	93 87       	std	Z+11, r25	; 0x0b
    568a:	82 87       	std	Z+10, r24	; 0x0a
    568c:	ea 85       	ldd	r30, Y+10	; 0x0a
    568e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5690:	86 89       	ldd	r24, Z+22	; 0x16
    5692:	28 2f       	mov	r18, r24
    5694:	30 e0       	ldi	r19, 0x00	; 0
    5696:	c9 01       	movw	r24, r18
    5698:	88 0f       	add	r24, r24
    569a:	99 1f       	adc	r25, r25
    569c:	88 0f       	add	r24, r24
    569e:	99 1f       	adc	r25, r25
    56a0:	88 0f       	add	r24, r24
    56a2:	99 1f       	adc	r25, r25
    56a4:	82 0f       	add	r24, r18
    56a6:	93 1f       	adc	r25, r19
    56a8:	fc 01       	movw	r30, r24
    56aa:	e8 5a       	subi	r30, 0xA8	; 168
    56ac:	f8 4f       	sbci	r31, 0xF8	; 248
    56ae:	80 81       	ld	r24, Z
    56b0:	8f 5f       	subi	r24, 0xFF	; 255
    56b2:	80 83       	st	Z, r24
    56b4:	30 c0       	rjmp	.+96     	; 0x5716 <xTaskRemoveFromEventList+0x252>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    56b6:	80 91 93 07 	lds	r24, 0x0793
    56ba:	90 91 94 07 	lds	r25, 0x0794
    56be:	9a 83       	std	Y+2, r25	; 0x02
    56c0:	89 83       	std	Y+1, r24	; 0x01
    56c2:	ea 85       	ldd	r30, Y+10	; 0x0a
    56c4:	fb 85       	ldd	r31, Y+11	; 0x0b
    56c6:	89 81       	ldd	r24, Y+1	; 0x01
    56c8:	9a 81       	ldd	r25, Y+2	; 0x02
    56ca:	97 87       	std	Z+15, r25	; 0x0f
    56cc:	86 87       	std	Z+14, r24	; 0x0e
    56ce:	e9 81       	ldd	r30, Y+1	; 0x01
    56d0:	fa 81       	ldd	r31, Y+2	; 0x02
    56d2:	84 81       	ldd	r24, Z+4	; 0x04
    56d4:	95 81       	ldd	r25, Z+5	; 0x05
    56d6:	ea 85       	ldd	r30, Y+10	; 0x0a
    56d8:	fb 85       	ldd	r31, Y+11	; 0x0b
    56da:	91 8b       	std	Z+17, r25	; 0x11
    56dc:	80 8b       	std	Z+16, r24	; 0x10
    56de:	e9 81       	ldd	r30, Y+1	; 0x01
    56e0:	fa 81       	ldd	r31, Y+2	; 0x02
    56e2:	04 80       	ldd	r0, Z+4	; 0x04
    56e4:	f5 81       	ldd	r31, Z+5	; 0x05
    56e6:	e0 2d       	mov	r30, r0
    56e8:	8a 85       	ldd	r24, Y+10	; 0x0a
    56ea:	9b 85       	ldd	r25, Y+11	; 0x0b
    56ec:	0c 96       	adiw	r24, 0x0c	; 12
    56ee:	93 83       	std	Z+3, r25	; 0x03
    56f0:	82 83       	std	Z+2, r24	; 0x02
    56f2:	8a 85       	ldd	r24, Y+10	; 0x0a
    56f4:	9b 85       	ldd	r25, Y+11	; 0x0b
    56f6:	0c 96       	adiw	r24, 0x0c	; 12
    56f8:	e9 81       	ldd	r30, Y+1	; 0x01
    56fa:	fa 81       	ldd	r31, Y+2	; 0x02
    56fc:	95 83       	std	Z+5, r25	; 0x05
    56fe:	84 83       	std	Z+4, r24	; 0x04
    5700:	ea 85       	ldd	r30, Y+10	; 0x0a
    5702:	fb 85       	ldd	r31, Y+11	; 0x0b
    5704:	82 e9       	ldi	r24, 0x92	; 146
    5706:	97 e0       	ldi	r25, 0x07	; 7
    5708:	95 8b       	std	Z+21, r25	; 0x15
    570a:	84 8b       	std	Z+20, r24	; 0x14
    570c:	80 91 92 07 	lds	r24, 0x0792
    5710:	8f 5f       	subi	r24, 0xFF	; 255
    5712:	80 93 92 07 	sts	0x0792, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    5716:	ea 85       	ldd	r30, Y+10	; 0x0a
    5718:	fb 85       	ldd	r31, Y+11	; 0x0b
    571a:	96 89       	ldd	r25, Z+22	; 0x16
    571c:	e0 91 46 07 	lds	r30, 0x0746
    5720:	f0 91 47 07 	lds	r31, 0x0747
    5724:	86 89       	ldd	r24, Z+22	; 0x16
    5726:	89 17       	cp	r24, r25
    5728:	30 f4       	brcc	.+12     	; 0x5736 <xTaskRemoveFromEventList+0x272>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
    572a:	81 e0       	ldi	r24, 0x01	; 1
    572c:	89 87       	std	Y+9, r24	; 0x09

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    572e:	81 e0       	ldi	r24, 0x01	; 1
    5730:	80 93 50 07 	sts	0x0750, r24
    5734:	01 c0       	rjmp	.+2      	; 0x5738 <xTaskRemoveFromEventList+0x274>
    }
    else
    {
        xReturn = pdFALSE;
    5736:	19 86       	std	Y+9, r1	; 0x09
    }

    return xReturn;
    5738:	89 85       	ldd	r24, Y+9	; 0x09
}
    573a:	2d 96       	adiw	r28, 0x0d	; 13
    573c:	0f b6       	in	r0, 0x3f	; 63
    573e:	f8 94       	cli
    5740:	de bf       	out	0x3e, r29	; 62
    5742:	0f be       	out	0x3f, r0	; 63
    5744:	cd bf       	out	0x3d, r28	; 61
    5746:	cf 91       	pop	r28
    5748:	df 91       	pop	r29
    574a:	08 95       	ret

0000574c <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    574c:	df 93       	push	r29
    574e:	cf 93       	push	r28
    5750:	cd b7       	in	r28, 0x3d	; 61
    5752:	de b7       	in	r29, 0x3e	; 62
    5754:	2c 97       	sbiw	r28, 0x0c	; 12
    5756:	0f b6       	in	r0, 0x3f	; 63
    5758:	f8 94       	cli
    575a:	de bf       	out	0x3e, r29	; 62
    575c:	0f be       	out	0x3f, r0	; 63
    575e:	cd bf       	out	0x3d, r28	; 61
    5760:	9a 87       	std	Y+10, r25	; 0x0a
    5762:	89 87       	std	Y+9, r24	; 0x09
    5764:	7c 87       	std	Y+12, r23	; 0x0c
    5766:	6b 87       	std	Y+11, r22	; 0x0b
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5768:	8b 85       	ldd	r24, Y+11	; 0x0b
    576a:	9c 85       	ldd	r25, Y+12	; 0x0c
    576c:	90 68       	ori	r25, 0x80	; 128
    576e:	e9 85       	ldd	r30, Y+9	; 0x09
    5770:	fa 85       	ldd	r31, Y+10	; 0x0a
    5772:	91 83       	std	Z+1, r25	; 0x01
    5774:	80 83       	st	Z, r24

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5776:	e9 85       	ldd	r30, Y+9	; 0x09
    5778:	fa 85       	ldd	r31, Y+10	; 0x0a
    577a:	86 81       	ldd	r24, Z+6	; 0x06
    577c:	97 81       	ldd	r25, Z+7	; 0x07
    577e:	98 87       	std	Y+8, r25	; 0x08
    5780:	8f 83       	std	Y+7, r24	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    5782:	e9 85       	ldd	r30, Y+9	; 0x09
    5784:	fa 85       	ldd	r31, Y+10	; 0x0a
    5786:	80 85       	ldd	r24, Z+8	; 0x08
    5788:	91 85       	ldd	r25, Z+9	; 0x09
    578a:	9e 83       	std	Y+6, r25	; 0x06
    578c:	8d 83       	std	Y+5, r24	; 0x05
    578e:	e9 85       	ldd	r30, Y+9	; 0x09
    5790:	fa 85       	ldd	r31, Y+10	; 0x0a
    5792:	a2 81       	ldd	r26, Z+2	; 0x02
    5794:	b3 81       	ldd	r27, Z+3	; 0x03
    5796:	e9 85       	ldd	r30, Y+9	; 0x09
    5798:	fa 85       	ldd	r31, Y+10	; 0x0a
    579a:	84 81       	ldd	r24, Z+4	; 0x04
    579c:	95 81       	ldd	r25, Z+5	; 0x05
    579e:	15 96       	adiw	r26, 0x05	; 5
    57a0:	9c 93       	st	X, r25
    57a2:	8e 93       	st	-X, r24
    57a4:	14 97       	sbiw	r26, 0x04	; 4
    57a6:	e9 85       	ldd	r30, Y+9	; 0x09
    57a8:	fa 85       	ldd	r31, Y+10	; 0x0a
    57aa:	a4 81       	ldd	r26, Z+4	; 0x04
    57ac:	b5 81       	ldd	r27, Z+5	; 0x05
    57ae:	e9 85       	ldd	r30, Y+9	; 0x09
    57b0:	fa 85       	ldd	r31, Y+10	; 0x0a
    57b2:	82 81       	ldd	r24, Z+2	; 0x02
    57b4:	93 81       	ldd	r25, Z+3	; 0x03
    57b6:	13 96       	adiw	r26, 0x03	; 3
    57b8:	9c 93       	st	X, r25
    57ba:	8e 93       	st	-X, r24
    57bc:	12 97       	sbiw	r26, 0x02	; 2
    57be:	ed 81       	ldd	r30, Y+5	; 0x05
    57c0:	fe 81       	ldd	r31, Y+6	; 0x06
    57c2:	21 81       	ldd	r18, Z+1	; 0x01
    57c4:	32 81       	ldd	r19, Z+2	; 0x02
    57c6:	89 85       	ldd	r24, Y+9	; 0x09
    57c8:	9a 85       	ldd	r25, Y+10	; 0x0a
    57ca:	28 17       	cp	r18, r24
    57cc:	39 07       	cpc	r19, r25
    57ce:	41 f4       	brne	.+16     	; 0x57e0 <vTaskRemoveFromUnorderedEventList+0x94>
    57d0:	e9 85       	ldd	r30, Y+9	; 0x09
    57d2:	fa 85       	ldd	r31, Y+10	; 0x0a
    57d4:	84 81       	ldd	r24, Z+4	; 0x04
    57d6:	95 81       	ldd	r25, Z+5	; 0x05
    57d8:	ed 81       	ldd	r30, Y+5	; 0x05
    57da:	fe 81       	ldd	r31, Y+6	; 0x06
    57dc:	92 83       	std	Z+2, r25	; 0x02
    57de:	81 83       	std	Z+1, r24	; 0x01
    57e0:	e9 85       	ldd	r30, Y+9	; 0x09
    57e2:	fa 85       	ldd	r31, Y+10	; 0x0a
    57e4:	11 86       	std	Z+9, r1	; 0x09
    57e6:	10 86       	std	Z+8, r1	; 0x08
    57e8:	ed 81       	ldd	r30, Y+5	; 0x05
    57ea:	fe 81       	ldd	r31, Y+6	; 0x06
    57ec:	80 81       	ld	r24, Z
    57ee:	81 50       	subi	r24, 0x01	; 1
    57f0:	ed 81       	ldd	r30, Y+5	; 0x05
    57f2:	fe 81       	ldd	r31, Y+6	; 0x06
    57f4:	80 83       	st	Z, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    57f6:	ef 81       	ldd	r30, Y+7	; 0x07
    57f8:	f8 85       	ldd	r31, Y+8	; 0x08
    57fa:	82 85       	ldd	r24, Z+10	; 0x0a
    57fc:	93 85       	ldd	r25, Z+11	; 0x0b
    57fe:	9c 83       	std	Y+4, r25	; 0x04
    5800:	8b 83       	std	Y+3, r24	; 0x03
    5802:	ef 81       	ldd	r30, Y+7	; 0x07
    5804:	f8 85       	ldd	r31, Y+8	; 0x08
    5806:	a4 81       	ldd	r26, Z+4	; 0x04
    5808:	b5 81       	ldd	r27, Z+5	; 0x05
    580a:	ef 81       	ldd	r30, Y+7	; 0x07
    580c:	f8 85       	ldd	r31, Y+8	; 0x08
    580e:	86 81       	ldd	r24, Z+6	; 0x06
    5810:	97 81       	ldd	r25, Z+7	; 0x07
    5812:	15 96       	adiw	r26, 0x05	; 5
    5814:	9c 93       	st	X, r25
    5816:	8e 93       	st	-X, r24
    5818:	14 97       	sbiw	r26, 0x04	; 4
    581a:	ef 81       	ldd	r30, Y+7	; 0x07
    581c:	f8 85       	ldd	r31, Y+8	; 0x08
    581e:	a6 81       	ldd	r26, Z+6	; 0x06
    5820:	b7 81       	ldd	r27, Z+7	; 0x07
    5822:	ef 81       	ldd	r30, Y+7	; 0x07
    5824:	f8 85       	ldd	r31, Y+8	; 0x08
    5826:	84 81       	ldd	r24, Z+4	; 0x04
    5828:	95 81       	ldd	r25, Z+5	; 0x05
    582a:	13 96       	adiw	r26, 0x03	; 3
    582c:	9c 93       	st	X, r25
    582e:	8e 93       	st	-X, r24
    5830:	12 97       	sbiw	r26, 0x02	; 2
    5832:	eb 81       	ldd	r30, Y+3	; 0x03
    5834:	fc 81       	ldd	r31, Y+4	; 0x04
    5836:	21 81       	ldd	r18, Z+1	; 0x01
    5838:	32 81       	ldd	r19, Z+2	; 0x02
    583a:	8f 81       	ldd	r24, Y+7	; 0x07
    583c:	98 85       	ldd	r25, Y+8	; 0x08
    583e:	02 96       	adiw	r24, 0x02	; 2
    5840:	28 17       	cp	r18, r24
    5842:	39 07       	cpc	r19, r25
    5844:	41 f4       	brne	.+16     	; 0x5856 <vTaskRemoveFromUnorderedEventList+0x10a>
    5846:	ef 81       	ldd	r30, Y+7	; 0x07
    5848:	f8 85       	ldd	r31, Y+8	; 0x08
    584a:	86 81       	ldd	r24, Z+6	; 0x06
    584c:	97 81       	ldd	r25, Z+7	; 0x07
    584e:	eb 81       	ldd	r30, Y+3	; 0x03
    5850:	fc 81       	ldd	r31, Y+4	; 0x04
    5852:	92 83       	std	Z+2, r25	; 0x02
    5854:	81 83       	std	Z+1, r24	; 0x01
    5856:	ef 81       	ldd	r30, Y+7	; 0x07
    5858:	f8 85       	ldd	r31, Y+8	; 0x08
    585a:	13 86       	std	Z+11, r1	; 0x0b
    585c:	12 86       	std	Z+10, r1	; 0x0a
    585e:	eb 81       	ldd	r30, Y+3	; 0x03
    5860:	fc 81       	ldd	r31, Y+4	; 0x04
    5862:	80 81       	ld	r24, Z
    5864:	81 50       	subi	r24, 0x01	; 1
    5866:	eb 81       	ldd	r30, Y+3	; 0x03
    5868:	fc 81       	ldd	r31, Y+4	; 0x04
    586a:	80 83       	st	Z, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    586c:	ef 81       	ldd	r30, Y+7	; 0x07
    586e:	f8 85       	ldd	r31, Y+8	; 0x08
    5870:	96 89       	ldd	r25, Z+22	; 0x16
    5872:	80 91 4c 07 	lds	r24, 0x074C
    5876:	89 17       	cp	r24, r25
    5878:	28 f4       	brcc	.+10     	; 0x5884 <vTaskRemoveFromUnorderedEventList+0x138>
    587a:	ef 81       	ldd	r30, Y+7	; 0x07
    587c:	f8 85       	ldd	r31, Y+8	; 0x08
    587e:	86 89       	ldd	r24, Z+22	; 0x16
    5880:	80 93 4c 07 	sts	0x074C, r24
    5884:	ef 81       	ldd	r30, Y+7	; 0x07
    5886:	f8 85       	ldd	r31, Y+8	; 0x08
    5888:	86 89       	ldd	r24, Z+22	; 0x16
    588a:	28 2f       	mov	r18, r24
    588c:	30 e0       	ldi	r19, 0x00	; 0
    588e:	c9 01       	movw	r24, r18
    5890:	88 0f       	add	r24, r24
    5892:	99 1f       	adc	r25, r25
    5894:	88 0f       	add	r24, r24
    5896:	99 1f       	adc	r25, r25
    5898:	88 0f       	add	r24, r24
    589a:	99 1f       	adc	r25, r25
    589c:	82 0f       	add	r24, r18
    589e:	93 1f       	adc	r25, r19
    58a0:	fc 01       	movw	r30, r24
    58a2:	e8 5a       	subi	r30, 0xA8	; 168
    58a4:	f8 4f       	sbci	r31, 0xF8	; 248
    58a6:	81 81       	ldd	r24, Z+1	; 0x01
    58a8:	92 81       	ldd	r25, Z+2	; 0x02
    58aa:	9a 83       	std	Y+2, r25	; 0x02
    58ac:	89 83       	std	Y+1, r24	; 0x01
    58ae:	ef 81       	ldd	r30, Y+7	; 0x07
    58b0:	f8 85       	ldd	r31, Y+8	; 0x08
    58b2:	89 81       	ldd	r24, Y+1	; 0x01
    58b4:	9a 81       	ldd	r25, Y+2	; 0x02
    58b6:	95 83       	std	Z+5, r25	; 0x05
    58b8:	84 83       	std	Z+4, r24	; 0x04
    58ba:	e9 81       	ldd	r30, Y+1	; 0x01
    58bc:	fa 81       	ldd	r31, Y+2	; 0x02
    58be:	84 81       	ldd	r24, Z+4	; 0x04
    58c0:	95 81       	ldd	r25, Z+5	; 0x05
    58c2:	ef 81       	ldd	r30, Y+7	; 0x07
    58c4:	f8 85       	ldd	r31, Y+8	; 0x08
    58c6:	97 83       	std	Z+7, r25	; 0x07
    58c8:	86 83       	std	Z+6, r24	; 0x06
    58ca:	e9 81       	ldd	r30, Y+1	; 0x01
    58cc:	fa 81       	ldd	r31, Y+2	; 0x02
    58ce:	04 80       	ldd	r0, Z+4	; 0x04
    58d0:	f5 81       	ldd	r31, Z+5	; 0x05
    58d2:	e0 2d       	mov	r30, r0
    58d4:	8f 81       	ldd	r24, Y+7	; 0x07
    58d6:	98 85       	ldd	r25, Y+8	; 0x08
    58d8:	02 96       	adiw	r24, 0x02	; 2
    58da:	93 83       	std	Z+3, r25	; 0x03
    58dc:	82 83       	std	Z+2, r24	; 0x02
    58de:	8f 81       	ldd	r24, Y+7	; 0x07
    58e0:	98 85       	ldd	r25, Y+8	; 0x08
    58e2:	02 96       	adiw	r24, 0x02	; 2
    58e4:	e9 81       	ldd	r30, Y+1	; 0x01
    58e6:	fa 81       	ldd	r31, Y+2	; 0x02
    58e8:	95 83       	std	Z+5, r25	; 0x05
    58ea:	84 83       	std	Z+4, r24	; 0x04
    58ec:	ef 81       	ldd	r30, Y+7	; 0x07
    58ee:	f8 85       	ldd	r31, Y+8	; 0x08
    58f0:	86 89       	ldd	r24, Z+22	; 0x16
    58f2:	28 2f       	mov	r18, r24
    58f4:	30 e0       	ldi	r19, 0x00	; 0
    58f6:	c9 01       	movw	r24, r18
    58f8:	88 0f       	add	r24, r24
    58fa:	99 1f       	adc	r25, r25
    58fc:	88 0f       	add	r24, r24
    58fe:	99 1f       	adc	r25, r25
    5900:	88 0f       	add	r24, r24
    5902:	99 1f       	adc	r25, r25
    5904:	82 0f       	add	r24, r18
    5906:	93 1f       	adc	r25, r19
    5908:	88 5a       	subi	r24, 0xA8	; 168
    590a:	98 4f       	sbci	r25, 0xF8	; 248
    590c:	ef 81       	ldd	r30, Y+7	; 0x07
    590e:	f8 85       	ldd	r31, Y+8	; 0x08
    5910:	93 87       	std	Z+11, r25	; 0x0b
    5912:	82 87       	std	Z+10, r24	; 0x0a
    5914:	ef 81       	ldd	r30, Y+7	; 0x07
    5916:	f8 85       	ldd	r31, Y+8	; 0x08
    5918:	86 89       	ldd	r24, Z+22	; 0x16
    591a:	28 2f       	mov	r18, r24
    591c:	30 e0       	ldi	r19, 0x00	; 0
    591e:	c9 01       	movw	r24, r18
    5920:	88 0f       	add	r24, r24
    5922:	99 1f       	adc	r25, r25
    5924:	88 0f       	add	r24, r24
    5926:	99 1f       	adc	r25, r25
    5928:	88 0f       	add	r24, r24
    592a:	99 1f       	adc	r25, r25
    592c:	82 0f       	add	r24, r18
    592e:	93 1f       	adc	r25, r19
    5930:	fc 01       	movw	r30, r24
    5932:	e8 5a       	subi	r30, 0xA8	; 168
    5934:	f8 4f       	sbci	r31, 0xF8	; 248
    5936:	80 81       	ld	r24, Z
    5938:	8f 5f       	subi	r24, 0xFF	; 255
    593a:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    593c:	ef 81       	ldd	r30, Y+7	; 0x07
    593e:	f8 85       	ldd	r31, Y+8	; 0x08
    5940:	96 89       	ldd	r25, Z+22	; 0x16
    5942:	e0 91 46 07 	lds	r30, 0x0746
    5946:	f0 91 47 07 	lds	r31, 0x0747
    594a:	86 89       	ldd	r24, Z+22	; 0x16
    594c:	89 17       	cp	r24, r25
    594e:	18 f4       	brcc	.+6      	; 0x5956 <vTaskRemoveFromUnorderedEventList+0x20a>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    5950:	81 e0       	ldi	r24, 0x01	; 1
    5952:	80 93 50 07 	sts	0x0750, r24
    }
}
    5956:	2c 96       	adiw	r28, 0x0c	; 12
    5958:	0f b6       	in	r0, 0x3f	; 63
    595a:	f8 94       	cli
    595c:	de bf       	out	0x3e, r29	; 62
    595e:	0f be       	out	0x3f, r0	; 63
    5960:	cd bf       	out	0x3d, r28	; 61
    5962:	cf 91       	pop	r28
    5964:	df 91       	pop	r29
    5966:	08 95       	ret

00005968 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    5968:	df 93       	push	r29
    596a:	cf 93       	push	r28
    596c:	00 d0       	rcall	.+0      	; 0x596e <vTaskSetTimeOutState+0x6>
    596e:	cd b7       	in	r28, 0x3d	; 61
    5970:	de b7       	in	r29, 0x3e	; 62
    5972:	9a 83       	std	Y+2, r25	; 0x02
    5974:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    5976:	0f b6       	in	r0, 0x3f	; 63
    5978:	f8 94       	cli
    597a:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    597c:	80 91 51 07 	lds	r24, 0x0751
    5980:	e9 81       	ldd	r30, Y+1	; 0x01
    5982:	fa 81       	ldd	r31, Y+2	; 0x02
    5984:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    5986:	80 91 4a 07 	lds	r24, 0x074A
    598a:	90 91 4b 07 	lds	r25, 0x074B
    598e:	e9 81       	ldd	r30, Y+1	; 0x01
    5990:	fa 81       	ldd	r31, Y+2	; 0x02
    5992:	92 83       	std	Z+2, r25	; 0x02
    5994:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    5996:	0f 90       	pop	r0
    5998:	0f be       	out	0x3f, r0	; 63
}
    599a:	0f 90       	pop	r0
    599c:	0f 90       	pop	r0
    599e:	cf 91       	pop	r28
    59a0:	df 91       	pop	r29
    59a2:	08 95       	ret

000059a4 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    59a4:	df 93       	push	r29
    59a6:	cf 93       	push	r28
    59a8:	00 d0       	rcall	.+0      	; 0x59aa <vTaskInternalSetTimeOutState+0x6>
    59aa:	cd b7       	in	r28, 0x3d	; 61
    59ac:	de b7       	in	r29, 0x3e	; 62
    59ae:	9a 83       	std	Y+2, r25	; 0x02
    59b0:	89 83       	std	Y+1, r24	; 0x01
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    59b2:	80 91 51 07 	lds	r24, 0x0751
    59b6:	e9 81       	ldd	r30, Y+1	; 0x01
    59b8:	fa 81       	ldd	r31, Y+2	; 0x02
    59ba:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    59bc:	80 91 4a 07 	lds	r24, 0x074A
    59c0:	90 91 4b 07 	lds	r25, 0x074B
    59c4:	e9 81       	ldd	r30, Y+1	; 0x01
    59c6:	fa 81       	ldd	r31, Y+2	; 0x02
    59c8:	92 83       	std	Z+2, r25	; 0x02
    59ca:	81 83       	std	Z+1, r24	; 0x01
}
    59cc:	0f 90       	pop	r0
    59ce:	0f 90       	pop	r0
    59d0:	cf 91       	pop	r28
    59d2:	df 91       	pop	r29
    59d4:	08 95       	ret

000059d6 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    59d6:	df 93       	push	r29
    59d8:	cf 93       	push	r28
    59da:	cd b7       	in	r28, 0x3d	; 61
    59dc:	de b7       	in	r29, 0x3e	; 62
    59de:	29 97       	sbiw	r28, 0x09	; 9
    59e0:	0f b6       	in	r0, 0x3f	; 63
    59e2:	f8 94       	cli
    59e4:	de bf       	out	0x3e, r29	; 62
    59e6:	0f be       	out	0x3f, r0	; 63
    59e8:	cd bf       	out	0x3d, r28	; 61
    59ea:	9f 83       	std	Y+7, r25	; 0x07
    59ec:	8e 83       	std	Y+6, r24	; 0x06
    59ee:	79 87       	std	Y+9, r23	; 0x09
    59f0:	68 87       	std	Y+8, r22	; 0x08
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    59f2:	0f b6       	in	r0, 0x3f	; 63
    59f4:	f8 94       	cli
    59f6:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    59f8:	80 91 4a 07 	lds	r24, 0x074A
    59fc:	90 91 4b 07 	lds	r25, 0x074B
    5a00:	9c 83       	std	Y+4, r25	; 0x04
    5a02:	8b 83       	std	Y+3, r24	; 0x03
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    5a04:	ee 81       	ldd	r30, Y+6	; 0x06
    5a06:	ff 81       	ldd	r31, Y+7	; 0x07
    5a08:	21 81       	ldd	r18, Z+1	; 0x01
    5a0a:	32 81       	ldd	r19, Z+2	; 0x02
    5a0c:	8b 81       	ldd	r24, Y+3	; 0x03
    5a0e:	9c 81       	ldd	r25, Y+4	; 0x04
    5a10:	82 1b       	sub	r24, r18
    5a12:	93 0b       	sbc	r25, r19
    5a14:	9a 83       	std	Y+2, r25	; 0x02
    5a16:	89 83       	std	Y+1, r24	; 0x01
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    5a18:	ee 81       	ldd	r30, Y+6	; 0x06
    5a1a:	ff 81       	ldd	r31, Y+7	; 0x07
    5a1c:	90 81       	ld	r25, Z
    5a1e:	80 91 51 07 	lds	r24, 0x0751
    5a22:	98 17       	cp	r25, r24
    5a24:	81 f0       	breq	.+32     	; 0x5a46 <xTaskCheckForTimeOut+0x70>
    5a26:	ee 81       	ldd	r30, Y+6	; 0x06
    5a28:	ff 81       	ldd	r31, Y+7	; 0x07
    5a2a:	21 81       	ldd	r18, Z+1	; 0x01
    5a2c:	32 81       	ldd	r19, Z+2	; 0x02
    5a2e:	8b 81       	ldd	r24, Y+3	; 0x03
    5a30:	9c 81       	ldd	r25, Y+4	; 0x04
    5a32:	82 17       	cp	r24, r18
    5a34:	93 07       	cpc	r25, r19
    5a36:	38 f0       	brcs	.+14     	; 0x5a46 <xTaskCheckForTimeOut+0x70>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    5a38:	81 e0       	ldi	r24, 0x01	; 1
    5a3a:	8d 83       	std	Y+5, r24	; 0x05
            *pxTicksToWait = ( TickType_t ) 0;
    5a3c:	e8 85       	ldd	r30, Y+8	; 0x08
    5a3e:	f9 85       	ldd	r31, Y+9	; 0x09
    5a40:	11 82       	std	Z+1, r1	; 0x01
    5a42:	10 82       	st	Z, r1
    5a44:	23 c0       	rjmp	.+70     	; 0x5a8c <xTaskCheckForTimeOut+0xb6>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    5a46:	e8 85       	ldd	r30, Y+8	; 0x08
    5a48:	f9 85       	ldd	r31, Y+9	; 0x09
    5a4a:	20 81       	ld	r18, Z
    5a4c:	31 81       	ldd	r19, Z+1	; 0x01
    5a4e:	89 81       	ldd	r24, Y+1	; 0x01
    5a50:	9a 81       	ldd	r25, Y+2	; 0x02
    5a52:	82 17       	cp	r24, r18
    5a54:	93 07       	cpc	r25, r19
    5a56:	a0 f4       	brcc	.+40     	; 0x5a80 <xTaskCheckForTimeOut+0xaa>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    5a58:	e8 85       	ldd	r30, Y+8	; 0x08
    5a5a:	f9 85       	ldd	r31, Y+9	; 0x09
    5a5c:	20 81       	ld	r18, Z
    5a5e:	31 81       	ldd	r19, Z+1	; 0x01
    5a60:	89 81       	ldd	r24, Y+1	; 0x01
    5a62:	9a 81       	ldd	r25, Y+2	; 0x02
    5a64:	a9 01       	movw	r20, r18
    5a66:	48 1b       	sub	r20, r24
    5a68:	59 0b       	sbc	r21, r25
    5a6a:	ca 01       	movw	r24, r20
    5a6c:	e8 85       	ldd	r30, Y+8	; 0x08
    5a6e:	f9 85       	ldd	r31, Y+9	; 0x09
    5a70:	91 83       	std	Z+1, r25	; 0x01
    5a72:	80 83       	st	Z, r24
            vTaskInternalSetTimeOutState( pxTimeOut );
    5a74:	8e 81       	ldd	r24, Y+6	; 0x06
    5a76:	9f 81       	ldd	r25, Y+7	; 0x07
    5a78:	0e 94 d2 2c 	call	0x59a4	; 0x59a4 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
    5a7c:	1d 82       	std	Y+5, r1	; 0x05
    5a7e:	06 c0       	rjmp	.+12     	; 0x5a8c <xTaskCheckForTimeOut+0xb6>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    5a80:	e8 85       	ldd	r30, Y+8	; 0x08
    5a82:	f9 85       	ldd	r31, Y+9	; 0x09
    5a84:	11 82       	std	Z+1, r1	; 0x01
    5a86:	10 82       	st	Z, r1
            xReturn = pdTRUE;
    5a88:	81 e0       	ldi	r24, 0x01	; 1
    5a8a:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    5a8c:	0f 90       	pop	r0
    5a8e:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    5a90:	8d 81       	ldd	r24, Y+5	; 0x05
}
    5a92:	29 96       	adiw	r28, 0x09	; 9
    5a94:	0f b6       	in	r0, 0x3f	; 63
    5a96:	f8 94       	cli
    5a98:	de bf       	out	0x3e, r29	; 62
    5a9a:	0f be       	out	0x3f, r0	; 63
    5a9c:	cd bf       	out	0x3d, r28	; 61
    5a9e:	cf 91       	pop	r28
    5aa0:	df 91       	pop	r29
    5aa2:	08 95       	ret

00005aa4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    5aa4:	df 93       	push	r29
    5aa6:	cf 93       	push	r28
    5aa8:	cd b7       	in	r28, 0x3d	; 61
    5aaa:	de b7       	in	r29, 0x3e	; 62
    xYieldPending = pdTRUE;
    5aac:	81 e0       	ldi	r24, 0x01	; 1
    5aae:	80 93 50 07 	sts	0x0750, r24
}
    5ab2:	cf 91       	pop	r28
    5ab4:	df 91       	pop	r29
    5ab6:	08 95       	ret

00005ab8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    5ab8:	df 93       	push	r29
    5aba:	cf 93       	push	r28
    5abc:	00 d0       	rcall	.+0      	; 0x5abe <prvIdleTask+0x6>
    5abe:	cd b7       	in	r28, 0x3d	; 61
    5ac0:	de b7       	in	r29, 0x3e	; 62
    5ac2:	9a 83       	std	Y+2, r25	; 0x02
    5ac4:	89 83       	std	Y+1, r24	; 0x01

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    5ac6:	0e 94 a9 2d 	call	0x5b52	; 0x5b52 <prvCheckTasksWaitingTermination>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    5aca:	80 91 58 07 	lds	r24, 0x0758
    5ace:	82 30       	cpi	r24, 0x02	; 2
    5ad0:	d0 f3       	brcs	.-12     	; 0x5ac6 <prvIdleTask+0xe>
                {
                    taskYIELD();
    5ad2:	0e 94 86 10 	call	0x210c	; 0x210c <vPortYield>
    5ad6:	f7 cf       	rjmp	.-18     	; 0x5ac6 <prvIdleTask+0xe>

00005ad8 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    5ad8:	df 93       	push	r29
    5ada:	cf 93       	push	r28
    5adc:	0f 92       	push	r0
    5ade:	cd b7       	in	r28, 0x3d	; 61
    5ae0:	de b7       	in	r29, 0x3e	; 62
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5ae2:	19 82       	std	Y+1, r1	; 0x01
    5ae4:	13 c0       	rjmp	.+38     	; 0x5b0c <prvInitialiseTaskLists+0x34>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    5ae6:	89 81       	ldd	r24, Y+1	; 0x01
    5ae8:	28 2f       	mov	r18, r24
    5aea:	30 e0       	ldi	r19, 0x00	; 0
    5aec:	c9 01       	movw	r24, r18
    5aee:	88 0f       	add	r24, r24
    5af0:	99 1f       	adc	r25, r25
    5af2:	88 0f       	add	r24, r24
    5af4:	99 1f       	adc	r25, r25
    5af6:	88 0f       	add	r24, r24
    5af8:	99 1f       	adc	r25, r25
    5afa:	82 0f       	add	r24, r18
    5afc:	93 1f       	adc	r25, r19
    5afe:	88 5a       	subi	r24, 0xA8	; 168
    5b00:	98 4f       	sbci	r25, 0xF8	; 248
    5b02:	0e 94 bf 17 	call	0x2f7e	; 0x2f7e <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5b06:	89 81       	ldd	r24, Y+1	; 0x01
    5b08:	8f 5f       	subi	r24, 0xFF	; 255
    5b0a:	89 83       	std	Y+1, r24	; 0x01
    5b0c:	89 81       	ldd	r24, Y+1	; 0x01
    5b0e:	84 30       	cpi	r24, 0x04	; 4
    5b10:	50 f3       	brcs	.-44     	; 0x5ae6 <prvInitialiseTaskLists+0xe>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    5b12:	8c e7       	ldi	r24, 0x7C	; 124
    5b14:	97 e0       	ldi	r25, 0x07	; 7
    5b16:	0e 94 bf 17 	call	0x2f7e	; 0x2f7e <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    5b1a:	85 e8       	ldi	r24, 0x85	; 133
    5b1c:	97 e0       	ldi	r25, 0x07	; 7
    5b1e:	0e 94 bf 17 	call	0x2f7e	; 0x2f7e <vListInitialise>
    vListInitialise( &xPendingReadyList );
    5b22:	82 e9       	ldi	r24, 0x92	; 146
    5b24:	97 e0       	ldi	r25, 0x07	; 7
    5b26:	0e 94 bf 17 	call	0x2f7e	; 0x2f7e <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
    5b2a:	8b e9       	ldi	r24, 0x9B	; 155
    5b2c:	97 e0       	ldi	r25, 0x07	; 7
    5b2e:	0e 94 bf 17 	call	0x2f7e	; 0x2f7e <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    5b32:	8c e7       	ldi	r24, 0x7C	; 124
    5b34:	97 e0       	ldi	r25, 0x07	; 7
    5b36:	90 93 8f 07 	sts	0x078F, r25
    5b3a:	80 93 8e 07 	sts	0x078E, r24
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    5b3e:	85 e8       	ldi	r24, 0x85	; 133
    5b40:	97 e0       	ldi	r25, 0x07	; 7
    5b42:	90 93 91 07 	sts	0x0791, r25
    5b46:	80 93 90 07 	sts	0x0790, r24
}
    5b4a:	0f 90       	pop	r0
    5b4c:	cf 91       	pop	r28
    5b4e:	df 91       	pop	r29
    5b50:	08 95       	ret

00005b52 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    5b52:	df 93       	push	r29
    5b54:	cf 93       	push	r28
    5b56:	00 d0       	rcall	.+0      	; 0x5b58 <prvCheckTasksWaitingTermination+0x6>
    5b58:	cd b7       	in	r28, 0x3d	; 61
    5b5a:	de b7       	in	r29, 0x3e	; 62
    5b5c:	20 c0       	rjmp	.+64     	; 0x5b9e <prvCheckTasksWaitingTermination+0x4c>

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
    5b5e:	0f b6       	in	r0, 0x3f	; 63
    5b60:	f8 94       	cli
    5b62:	0f 92       	push	r0
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5b64:	e0 91 a0 07 	lds	r30, 0x07A0
    5b68:	f0 91 a1 07 	lds	r31, 0x07A1
    5b6c:	86 81       	ldd	r24, Z+6	; 0x06
    5b6e:	97 81       	ldd	r25, Z+7	; 0x07
    5b70:	9a 83       	std	Y+2, r25	; 0x02
    5b72:	89 83       	std	Y+1, r24	; 0x01
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5b74:	89 81       	ldd	r24, Y+1	; 0x01
    5b76:	9a 81       	ldd	r25, Y+2	; 0x02
    5b78:	02 96       	adiw	r24, 0x02	; 2
    5b7a:	0e 94 a9 18 	call	0x3152	; 0x3152 <uxListRemove>
                    --uxCurrentNumberOfTasks;
    5b7e:	80 91 49 07 	lds	r24, 0x0749
    5b82:	81 50       	subi	r24, 0x01	; 1
    5b84:	80 93 49 07 	sts	0x0749, r24
                    --uxDeletedTasksWaitingCleanUp;
    5b88:	80 91 48 07 	lds	r24, 0x0748
    5b8c:	81 50       	subi	r24, 0x01	; 1
    5b8e:	80 93 48 07 	sts	0x0748, r24
                }
                taskEXIT_CRITICAL();
    5b92:	0f 90       	pop	r0
    5b94:	0f be       	out	0x3f, r0	; 63

                prvDeleteTCB( pxTCB );
    5b96:	89 81       	ldd	r24, Y+1	; 0x01
    5b98:	9a 81       	ldd	r25, Y+2	; 0x02
    5b9a:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <prvDeleteTCB>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    5b9e:	80 91 48 07 	lds	r24, 0x0748
    5ba2:	88 23       	and	r24, r24
    5ba4:	e1 f6       	brne	.-72     	; 0x5b5e <prvCheckTasksWaitingTermination+0xc>

                prvDeleteTCB( pxTCB );
            }
        }
    #endif /* INCLUDE_vTaskDelete */
}
    5ba6:	0f 90       	pop	r0
    5ba8:	0f 90       	pop	r0
    5baa:	cf 91       	pop	r28
    5bac:	df 91       	pop	r29
    5bae:	08 95       	ret

00005bb0 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
    5bb0:	df 93       	push	r29
    5bb2:	cf 93       	push	r28
    5bb4:	00 d0       	rcall	.+0      	; 0x5bb6 <prvDeleteTCB+0x6>
    5bb6:	cd b7       	in	r28, 0x3d	; 61
    5bb8:	de b7       	in	r29, 0x3e	; 62
    5bba:	9a 83       	std	Y+2, r25	; 0x02
    5bbc:	89 83       	std	Y+1, r24	; 0x01

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFreeStack( pxTCB->pxStack );
    5bbe:	e9 81       	ldd	r30, Y+1	; 0x01
    5bc0:	fa 81       	ldd	r31, Y+2	; 0x02
    5bc2:	87 89       	ldd	r24, Z+23	; 0x17
    5bc4:	90 8d       	ldd	r25, Z+24	; 0x18
    5bc6:	0e 94 a1 0e 	call	0x1d42	; 0x1d42 <vPortFree>
                vPortFree( pxTCB );
    5bca:	89 81       	ldd	r24, Y+1	; 0x01
    5bcc:	9a 81       	ldd	r25, Y+2	; 0x02
    5bce:	0e 94 a1 0e 	call	0x1d42	; 0x1d42 <vPortFree>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    5bd2:	0f 90       	pop	r0
    5bd4:	0f 90       	pop	r0
    5bd6:	cf 91       	pop	r28
    5bd8:	df 91       	pop	r29
    5bda:	08 95       	ret

00005bdc <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    5bdc:	df 93       	push	r29
    5bde:	cf 93       	push	r28
    5be0:	cd b7       	in	r28, 0x3d	; 61
    5be2:	de b7       	in	r29, 0x3e	; 62
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    5be4:	e0 91 8e 07 	lds	r30, 0x078E
    5be8:	f0 91 8f 07 	lds	r31, 0x078F
    5bec:	80 81       	ld	r24, Z
    5bee:	88 23       	and	r24, r24
    5bf0:	39 f4       	brne	.+14     	; 0x5c00 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    5bf2:	8f ef       	ldi	r24, 0xFF	; 255
    5bf4:	9f ef       	ldi	r25, 0xFF	; 255
    5bf6:	90 93 54 07 	sts	0x0754, r25
    5bfa:	80 93 53 07 	sts	0x0753, r24
    5bfe:	0d c0       	rjmp	.+26     	; 0x5c1a <prvResetNextTaskUnblockTime+0x3e>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    5c00:	e0 91 8e 07 	lds	r30, 0x078E
    5c04:	f0 91 8f 07 	lds	r31, 0x078F
    5c08:	05 80       	ldd	r0, Z+5	; 0x05
    5c0a:	f6 81       	ldd	r31, Z+6	; 0x06
    5c0c:	e0 2d       	mov	r30, r0
    5c0e:	80 81       	ld	r24, Z
    5c10:	91 81       	ldd	r25, Z+1	; 0x01
    5c12:	90 93 54 07 	sts	0x0754, r25
    5c16:	80 93 53 07 	sts	0x0753, r24
    }
}
    5c1a:	cf 91       	pop	r28
    5c1c:	df 91       	pop	r29
    5c1e:	08 95       	ret

00005c20 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

    BaseType_t xTaskGetSchedulerState( void )
    {
    5c20:	df 93       	push	r29
    5c22:	cf 93       	push	r28
    5c24:	0f 92       	push	r0
    5c26:	cd b7       	in	r28, 0x3d	; 61
    5c28:	de b7       	in	r29, 0x3e	; 62
        BaseType_t xReturn;

        if( xSchedulerRunning == pdFALSE )
    5c2a:	80 91 4d 07 	lds	r24, 0x074D
    5c2e:	88 23       	and	r24, r24
    5c30:	19 f4       	brne	.+6      	; 0x5c38 <xTaskGetSchedulerState+0x18>
        {
            xReturn = taskSCHEDULER_NOT_STARTED;
    5c32:	81 e0       	ldi	r24, 0x01	; 1
    5c34:	89 83       	std	Y+1, r24	; 0x01
    5c36:	08 c0       	rjmp	.+16     	; 0x5c48 <xTaskGetSchedulerState+0x28>
        }
        else
        {
            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5c38:	80 91 57 07 	lds	r24, 0x0757
    5c3c:	88 23       	and	r24, r24
    5c3e:	19 f4       	brne	.+6      	; 0x5c46 <xTaskGetSchedulerState+0x26>
            {
                xReturn = taskSCHEDULER_RUNNING;
    5c40:	82 e0       	ldi	r24, 0x02	; 2
    5c42:	89 83       	std	Y+1, r24	; 0x01
    5c44:	01 c0       	rjmp	.+2      	; 0x5c48 <xTaskGetSchedulerState+0x28>
            }
            else
            {
                xReturn = taskSCHEDULER_SUSPENDED;
    5c46:	19 82       	std	Y+1, r1	; 0x01
            }
        }

        return xReturn;
    5c48:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5c4a:	0f 90       	pop	r0
    5c4c:	cf 91       	pop	r28
    5c4e:	df 91       	pop	r29
    5c50:	08 95       	ret

00005c52 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    5c52:	df 93       	push	r29
    5c54:	cf 93       	push	r28
    5c56:	00 d0       	rcall	.+0      	; 0x5c58 <uxTaskResetEventItemValue+0x6>
    5c58:	cd b7       	in	r28, 0x3d	; 61
    5c5a:	de b7       	in	r29, 0x3e	; 62
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    5c5c:	e0 91 46 07 	lds	r30, 0x0746
    5c60:	f0 91 47 07 	lds	r31, 0x0747
    5c64:	84 85       	ldd	r24, Z+12	; 0x0c
    5c66:	95 85       	ldd	r25, Z+13	; 0x0d
    5c68:	9a 83       	std	Y+2, r25	; 0x02
    5c6a:	89 83       	std	Y+1, r24	; 0x01

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5c6c:	a0 91 46 07 	lds	r26, 0x0746
    5c70:	b0 91 47 07 	lds	r27, 0x0747
    5c74:	e0 91 46 07 	lds	r30, 0x0746
    5c78:	f0 91 47 07 	lds	r31, 0x0747
    5c7c:	86 89       	ldd	r24, Z+22	; 0x16
    5c7e:	28 2f       	mov	r18, r24
    5c80:	30 e0       	ldi	r19, 0x00	; 0
    5c82:	84 e0       	ldi	r24, 0x04	; 4
    5c84:	90 e0       	ldi	r25, 0x00	; 0
    5c86:	82 1b       	sub	r24, r18
    5c88:	93 0b       	sbc	r25, r19
    5c8a:	1d 96       	adiw	r26, 0x0d	; 13
    5c8c:	9c 93       	st	X, r25
    5c8e:	8e 93       	st	-X, r24
    5c90:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
    5c92:	89 81       	ldd	r24, Y+1	; 0x01
    5c94:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5c96:	0f 90       	pop	r0
    5c98:	0f 90       	pop	r0
    5c9a:	cf 91       	pop	r28
    5c9c:	df 91       	pop	r29
    5c9e:	08 95       	ret

00005ca0 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    5ca0:	df 93       	push	r29
    5ca2:	cf 93       	push	r28
    5ca4:	cd b7       	in	r28, 0x3d	; 61
    5ca6:	de b7       	in	r29, 0x3e	; 62
    5ca8:	28 97       	sbiw	r28, 0x08	; 8
    5caa:	0f b6       	in	r0, 0x3f	; 63
    5cac:	f8 94       	cli
    5cae:	de bf       	out	0x3e, r29	; 62
    5cb0:	0f be       	out	0x3f, r0	; 63
    5cb2:	cd bf       	out	0x3d, r28	; 61
    5cb4:	8d 83       	std	Y+5, r24	; 0x05
    5cb6:	6e 83       	std	Y+6, r22	; 0x06
    5cb8:	58 87       	std	Y+8, r21	; 0x08
    5cba:	4f 83       	std	Y+7, r20	; 0x07
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    5cbc:	0f b6       	in	r0, 0x3f	; 63
    5cbe:	f8 94       	cli
    5cc0:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    5cc2:	20 91 46 07 	lds	r18, 0x0746
    5cc6:	30 91 47 07 	lds	r19, 0x0747
    5cca:	8d 81       	ldd	r24, Y+5	; 0x05
    5ccc:	88 2f       	mov	r24, r24
    5cce:	90 e0       	ldi	r25, 0x00	; 0
    5cd0:	88 0f       	add	r24, r24
    5cd2:	99 1f       	adc	r25, r25
    5cd4:	88 0f       	add	r24, r24
    5cd6:	99 1f       	adc	r25, r25
    5cd8:	82 0f       	add	r24, r18
    5cda:	93 1f       	adc	r25, r19
    5cdc:	fc 01       	movw	r30, r24
    5cde:	b1 96       	adiw	r30, 0x21	; 33
    5ce0:	80 81       	ld	r24, Z
    5ce2:	91 81       	ldd	r25, Z+1	; 0x01
    5ce4:	a2 81       	ldd	r26, Z+2	; 0x02
    5ce6:	b3 81       	ldd	r27, Z+3	; 0x03
    5ce8:	00 97       	sbiw	r24, 0x00	; 0
    5cea:	a1 05       	cpc	r26, r1
    5cec:	b1 05       	cpc	r27, r1
    5cee:	c1 f4       	brne	.+48     	; 0x5d20 <ulTaskGenericNotifyTake+0x80>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    5cf0:	20 91 46 07 	lds	r18, 0x0746
    5cf4:	30 91 47 07 	lds	r19, 0x0747
    5cf8:	8d 81       	ldd	r24, Y+5	; 0x05
    5cfa:	88 2f       	mov	r24, r24
    5cfc:	90 e0       	ldi	r25, 0x00	; 0
    5cfe:	82 0f       	add	r24, r18
    5d00:	93 1f       	adc	r25, r19
    5d02:	fc 01       	movw	r30, r24
    5d04:	b5 96       	adiw	r30, 0x25	; 37
    5d06:	81 e0       	ldi	r24, 0x01	; 1
    5d08:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    5d0a:	8f 81       	ldd	r24, Y+7	; 0x07
    5d0c:	98 85       	ldd	r25, Y+8	; 0x08
    5d0e:	00 97       	sbiw	r24, 0x00	; 0
    5d10:	39 f0       	breq	.+14     	; 0x5d20 <ulTaskGenericNotifyTake+0x80>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5d12:	8f 81       	ldd	r24, Y+7	; 0x07
    5d14:	98 85       	ldd	r25, Y+8	; 0x08
    5d16:	61 e0       	ldi	r22, 0x01	; 1
    5d18:	0e 94 d5 35 	call	0x6baa	; 0x6baa <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    5d1c:	0e 94 86 10 	call	0x210c	; 0x210c <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    5d20:	0f 90       	pop	r0
    5d22:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    5d24:	0f b6       	in	r0, 0x3f	; 63
    5d26:	f8 94       	cli
    5d28:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    5d2a:	20 91 46 07 	lds	r18, 0x0746
    5d2e:	30 91 47 07 	lds	r19, 0x0747
    5d32:	8d 81       	ldd	r24, Y+5	; 0x05
    5d34:	88 2f       	mov	r24, r24
    5d36:	90 e0       	ldi	r25, 0x00	; 0
    5d38:	88 0f       	add	r24, r24
    5d3a:	99 1f       	adc	r25, r25
    5d3c:	88 0f       	add	r24, r24
    5d3e:	99 1f       	adc	r25, r25
    5d40:	82 0f       	add	r24, r18
    5d42:	93 1f       	adc	r25, r19
    5d44:	fc 01       	movw	r30, r24
    5d46:	b1 96       	adiw	r30, 0x21	; 33
    5d48:	80 81       	ld	r24, Z
    5d4a:	91 81       	ldd	r25, Z+1	; 0x01
    5d4c:	a2 81       	ldd	r26, Z+2	; 0x02
    5d4e:	b3 81       	ldd	r27, Z+3	; 0x03
    5d50:	89 83       	std	Y+1, r24	; 0x01
    5d52:	9a 83       	std	Y+2, r25	; 0x02
    5d54:	ab 83       	std	Y+3, r26	; 0x03
    5d56:	bc 83       	std	Y+4, r27	; 0x04

            if( ulReturn != 0UL )
    5d58:	89 81       	ldd	r24, Y+1	; 0x01
    5d5a:	9a 81       	ldd	r25, Y+2	; 0x02
    5d5c:	ab 81       	ldd	r26, Y+3	; 0x03
    5d5e:	bc 81       	ldd	r27, Y+4	; 0x04
    5d60:	00 97       	sbiw	r24, 0x00	; 0
    5d62:	a1 05       	cpc	r26, r1
    5d64:	b1 05       	cpc	r27, r1
    5d66:	a9 f1       	breq	.+106    	; 0x5dd2 <ulTaskGenericNotifyTake+0x132>
            {
                if( xClearCountOnExit != pdFALSE )
    5d68:	8e 81       	ldd	r24, Y+6	; 0x06
    5d6a:	88 23       	and	r24, r24
    5d6c:	a1 f0       	breq	.+40     	; 0x5d96 <ulTaskGenericNotifyTake+0xf6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    5d6e:	20 91 46 07 	lds	r18, 0x0746
    5d72:	30 91 47 07 	lds	r19, 0x0747
    5d76:	8d 81       	ldd	r24, Y+5	; 0x05
    5d78:	88 2f       	mov	r24, r24
    5d7a:	90 e0       	ldi	r25, 0x00	; 0
    5d7c:	88 0f       	add	r24, r24
    5d7e:	99 1f       	adc	r25, r25
    5d80:	88 0f       	add	r24, r24
    5d82:	99 1f       	adc	r25, r25
    5d84:	82 0f       	add	r24, r18
    5d86:	93 1f       	adc	r25, r19
    5d88:	fc 01       	movw	r30, r24
    5d8a:	b1 96       	adiw	r30, 0x21	; 33
    5d8c:	10 82       	st	Z, r1
    5d8e:	11 82       	std	Z+1, r1	; 0x01
    5d90:	12 82       	std	Z+2, r1	; 0x02
    5d92:	13 82       	std	Z+3, r1	; 0x03
    5d94:	1e c0       	rjmp	.+60     	; 0x5dd2 <ulTaskGenericNotifyTake+0x132>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    5d96:	e0 91 46 07 	lds	r30, 0x0746
    5d9a:	f0 91 47 07 	lds	r31, 0x0747
    5d9e:	8d 81       	ldd	r24, Y+5	; 0x05
    5da0:	68 2f       	mov	r22, r24
    5da2:	70 e0       	ldi	r23, 0x00	; 0
    5da4:	89 81       	ldd	r24, Y+1	; 0x01
    5da6:	9a 81       	ldd	r25, Y+2	; 0x02
    5da8:	ab 81       	ldd	r26, Y+3	; 0x03
    5daa:	bc 81       	ldd	r27, Y+4	; 0x04
    5dac:	9c 01       	movw	r18, r24
    5dae:	ad 01       	movw	r20, r26
    5db0:	21 50       	subi	r18, 0x01	; 1
    5db2:	30 40       	sbci	r19, 0x00	; 0
    5db4:	40 40       	sbci	r20, 0x00	; 0
    5db6:	50 40       	sbci	r21, 0x00	; 0
    5db8:	cb 01       	movw	r24, r22
    5dba:	88 0f       	add	r24, r24
    5dbc:	99 1f       	adc	r25, r25
    5dbe:	88 0f       	add	r24, r24
    5dc0:	99 1f       	adc	r25, r25
    5dc2:	8e 0f       	add	r24, r30
    5dc4:	9f 1f       	adc	r25, r31
    5dc6:	fc 01       	movw	r30, r24
    5dc8:	b1 96       	adiw	r30, 0x21	; 33
    5dca:	20 83       	st	Z, r18
    5dcc:	31 83       	std	Z+1, r19	; 0x01
    5dce:	42 83       	std	Z+2, r20	; 0x02
    5dd0:	53 83       	std	Z+3, r21	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    5dd2:	20 91 46 07 	lds	r18, 0x0746
    5dd6:	30 91 47 07 	lds	r19, 0x0747
    5dda:	8d 81       	ldd	r24, Y+5	; 0x05
    5ddc:	88 2f       	mov	r24, r24
    5dde:	90 e0       	ldi	r25, 0x00	; 0
    5de0:	82 0f       	add	r24, r18
    5de2:	93 1f       	adc	r25, r19
    5de4:	fc 01       	movw	r30, r24
    5de6:	b5 96       	adiw	r30, 0x25	; 37
    5de8:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    5dea:	0f 90       	pop	r0
    5dec:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    5dee:	89 81       	ldd	r24, Y+1	; 0x01
    5df0:	9a 81       	ldd	r25, Y+2	; 0x02
    5df2:	ab 81       	ldd	r26, Y+3	; 0x03
    5df4:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    5df6:	bc 01       	movw	r22, r24
    5df8:	cd 01       	movw	r24, r26
    5dfa:	28 96       	adiw	r28, 0x08	; 8
    5dfc:	0f b6       	in	r0, 0x3f	; 63
    5dfe:	f8 94       	cli
    5e00:	de bf       	out	0x3e, r29	; 62
    5e02:	0f be       	out	0x3f, r0	; 63
    5e04:	cd bf       	out	0x3d, r28	; 61
    5e06:	cf 91       	pop	r28
    5e08:	df 91       	pop	r29
    5e0a:	08 95       	ret

00005e0c <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    5e0c:	cf 92       	push	r12
    5e0e:	df 92       	push	r13
    5e10:	ef 92       	push	r14
    5e12:	ff 92       	push	r15
    5e14:	0f 93       	push	r16
    5e16:	1f 93       	push	r17
    5e18:	df 93       	push	r29
    5e1a:	cf 93       	push	r28
    5e1c:	cd b7       	in	r28, 0x3d	; 61
    5e1e:	de b7       	in	r29, 0x3e	; 62
    5e20:	2e 97       	sbiw	r28, 0x0e	; 14
    5e22:	0f b6       	in	r0, 0x3f	; 63
    5e24:	f8 94       	cli
    5e26:	de bf       	out	0x3e, r29	; 62
    5e28:	0f be       	out	0x3f, r0	; 63
    5e2a:	cd bf       	out	0x3d, r28	; 61
    5e2c:	8a 83       	std	Y+2, r24	; 0x02
    5e2e:	4b 83       	std	Y+3, r20	; 0x03
    5e30:	5c 83       	std	Y+4, r21	; 0x04
    5e32:	6d 83       	std	Y+5, r22	; 0x05
    5e34:	7e 83       	std	Y+6, r23	; 0x06
    5e36:	0f 83       	std	Y+7, r16	; 0x07
    5e38:	18 87       	std	Y+8, r17	; 0x08
    5e3a:	29 87       	std	Y+9, r18	; 0x09
    5e3c:	3a 87       	std	Y+10, r19	; 0x0a
    5e3e:	fc 86       	std	Y+12, r15	; 0x0c
    5e40:	eb 86       	std	Y+11, r14	; 0x0b
    5e42:	de 86       	std	Y+14, r13	; 0x0e
    5e44:	cd 86       	std	Y+13, r12	; 0x0d
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    5e46:	0f b6       	in	r0, 0x3f	; 63
    5e48:	f8 94       	cli
    5e4a:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    5e4c:	20 91 46 07 	lds	r18, 0x0746
    5e50:	30 91 47 07 	lds	r19, 0x0747
    5e54:	8a 81       	ldd	r24, Y+2	; 0x02
    5e56:	88 2f       	mov	r24, r24
    5e58:	90 e0       	ldi	r25, 0x00	; 0
    5e5a:	82 0f       	add	r24, r18
    5e5c:	93 1f       	adc	r25, r19
    5e5e:	fc 01       	movw	r30, r24
    5e60:	b5 96       	adiw	r30, 0x25	; 37
    5e62:	80 81       	ld	r24, Z
    5e64:	82 30       	cpi	r24, 0x02	; 2
    5e66:	09 f4       	brne	.+2      	; 0x5e6a <xTaskGenericNotifyWait+0x5e>
    5e68:	47 c0       	rjmp	.+142    	; 0x5ef8 <xTaskGenericNotifyWait+0xec>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    5e6a:	60 91 46 07 	lds	r22, 0x0746
    5e6e:	70 91 47 07 	lds	r23, 0x0747
    5e72:	8a 81       	ldd	r24, Y+2	; 0x02
    5e74:	08 2f       	mov	r16, r24
    5e76:	10 e0       	ldi	r17, 0x00	; 0
    5e78:	8a 81       	ldd	r24, Y+2	; 0x02
    5e7a:	88 2f       	mov	r24, r24
    5e7c:	90 e0       	ldi	r25, 0x00	; 0
    5e7e:	88 0f       	add	r24, r24
    5e80:	99 1f       	adc	r25, r25
    5e82:	88 0f       	add	r24, r24
    5e84:	99 1f       	adc	r25, r25
    5e86:	86 0f       	add	r24, r22
    5e88:	97 1f       	adc	r25, r23
    5e8a:	fc 01       	movw	r30, r24
    5e8c:	b1 96       	adiw	r30, 0x21	; 33
    5e8e:	20 81       	ld	r18, Z
    5e90:	31 81       	ldd	r19, Z+1	; 0x01
    5e92:	42 81       	ldd	r20, Z+2	; 0x02
    5e94:	53 81       	ldd	r21, Z+3	; 0x03
    5e96:	8b 81       	ldd	r24, Y+3	; 0x03
    5e98:	9c 81       	ldd	r25, Y+4	; 0x04
    5e9a:	ad 81       	ldd	r26, Y+5	; 0x05
    5e9c:	be 81       	ldd	r27, Y+6	; 0x06
    5e9e:	80 95       	com	r24
    5ea0:	90 95       	com	r25
    5ea2:	a0 95       	com	r26
    5ea4:	b0 95       	com	r27
    5ea6:	28 23       	and	r18, r24
    5ea8:	39 23       	and	r19, r25
    5eaa:	4a 23       	and	r20, r26
    5eac:	5b 23       	and	r21, r27
    5eae:	c8 01       	movw	r24, r16
    5eb0:	88 0f       	add	r24, r24
    5eb2:	99 1f       	adc	r25, r25
    5eb4:	88 0f       	add	r24, r24
    5eb6:	99 1f       	adc	r25, r25
    5eb8:	86 0f       	add	r24, r22
    5eba:	97 1f       	adc	r25, r23
    5ebc:	fc 01       	movw	r30, r24
    5ebe:	b1 96       	adiw	r30, 0x21	; 33
    5ec0:	20 83       	st	Z, r18
    5ec2:	31 83       	std	Z+1, r19	; 0x01
    5ec4:	42 83       	std	Z+2, r20	; 0x02
    5ec6:	53 83       	std	Z+3, r21	; 0x03

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    5ec8:	20 91 46 07 	lds	r18, 0x0746
    5ecc:	30 91 47 07 	lds	r19, 0x0747
    5ed0:	8a 81       	ldd	r24, Y+2	; 0x02
    5ed2:	88 2f       	mov	r24, r24
    5ed4:	90 e0       	ldi	r25, 0x00	; 0
    5ed6:	82 0f       	add	r24, r18
    5ed8:	93 1f       	adc	r25, r19
    5eda:	fc 01       	movw	r30, r24
    5edc:	b5 96       	adiw	r30, 0x25	; 37
    5ede:	81 e0       	ldi	r24, 0x01	; 1
    5ee0:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    5ee2:	8d 85       	ldd	r24, Y+13	; 0x0d
    5ee4:	9e 85       	ldd	r25, Y+14	; 0x0e
    5ee6:	00 97       	sbiw	r24, 0x00	; 0
    5ee8:	39 f0       	breq	.+14     	; 0x5ef8 <xTaskGenericNotifyWait+0xec>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5eea:	8d 85       	ldd	r24, Y+13	; 0x0d
    5eec:	9e 85       	ldd	r25, Y+14	; 0x0e
    5eee:	61 e0       	ldi	r22, 0x01	; 1
    5ef0:	0e 94 d5 35 	call	0x6baa	; 0x6baa <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    5ef4:	0e 94 86 10 	call	0x210c	; 0x210c <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    5ef8:	0f 90       	pop	r0
    5efa:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    5efc:	0f b6       	in	r0, 0x3f	; 63
    5efe:	f8 94       	cli
    5f00:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    5f02:	8b 85       	ldd	r24, Y+11	; 0x0b
    5f04:	9c 85       	ldd	r25, Y+12	; 0x0c
    5f06:	00 97       	sbiw	r24, 0x00	; 0
    5f08:	c9 f0       	breq	.+50     	; 0x5f3c <xTaskGenericNotifyWait+0x130>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    5f0a:	20 91 46 07 	lds	r18, 0x0746
    5f0e:	30 91 47 07 	lds	r19, 0x0747
    5f12:	8a 81       	ldd	r24, Y+2	; 0x02
    5f14:	88 2f       	mov	r24, r24
    5f16:	90 e0       	ldi	r25, 0x00	; 0
    5f18:	88 0f       	add	r24, r24
    5f1a:	99 1f       	adc	r25, r25
    5f1c:	88 0f       	add	r24, r24
    5f1e:	99 1f       	adc	r25, r25
    5f20:	82 0f       	add	r24, r18
    5f22:	93 1f       	adc	r25, r19
    5f24:	fc 01       	movw	r30, r24
    5f26:	b1 96       	adiw	r30, 0x21	; 33
    5f28:	80 81       	ld	r24, Z
    5f2a:	91 81       	ldd	r25, Z+1	; 0x01
    5f2c:	a2 81       	ldd	r26, Z+2	; 0x02
    5f2e:	b3 81       	ldd	r27, Z+3	; 0x03
    5f30:	eb 85       	ldd	r30, Y+11	; 0x0b
    5f32:	fc 85       	ldd	r31, Y+12	; 0x0c
    5f34:	80 83       	st	Z, r24
    5f36:	91 83       	std	Z+1, r25	; 0x01
    5f38:	a2 83       	std	Z+2, r26	; 0x02
    5f3a:	b3 83       	std	Z+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    5f3c:	20 91 46 07 	lds	r18, 0x0746
    5f40:	30 91 47 07 	lds	r19, 0x0747
    5f44:	8a 81       	ldd	r24, Y+2	; 0x02
    5f46:	88 2f       	mov	r24, r24
    5f48:	90 e0       	ldi	r25, 0x00	; 0
    5f4a:	82 0f       	add	r24, r18
    5f4c:	93 1f       	adc	r25, r19
    5f4e:	fc 01       	movw	r30, r24
    5f50:	b5 96       	adiw	r30, 0x25	; 37
    5f52:	80 81       	ld	r24, Z
    5f54:	82 30       	cpi	r24, 0x02	; 2
    5f56:	11 f0       	breq	.+4      	; 0x5f5c <xTaskGenericNotifyWait+0x150>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    5f58:	19 82       	std	Y+1, r1	; 0x01
    5f5a:	31 c0       	rjmp	.+98     	; 0x5fbe <xTaskGenericNotifyWait+0x1b2>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    5f5c:	60 91 46 07 	lds	r22, 0x0746
    5f60:	70 91 47 07 	lds	r23, 0x0747
    5f64:	8a 81       	ldd	r24, Y+2	; 0x02
    5f66:	08 2f       	mov	r16, r24
    5f68:	10 e0       	ldi	r17, 0x00	; 0
    5f6a:	8a 81       	ldd	r24, Y+2	; 0x02
    5f6c:	88 2f       	mov	r24, r24
    5f6e:	90 e0       	ldi	r25, 0x00	; 0
    5f70:	88 0f       	add	r24, r24
    5f72:	99 1f       	adc	r25, r25
    5f74:	88 0f       	add	r24, r24
    5f76:	99 1f       	adc	r25, r25
    5f78:	86 0f       	add	r24, r22
    5f7a:	97 1f       	adc	r25, r23
    5f7c:	fc 01       	movw	r30, r24
    5f7e:	b1 96       	adiw	r30, 0x21	; 33
    5f80:	20 81       	ld	r18, Z
    5f82:	31 81       	ldd	r19, Z+1	; 0x01
    5f84:	42 81       	ldd	r20, Z+2	; 0x02
    5f86:	53 81       	ldd	r21, Z+3	; 0x03
    5f88:	8f 81       	ldd	r24, Y+7	; 0x07
    5f8a:	98 85       	ldd	r25, Y+8	; 0x08
    5f8c:	a9 85       	ldd	r26, Y+9	; 0x09
    5f8e:	ba 85       	ldd	r27, Y+10	; 0x0a
    5f90:	80 95       	com	r24
    5f92:	90 95       	com	r25
    5f94:	a0 95       	com	r26
    5f96:	b0 95       	com	r27
    5f98:	28 23       	and	r18, r24
    5f9a:	39 23       	and	r19, r25
    5f9c:	4a 23       	and	r20, r26
    5f9e:	5b 23       	and	r21, r27
    5fa0:	c8 01       	movw	r24, r16
    5fa2:	88 0f       	add	r24, r24
    5fa4:	99 1f       	adc	r25, r25
    5fa6:	88 0f       	add	r24, r24
    5fa8:	99 1f       	adc	r25, r25
    5faa:	86 0f       	add	r24, r22
    5fac:	97 1f       	adc	r25, r23
    5fae:	fc 01       	movw	r30, r24
    5fb0:	b1 96       	adiw	r30, 0x21	; 33
    5fb2:	20 83       	st	Z, r18
    5fb4:	31 83       	std	Z+1, r19	; 0x01
    5fb6:	42 83       	std	Z+2, r20	; 0x02
    5fb8:	53 83       	std	Z+3, r21	; 0x03
                xReturn = pdTRUE;
    5fba:	81 e0       	ldi	r24, 0x01	; 1
    5fbc:	89 83       	std	Y+1, r24	; 0x01
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    5fbe:	20 91 46 07 	lds	r18, 0x0746
    5fc2:	30 91 47 07 	lds	r19, 0x0747
    5fc6:	8a 81       	ldd	r24, Y+2	; 0x02
    5fc8:	88 2f       	mov	r24, r24
    5fca:	90 e0       	ldi	r25, 0x00	; 0
    5fcc:	82 0f       	add	r24, r18
    5fce:	93 1f       	adc	r25, r19
    5fd0:	fc 01       	movw	r30, r24
    5fd2:	b5 96       	adiw	r30, 0x25	; 37
    5fd4:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    5fd6:	0f 90       	pop	r0
    5fd8:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    5fda:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5fdc:	2e 96       	adiw	r28, 0x0e	; 14
    5fde:	0f b6       	in	r0, 0x3f	; 63
    5fe0:	f8 94       	cli
    5fe2:	de bf       	out	0x3e, r29	; 62
    5fe4:	0f be       	out	0x3f, r0	; 63
    5fe6:	cd bf       	out	0x3d, r28	; 61
    5fe8:	cf 91       	pop	r28
    5fea:	df 91       	pop	r29
    5fec:	1f 91       	pop	r17
    5fee:	0f 91       	pop	r16
    5ff0:	ff 90       	pop	r15
    5ff2:	ef 90       	pop	r14
    5ff4:	df 90       	pop	r13
    5ff6:	cf 90       	pop	r12
    5ff8:	08 95       	ret

00005ffa <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    5ffa:	ef 92       	push	r14
    5ffc:	ff 92       	push	r15
    5ffe:	0f 93       	push	r16
    6000:	1f 93       	push	r17
    6002:	df 93       	push	r29
    6004:	cf 93       	push	r28
    6006:	cd b7       	in	r28, 0x3d	; 61
    6008:	de b7       	in	r29, 0x3e	; 62
    600a:	64 97       	sbiw	r28, 0x14	; 20
    600c:	0f b6       	in	r0, 0x3f	; 63
    600e:	f8 94       	cli
    6010:	de bf       	out	0x3e, r29	; 62
    6012:	0f be       	out	0x3f, r0	; 63
    6014:	cd bf       	out	0x3d, r28	; 61
    6016:	9a 87       	std	Y+10, r25	; 0x0a
    6018:	89 87       	std	Y+9, r24	; 0x09
    601a:	6b 87       	std	Y+11, r22	; 0x0b
    601c:	2c 87       	std	Y+12, r18	; 0x0c
    601e:	3d 87       	std	Y+13, r19	; 0x0d
    6020:	4e 87       	std	Y+14, r20	; 0x0e
    6022:	5f 87       	std	Y+15, r21	; 0x0f
    6024:	08 8b       	std	Y+16, r16	; 0x10
    6026:	fa 8a       	std	Y+18, r15	; 0x12
    6028:	e9 8a       	std	Y+17, r14	; 0x11
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    602a:	81 e0       	ldi	r24, 0x01	; 1
    602c:	8e 83       	std	Y+6, r24	; 0x06
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
    602e:	89 85       	ldd	r24, Y+9	; 0x09
    6030:	9a 85       	ldd	r25, Y+10	; 0x0a
    6032:	98 87       	std	Y+8, r25	; 0x08
    6034:	8f 83       	std	Y+7, r24	; 0x07

        taskENTER_CRITICAL();
    6036:	0f b6       	in	r0, 0x3f	; 63
    6038:	f8 94       	cli
    603a:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    603c:	89 89       	ldd	r24, Y+17	; 0x11
    603e:	9a 89       	ldd	r25, Y+18	; 0x12
    6040:	00 97       	sbiw	r24, 0x00	; 0
    6042:	b9 f0       	breq	.+46     	; 0x6072 <xTaskGenericNotify+0x78>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    6044:	8b 85       	ldd	r24, Y+11	; 0x0b
    6046:	88 2f       	mov	r24, r24
    6048:	90 e0       	ldi	r25, 0x00	; 0
    604a:	2f 81       	ldd	r18, Y+7	; 0x07
    604c:	38 85       	ldd	r19, Y+8	; 0x08
    604e:	88 0f       	add	r24, r24
    6050:	99 1f       	adc	r25, r25
    6052:	88 0f       	add	r24, r24
    6054:	99 1f       	adc	r25, r25
    6056:	82 0f       	add	r24, r18
    6058:	93 1f       	adc	r25, r19
    605a:	fc 01       	movw	r30, r24
    605c:	b1 96       	adiw	r30, 0x21	; 33
    605e:	80 81       	ld	r24, Z
    6060:	91 81       	ldd	r25, Z+1	; 0x01
    6062:	a2 81       	ldd	r26, Z+2	; 0x02
    6064:	b3 81       	ldd	r27, Z+3	; 0x03
    6066:	e9 89       	ldd	r30, Y+17	; 0x11
    6068:	fa 89       	ldd	r31, Y+18	; 0x12
    606a:	80 83       	st	Z, r24
    606c:	91 83       	std	Z+1, r25	; 0x01
    606e:	a2 83       	std	Z+2, r26	; 0x02
    6070:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    6072:	8b 85       	ldd	r24, Y+11	; 0x0b
    6074:	28 2f       	mov	r18, r24
    6076:	30 e0       	ldi	r19, 0x00	; 0
    6078:	8f 81       	ldd	r24, Y+7	; 0x07
    607a:	98 85       	ldd	r25, Y+8	; 0x08
    607c:	82 0f       	add	r24, r18
    607e:	93 1f       	adc	r25, r19
    6080:	fc 01       	movw	r30, r24
    6082:	b5 96       	adiw	r30, 0x25	; 37
    6084:	80 81       	ld	r24, Z
    6086:	8d 83       	std	Y+5, r24	; 0x05

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    6088:	8b 85       	ldd	r24, Y+11	; 0x0b
    608a:	28 2f       	mov	r18, r24
    608c:	30 e0       	ldi	r19, 0x00	; 0
    608e:	8f 81       	ldd	r24, Y+7	; 0x07
    6090:	98 85       	ldd	r25, Y+8	; 0x08
    6092:	82 0f       	add	r24, r18
    6094:	93 1f       	adc	r25, r19
    6096:	fc 01       	movw	r30, r24
    6098:	b5 96       	adiw	r30, 0x25	; 37
    609a:	82 e0       	ldi	r24, 0x02	; 2
    609c:	80 83       	st	Z, r24

            switch( eAction )
    609e:	88 89       	ldd	r24, Y+16	; 0x10
    60a0:	28 2f       	mov	r18, r24
    60a2:	30 e0       	ldi	r19, 0x00	; 0
    60a4:	3c 8b       	std	Y+20, r19	; 0x14
    60a6:	2b 8b       	std	Y+19, r18	; 0x13
    60a8:	8b 89       	ldd	r24, Y+19	; 0x13
    60aa:	9c 89       	ldd	r25, Y+20	; 0x14
    60ac:	82 30       	cpi	r24, 0x02	; 2
    60ae:	91 05       	cpc	r25, r1
    60b0:	09 f4       	brne	.+2      	; 0x60b4 <xTaskGenericNotify+0xba>
    60b2:	46 c0       	rjmp	.+140    	; 0x6140 <xTaskGenericNotify+0x146>
    60b4:	2b 89       	ldd	r18, Y+19	; 0x13
    60b6:	3c 89       	ldd	r19, Y+20	; 0x14
    60b8:	23 30       	cpi	r18, 0x03	; 3
    60ba:	31 05       	cpc	r19, r1
    60bc:	34 f4       	brge	.+12     	; 0x60ca <xTaskGenericNotify+0xd0>
    60be:	8b 89       	ldd	r24, Y+19	; 0x13
    60c0:	9c 89       	ldd	r25, Y+20	; 0x14
    60c2:	81 30       	cpi	r24, 0x01	; 1
    60c4:	91 05       	cpc	r25, r1
    60c6:	71 f0       	breq	.+28     	; 0x60e4 <xTaskGenericNotify+0xea>
    60c8:	93 c0       	rjmp	.+294    	; 0x61f0 <xTaskGenericNotify+0x1f6>
    60ca:	2b 89       	ldd	r18, Y+19	; 0x13
    60cc:	3c 89       	ldd	r19, Y+20	; 0x14
    60ce:	23 30       	cpi	r18, 0x03	; 3
    60d0:	31 05       	cpc	r19, r1
    60d2:	09 f4       	brne	.+2      	; 0x60d6 <xTaskGenericNotify+0xdc>
    60d4:	5d c0       	rjmp	.+186    	; 0x6190 <xTaskGenericNotify+0x196>
    60d6:	8b 89       	ldd	r24, Y+19	; 0x13
    60d8:	9c 89       	ldd	r25, Y+20	; 0x14
    60da:	84 30       	cpi	r24, 0x04	; 4
    60dc:	91 05       	cpc	r25, r1
    60de:	09 f4       	brne	.+2      	; 0x60e2 <xTaskGenericNotify+0xe8>
    60e0:	6d c0       	rjmp	.+218    	; 0x61bc <xTaskGenericNotify+0x1c2>
    60e2:	86 c0       	rjmp	.+268    	; 0x61f0 <xTaskGenericNotify+0x1f6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    60e4:	8b 85       	ldd	r24, Y+11	; 0x0b
    60e6:	08 2f       	mov	r16, r24
    60e8:	10 e0       	ldi	r17, 0x00	; 0
    60ea:	8b 85       	ldd	r24, Y+11	; 0x0b
    60ec:	88 2f       	mov	r24, r24
    60ee:	90 e0       	ldi	r25, 0x00	; 0
    60f0:	2f 81       	ldd	r18, Y+7	; 0x07
    60f2:	38 85       	ldd	r19, Y+8	; 0x08
    60f4:	88 0f       	add	r24, r24
    60f6:	99 1f       	adc	r25, r25
    60f8:	88 0f       	add	r24, r24
    60fa:	99 1f       	adc	r25, r25
    60fc:	82 0f       	add	r24, r18
    60fe:	93 1f       	adc	r25, r19
    6100:	fc 01       	movw	r30, r24
    6102:	b1 96       	adiw	r30, 0x21	; 33
    6104:	20 81       	ld	r18, Z
    6106:	31 81       	ldd	r19, Z+1	; 0x01
    6108:	42 81       	ldd	r20, Z+2	; 0x02
    610a:	53 81       	ldd	r21, Z+3	; 0x03
    610c:	8c 85       	ldd	r24, Y+12	; 0x0c
    610e:	9d 85       	ldd	r25, Y+13	; 0x0d
    6110:	ae 85       	ldd	r26, Y+14	; 0x0e
    6112:	bf 85       	ldd	r27, Y+15	; 0x0f
    6114:	ba 01       	movw	r22, r20
    6116:	a9 01       	movw	r20, r18
    6118:	48 2b       	or	r20, r24
    611a:	59 2b       	or	r21, r25
    611c:	6a 2b       	or	r22, r26
    611e:	7b 2b       	or	r23, r27
    6120:	2f 81       	ldd	r18, Y+7	; 0x07
    6122:	38 85       	ldd	r19, Y+8	; 0x08
    6124:	c8 01       	movw	r24, r16
    6126:	88 0f       	add	r24, r24
    6128:	99 1f       	adc	r25, r25
    612a:	88 0f       	add	r24, r24
    612c:	99 1f       	adc	r25, r25
    612e:	82 0f       	add	r24, r18
    6130:	93 1f       	adc	r25, r19
    6132:	fc 01       	movw	r30, r24
    6134:	b1 96       	adiw	r30, 0x21	; 33
    6136:	40 83       	st	Z, r20
    6138:	51 83       	std	Z+1, r21	; 0x01
    613a:	62 83       	std	Z+2, r22	; 0x02
    613c:	73 83       	std	Z+3, r23	; 0x03
    613e:	58 c0       	rjmp	.+176    	; 0x61f0 <xTaskGenericNotify+0x1f6>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    6140:	8b 85       	ldd	r24, Y+11	; 0x0b
    6142:	08 2f       	mov	r16, r24
    6144:	10 e0       	ldi	r17, 0x00	; 0
    6146:	2f 81       	ldd	r18, Y+7	; 0x07
    6148:	38 85       	ldd	r19, Y+8	; 0x08
    614a:	c8 01       	movw	r24, r16
    614c:	88 0f       	add	r24, r24
    614e:	99 1f       	adc	r25, r25
    6150:	88 0f       	add	r24, r24
    6152:	99 1f       	adc	r25, r25
    6154:	82 0f       	add	r24, r18
    6156:	93 1f       	adc	r25, r19
    6158:	fc 01       	movw	r30, r24
    615a:	b1 96       	adiw	r30, 0x21	; 33
    615c:	80 81       	ld	r24, Z
    615e:	91 81       	ldd	r25, Z+1	; 0x01
    6160:	a2 81       	ldd	r26, Z+2	; 0x02
    6162:	b3 81       	ldd	r27, Z+3	; 0x03
    6164:	ac 01       	movw	r20, r24
    6166:	bd 01       	movw	r22, r26
    6168:	4f 5f       	subi	r20, 0xFF	; 255
    616a:	5f 4f       	sbci	r21, 0xFF	; 255
    616c:	6f 4f       	sbci	r22, 0xFF	; 255
    616e:	7f 4f       	sbci	r23, 0xFF	; 255
    6170:	2f 81       	ldd	r18, Y+7	; 0x07
    6172:	38 85       	ldd	r19, Y+8	; 0x08
    6174:	c8 01       	movw	r24, r16
    6176:	88 0f       	add	r24, r24
    6178:	99 1f       	adc	r25, r25
    617a:	88 0f       	add	r24, r24
    617c:	99 1f       	adc	r25, r25
    617e:	82 0f       	add	r24, r18
    6180:	93 1f       	adc	r25, r19
    6182:	fc 01       	movw	r30, r24
    6184:	b1 96       	adiw	r30, 0x21	; 33
    6186:	40 83       	st	Z, r20
    6188:	51 83       	std	Z+1, r21	; 0x01
    618a:	62 83       	std	Z+2, r22	; 0x02
    618c:	73 83       	std	Z+3, r23	; 0x03
    618e:	30 c0       	rjmp	.+96     	; 0x61f0 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    6190:	8b 85       	ldd	r24, Y+11	; 0x0b
    6192:	88 2f       	mov	r24, r24
    6194:	90 e0       	ldi	r25, 0x00	; 0
    6196:	2f 81       	ldd	r18, Y+7	; 0x07
    6198:	38 85       	ldd	r19, Y+8	; 0x08
    619a:	88 0f       	add	r24, r24
    619c:	99 1f       	adc	r25, r25
    619e:	88 0f       	add	r24, r24
    61a0:	99 1f       	adc	r25, r25
    61a2:	82 0f       	add	r24, r18
    61a4:	93 1f       	adc	r25, r19
    61a6:	fc 01       	movw	r30, r24
    61a8:	b1 96       	adiw	r30, 0x21	; 33
    61aa:	8c 85       	ldd	r24, Y+12	; 0x0c
    61ac:	9d 85       	ldd	r25, Y+13	; 0x0d
    61ae:	ae 85       	ldd	r26, Y+14	; 0x0e
    61b0:	bf 85       	ldd	r27, Y+15	; 0x0f
    61b2:	80 83       	st	Z, r24
    61b4:	91 83       	std	Z+1, r25	; 0x01
    61b6:	a2 83       	std	Z+2, r26	; 0x02
    61b8:	b3 83       	std	Z+3, r27	; 0x03
    61ba:	1a c0       	rjmp	.+52     	; 0x61f0 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    61bc:	8d 81       	ldd	r24, Y+5	; 0x05
    61be:	82 30       	cpi	r24, 0x02	; 2
    61c0:	b1 f0       	breq	.+44     	; 0x61ee <xTaskGenericNotify+0x1f4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    61c2:	8b 85       	ldd	r24, Y+11	; 0x0b
    61c4:	88 2f       	mov	r24, r24
    61c6:	90 e0       	ldi	r25, 0x00	; 0
    61c8:	2f 81       	ldd	r18, Y+7	; 0x07
    61ca:	38 85       	ldd	r19, Y+8	; 0x08
    61cc:	88 0f       	add	r24, r24
    61ce:	99 1f       	adc	r25, r25
    61d0:	88 0f       	add	r24, r24
    61d2:	99 1f       	adc	r25, r25
    61d4:	82 0f       	add	r24, r18
    61d6:	93 1f       	adc	r25, r19
    61d8:	fc 01       	movw	r30, r24
    61da:	b1 96       	adiw	r30, 0x21	; 33
    61dc:	8c 85       	ldd	r24, Y+12	; 0x0c
    61de:	9d 85       	ldd	r25, Y+13	; 0x0d
    61e0:	ae 85       	ldd	r26, Y+14	; 0x0e
    61e2:	bf 85       	ldd	r27, Y+15	; 0x0f
    61e4:	80 83       	st	Z, r24
    61e6:	91 83       	std	Z+1, r25	; 0x01
    61e8:	a2 83       	std	Z+2, r26	; 0x02
    61ea:	b3 83       	std	Z+3, r27	; 0x03
    61ec:	01 c0       	rjmp	.+2      	; 0x61f0 <xTaskGenericNotify+0x1f6>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    61ee:	1e 82       	std	Y+6, r1	; 0x06

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    61f0:	8d 81       	ldd	r24, Y+5	; 0x05
    61f2:	81 30       	cpi	r24, 0x01	; 1
    61f4:	09 f0       	breq	.+2      	; 0x61f8 <xTaskGenericNotify+0x1fe>
    61f6:	af c0       	rjmp	.+350    	; 0x6356 <xTaskGenericNotify+0x35c>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    61f8:	ef 81       	ldd	r30, Y+7	; 0x07
    61fa:	f8 85       	ldd	r31, Y+8	; 0x08
    61fc:	82 85       	ldd	r24, Z+10	; 0x0a
    61fe:	93 85       	ldd	r25, Z+11	; 0x0b
    6200:	9c 83       	std	Y+4, r25	; 0x04
    6202:	8b 83       	std	Y+3, r24	; 0x03
    6204:	ef 81       	ldd	r30, Y+7	; 0x07
    6206:	f8 85       	ldd	r31, Y+8	; 0x08
    6208:	a4 81       	ldd	r26, Z+4	; 0x04
    620a:	b5 81       	ldd	r27, Z+5	; 0x05
    620c:	ef 81       	ldd	r30, Y+7	; 0x07
    620e:	f8 85       	ldd	r31, Y+8	; 0x08
    6210:	86 81       	ldd	r24, Z+6	; 0x06
    6212:	97 81       	ldd	r25, Z+7	; 0x07
    6214:	15 96       	adiw	r26, 0x05	; 5
    6216:	9c 93       	st	X, r25
    6218:	8e 93       	st	-X, r24
    621a:	14 97       	sbiw	r26, 0x04	; 4
    621c:	ef 81       	ldd	r30, Y+7	; 0x07
    621e:	f8 85       	ldd	r31, Y+8	; 0x08
    6220:	a6 81       	ldd	r26, Z+6	; 0x06
    6222:	b7 81       	ldd	r27, Z+7	; 0x07
    6224:	ef 81       	ldd	r30, Y+7	; 0x07
    6226:	f8 85       	ldd	r31, Y+8	; 0x08
    6228:	84 81       	ldd	r24, Z+4	; 0x04
    622a:	95 81       	ldd	r25, Z+5	; 0x05
    622c:	13 96       	adiw	r26, 0x03	; 3
    622e:	9c 93       	st	X, r25
    6230:	8e 93       	st	-X, r24
    6232:	12 97       	sbiw	r26, 0x02	; 2
    6234:	eb 81       	ldd	r30, Y+3	; 0x03
    6236:	fc 81       	ldd	r31, Y+4	; 0x04
    6238:	21 81       	ldd	r18, Z+1	; 0x01
    623a:	32 81       	ldd	r19, Z+2	; 0x02
    623c:	8f 81       	ldd	r24, Y+7	; 0x07
    623e:	98 85       	ldd	r25, Y+8	; 0x08
    6240:	02 96       	adiw	r24, 0x02	; 2
    6242:	28 17       	cp	r18, r24
    6244:	39 07       	cpc	r19, r25
    6246:	41 f4       	brne	.+16     	; 0x6258 <xTaskGenericNotify+0x25e>
    6248:	ef 81       	ldd	r30, Y+7	; 0x07
    624a:	f8 85       	ldd	r31, Y+8	; 0x08
    624c:	86 81       	ldd	r24, Z+6	; 0x06
    624e:	97 81       	ldd	r25, Z+7	; 0x07
    6250:	eb 81       	ldd	r30, Y+3	; 0x03
    6252:	fc 81       	ldd	r31, Y+4	; 0x04
    6254:	92 83       	std	Z+2, r25	; 0x02
    6256:	81 83       	std	Z+1, r24	; 0x01
    6258:	ef 81       	ldd	r30, Y+7	; 0x07
    625a:	f8 85       	ldd	r31, Y+8	; 0x08
    625c:	13 86       	std	Z+11, r1	; 0x0b
    625e:	12 86       	std	Z+10, r1	; 0x0a
    6260:	eb 81       	ldd	r30, Y+3	; 0x03
    6262:	fc 81       	ldd	r31, Y+4	; 0x04
    6264:	80 81       	ld	r24, Z
    6266:	81 50       	subi	r24, 0x01	; 1
    6268:	eb 81       	ldd	r30, Y+3	; 0x03
    626a:	fc 81       	ldd	r31, Y+4	; 0x04
    626c:	80 83       	st	Z, r24
                prvAddTaskToReadyList( pxTCB );
    626e:	ef 81       	ldd	r30, Y+7	; 0x07
    6270:	f8 85       	ldd	r31, Y+8	; 0x08
    6272:	96 89       	ldd	r25, Z+22	; 0x16
    6274:	80 91 4c 07 	lds	r24, 0x074C
    6278:	89 17       	cp	r24, r25
    627a:	28 f4       	brcc	.+10     	; 0x6286 <xTaskGenericNotify+0x28c>
    627c:	ef 81       	ldd	r30, Y+7	; 0x07
    627e:	f8 85       	ldd	r31, Y+8	; 0x08
    6280:	86 89       	ldd	r24, Z+22	; 0x16
    6282:	80 93 4c 07 	sts	0x074C, r24
    6286:	ef 81       	ldd	r30, Y+7	; 0x07
    6288:	f8 85       	ldd	r31, Y+8	; 0x08
    628a:	86 89       	ldd	r24, Z+22	; 0x16
    628c:	28 2f       	mov	r18, r24
    628e:	30 e0       	ldi	r19, 0x00	; 0
    6290:	c9 01       	movw	r24, r18
    6292:	88 0f       	add	r24, r24
    6294:	99 1f       	adc	r25, r25
    6296:	88 0f       	add	r24, r24
    6298:	99 1f       	adc	r25, r25
    629a:	88 0f       	add	r24, r24
    629c:	99 1f       	adc	r25, r25
    629e:	82 0f       	add	r24, r18
    62a0:	93 1f       	adc	r25, r19
    62a2:	fc 01       	movw	r30, r24
    62a4:	e8 5a       	subi	r30, 0xA8	; 168
    62a6:	f8 4f       	sbci	r31, 0xF8	; 248
    62a8:	81 81       	ldd	r24, Z+1	; 0x01
    62aa:	92 81       	ldd	r25, Z+2	; 0x02
    62ac:	9a 83       	std	Y+2, r25	; 0x02
    62ae:	89 83       	std	Y+1, r24	; 0x01
    62b0:	ef 81       	ldd	r30, Y+7	; 0x07
    62b2:	f8 85       	ldd	r31, Y+8	; 0x08
    62b4:	89 81       	ldd	r24, Y+1	; 0x01
    62b6:	9a 81       	ldd	r25, Y+2	; 0x02
    62b8:	95 83       	std	Z+5, r25	; 0x05
    62ba:	84 83       	std	Z+4, r24	; 0x04
    62bc:	e9 81       	ldd	r30, Y+1	; 0x01
    62be:	fa 81       	ldd	r31, Y+2	; 0x02
    62c0:	84 81       	ldd	r24, Z+4	; 0x04
    62c2:	95 81       	ldd	r25, Z+5	; 0x05
    62c4:	ef 81       	ldd	r30, Y+7	; 0x07
    62c6:	f8 85       	ldd	r31, Y+8	; 0x08
    62c8:	97 83       	std	Z+7, r25	; 0x07
    62ca:	86 83       	std	Z+6, r24	; 0x06
    62cc:	e9 81       	ldd	r30, Y+1	; 0x01
    62ce:	fa 81       	ldd	r31, Y+2	; 0x02
    62d0:	04 80       	ldd	r0, Z+4	; 0x04
    62d2:	f5 81       	ldd	r31, Z+5	; 0x05
    62d4:	e0 2d       	mov	r30, r0
    62d6:	8f 81       	ldd	r24, Y+7	; 0x07
    62d8:	98 85       	ldd	r25, Y+8	; 0x08
    62da:	02 96       	adiw	r24, 0x02	; 2
    62dc:	93 83       	std	Z+3, r25	; 0x03
    62de:	82 83       	std	Z+2, r24	; 0x02
    62e0:	8f 81       	ldd	r24, Y+7	; 0x07
    62e2:	98 85       	ldd	r25, Y+8	; 0x08
    62e4:	02 96       	adiw	r24, 0x02	; 2
    62e6:	e9 81       	ldd	r30, Y+1	; 0x01
    62e8:	fa 81       	ldd	r31, Y+2	; 0x02
    62ea:	95 83       	std	Z+5, r25	; 0x05
    62ec:	84 83       	std	Z+4, r24	; 0x04
    62ee:	ef 81       	ldd	r30, Y+7	; 0x07
    62f0:	f8 85       	ldd	r31, Y+8	; 0x08
    62f2:	86 89       	ldd	r24, Z+22	; 0x16
    62f4:	28 2f       	mov	r18, r24
    62f6:	30 e0       	ldi	r19, 0x00	; 0
    62f8:	c9 01       	movw	r24, r18
    62fa:	88 0f       	add	r24, r24
    62fc:	99 1f       	adc	r25, r25
    62fe:	88 0f       	add	r24, r24
    6300:	99 1f       	adc	r25, r25
    6302:	88 0f       	add	r24, r24
    6304:	99 1f       	adc	r25, r25
    6306:	82 0f       	add	r24, r18
    6308:	93 1f       	adc	r25, r19
    630a:	88 5a       	subi	r24, 0xA8	; 168
    630c:	98 4f       	sbci	r25, 0xF8	; 248
    630e:	ef 81       	ldd	r30, Y+7	; 0x07
    6310:	f8 85       	ldd	r31, Y+8	; 0x08
    6312:	93 87       	std	Z+11, r25	; 0x0b
    6314:	82 87       	std	Z+10, r24	; 0x0a
    6316:	ef 81       	ldd	r30, Y+7	; 0x07
    6318:	f8 85       	ldd	r31, Y+8	; 0x08
    631a:	86 89       	ldd	r24, Z+22	; 0x16
    631c:	28 2f       	mov	r18, r24
    631e:	30 e0       	ldi	r19, 0x00	; 0
    6320:	c9 01       	movw	r24, r18
    6322:	88 0f       	add	r24, r24
    6324:	99 1f       	adc	r25, r25
    6326:	88 0f       	add	r24, r24
    6328:	99 1f       	adc	r25, r25
    632a:	88 0f       	add	r24, r24
    632c:	99 1f       	adc	r25, r25
    632e:	82 0f       	add	r24, r18
    6330:	93 1f       	adc	r25, r19
    6332:	fc 01       	movw	r30, r24
    6334:	e8 5a       	subi	r30, 0xA8	; 168
    6336:	f8 4f       	sbci	r31, 0xF8	; 248
    6338:	80 81       	ld	r24, Z
    633a:	8f 5f       	subi	r24, 0xFF	; 255
    633c:	80 83       	st	Z, r24
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    633e:	ef 81       	ldd	r30, Y+7	; 0x07
    6340:	f8 85       	ldd	r31, Y+8	; 0x08
    6342:	96 89       	ldd	r25, Z+22	; 0x16
    6344:	e0 91 46 07 	lds	r30, 0x0746
    6348:	f0 91 47 07 	lds	r31, 0x0747
    634c:	86 89       	ldd	r24, Z+22	; 0x16
    634e:	89 17       	cp	r24, r25
    6350:	10 f4       	brcc	.+4      	; 0x6356 <xTaskGenericNotify+0x35c>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    6352:	0e 94 86 10 	call	0x210c	; 0x210c <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    6356:	0f 90       	pop	r0
    6358:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    635a:	8e 81       	ldd	r24, Y+6	; 0x06
    }
    635c:	64 96       	adiw	r28, 0x14	; 20
    635e:	0f b6       	in	r0, 0x3f	; 63
    6360:	f8 94       	cli
    6362:	de bf       	out	0x3e, r29	; 62
    6364:	0f be       	out	0x3f, r0	; 63
    6366:	cd bf       	out	0x3d, r28	; 61
    6368:	cf 91       	pop	r28
    636a:	df 91       	pop	r29
    636c:	1f 91       	pop	r17
    636e:	0f 91       	pop	r16
    6370:	ff 90       	pop	r15
    6372:	ef 90       	pop	r14
    6374:	08 95       	ret

00006376 <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    6376:	cf 92       	push	r12
    6378:	df 92       	push	r13
    637a:	ef 92       	push	r14
    637c:	ff 92       	push	r15
    637e:	0f 93       	push	r16
    6380:	1f 93       	push	r17
    6382:	df 93       	push	r29
    6384:	cf 93       	push	r28
    6386:	cd b7       	in	r28, 0x3d	; 61
    6388:	de b7       	in	r29, 0x3e	; 62
    638a:	69 97       	sbiw	r28, 0x19	; 25
    638c:	0f b6       	in	r0, 0x3f	; 63
    638e:	f8 94       	cli
    6390:	de bf       	out	0x3e, r29	; 62
    6392:	0f be       	out	0x3f, r0	; 63
    6394:	cd bf       	out	0x3d, r28	; 61
    6396:	9d 87       	std	Y+13, r25	; 0x0d
    6398:	8c 87       	std	Y+12, r24	; 0x0c
    639a:	6e 87       	std	Y+14, r22	; 0x0e
    639c:	2f 87       	std	Y+15, r18	; 0x0f
    639e:	38 8b       	std	Y+16, r19	; 0x10
    63a0:	49 8b       	std	Y+17, r20	; 0x11
    63a2:	5a 8b       	std	Y+18, r21	; 0x12
    63a4:	0b 8b       	std	Y+19, r16	; 0x13
    63a6:	fd 8a       	std	Y+21, r15	; 0x15
    63a8:	ec 8a       	std	Y+20, r14	; 0x14
    63aa:	df 8a       	std	Y+23, r13	; 0x17
    63ac:	ce 8a       	std	Y+22, r12	; 0x16
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    63ae:	81 e0       	ldi	r24, 0x01	; 1
    63b0:	88 87       	std	Y+8, r24	; 0x08
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    63b2:	8c 85       	ldd	r24, Y+12	; 0x0c
    63b4:	9d 85       	ldd	r25, Y+13	; 0x0d
    63b6:	9b 87       	std	Y+11, r25	; 0x0b
    63b8:	8a 87       	std	Y+10, r24	; 0x0a

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    63ba:	1f 82       	std	Y+7, r1	; 0x07
        {
            if( pulPreviousNotificationValue != NULL )
    63bc:	8c 89       	ldd	r24, Y+20	; 0x14
    63be:	9d 89       	ldd	r25, Y+21	; 0x15
    63c0:	00 97       	sbiw	r24, 0x00	; 0
    63c2:	b9 f0       	breq	.+46     	; 0x63f2 <xTaskGenericNotifyFromISR+0x7c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    63c4:	8e 85       	ldd	r24, Y+14	; 0x0e
    63c6:	88 2f       	mov	r24, r24
    63c8:	90 e0       	ldi	r25, 0x00	; 0
    63ca:	2a 85       	ldd	r18, Y+10	; 0x0a
    63cc:	3b 85       	ldd	r19, Y+11	; 0x0b
    63ce:	88 0f       	add	r24, r24
    63d0:	99 1f       	adc	r25, r25
    63d2:	88 0f       	add	r24, r24
    63d4:	99 1f       	adc	r25, r25
    63d6:	82 0f       	add	r24, r18
    63d8:	93 1f       	adc	r25, r19
    63da:	fc 01       	movw	r30, r24
    63dc:	b1 96       	adiw	r30, 0x21	; 33
    63de:	80 81       	ld	r24, Z
    63e0:	91 81       	ldd	r25, Z+1	; 0x01
    63e2:	a2 81       	ldd	r26, Z+2	; 0x02
    63e4:	b3 81       	ldd	r27, Z+3	; 0x03
    63e6:	ec 89       	ldd	r30, Y+20	; 0x14
    63e8:	fd 89       	ldd	r31, Y+21	; 0x15
    63ea:	80 83       	st	Z, r24
    63ec:	91 83       	std	Z+1, r25	; 0x01
    63ee:	a2 83       	std	Z+2, r26	; 0x02
    63f0:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    63f2:	8e 85       	ldd	r24, Y+14	; 0x0e
    63f4:	28 2f       	mov	r18, r24
    63f6:	30 e0       	ldi	r19, 0x00	; 0
    63f8:	8a 85       	ldd	r24, Y+10	; 0x0a
    63fa:	9b 85       	ldd	r25, Y+11	; 0x0b
    63fc:	82 0f       	add	r24, r18
    63fe:	93 1f       	adc	r25, r19
    6400:	fc 01       	movw	r30, r24
    6402:	b5 96       	adiw	r30, 0x25	; 37
    6404:	80 81       	ld	r24, Z
    6406:	89 87       	std	Y+9, r24	; 0x09
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    6408:	8e 85       	ldd	r24, Y+14	; 0x0e
    640a:	28 2f       	mov	r18, r24
    640c:	30 e0       	ldi	r19, 0x00	; 0
    640e:	8a 85       	ldd	r24, Y+10	; 0x0a
    6410:	9b 85       	ldd	r25, Y+11	; 0x0b
    6412:	82 0f       	add	r24, r18
    6414:	93 1f       	adc	r25, r19
    6416:	fc 01       	movw	r30, r24
    6418:	b5 96       	adiw	r30, 0x25	; 37
    641a:	82 e0       	ldi	r24, 0x02	; 2
    641c:	80 83       	st	Z, r24

            switch( eAction )
    641e:	8b 89       	ldd	r24, Y+19	; 0x13
    6420:	28 2f       	mov	r18, r24
    6422:	30 e0       	ldi	r19, 0x00	; 0
    6424:	39 8f       	std	Y+25, r19	; 0x19
    6426:	28 8f       	std	Y+24, r18	; 0x18
    6428:	88 8d       	ldd	r24, Y+24	; 0x18
    642a:	99 8d       	ldd	r25, Y+25	; 0x19
    642c:	82 30       	cpi	r24, 0x02	; 2
    642e:	91 05       	cpc	r25, r1
    6430:	09 f4       	brne	.+2      	; 0x6434 <xTaskGenericNotifyFromISR+0xbe>
    6432:	46 c0       	rjmp	.+140    	; 0x64c0 <xTaskGenericNotifyFromISR+0x14a>
    6434:	28 8d       	ldd	r18, Y+24	; 0x18
    6436:	39 8d       	ldd	r19, Y+25	; 0x19
    6438:	23 30       	cpi	r18, 0x03	; 3
    643a:	31 05       	cpc	r19, r1
    643c:	34 f4       	brge	.+12     	; 0x644a <xTaskGenericNotifyFromISR+0xd4>
    643e:	88 8d       	ldd	r24, Y+24	; 0x18
    6440:	99 8d       	ldd	r25, Y+25	; 0x19
    6442:	81 30       	cpi	r24, 0x01	; 1
    6444:	91 05       	cpc	r25, r1
    6446:	71 f0       	breq	.+28     	; 0x6464 <xTaskGenericNotifyFromISR+0xee>
    6448:	93 c0       	rjmp	.+294    	; 0x6570 <xTaskGenericNotifyFromISR+0x1fa>
    644a:	28 8d       	ldd	r18, Y+24	; 0x18
    644c:	39 8d       	ldd	r19, Y+25	; 0x19
    644e:	23 30       	cpi	r18, 0x03	; 3
    6450:	31 05       	cpc	r19, r1
    6452:	09 f4       	brne	.+2      	; 0x6456 <xTaskGenericNotifyFromISR+0xe0>
    6454:	5d c0       	rjmp	.+186    	; 0x6510 <xTaskGenericNotifyFromISR+0x19a>
    6456:	88 8d       	ldd	r24, Y+24	; 0x18
    6458:	99 8d       	ldd	r25, Y+25	; 0x19
    645a:	84 30       	cpi	r24, 0x04	; 4
    645c:	91 05       	cpc	r25, r1
    645e:	09 f4       	brne	.+2      	; 0x6462 <xTaskGenericNotifyFromISR+0xec>
    6460:	6d c0       	rjmp	.+218    	; 0x653c <xTaskGenericNotifyFromISR+0x1c6>
    6462:	86 c0       	rjmp	.+268    	; 0x6570 <xTaskGenericNotifyFromISR+0x1fa>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    6464:	8e 85       	ldd	r24, Y+14	; 0x0e
    6466:	08 2f       	mov	r16, r24
    6468:	10 e0       	ldi	r17, 0x00	; 0
    646a:	8e 85       	ldd	r24, Y+14	; 0x0e
    646c:	88 2f       	mov	r24, r24
    646e:	90 e0       	ldi	r25, 0x00	; 0
    6470:	2a 85       	ldd	r18, Y+10	; 0x0a
    6472:	3b 85       	ldd	r19, Y+11	; 0x0b
    6474:	88 0f       	add	r24, r24
    6476:	99 1f       	adc	r25, r25
    6478:	88 0f       	add	r24, r24
    647a:	99 1f       	adc	r25, r25
    647c:	82 0f       	add	r24, r18
    647e:	93 1f       	adc	r25, r19
    6480:	fc 01       	movw	r30, r24
    6482:	b1 96       	adiw	r30, 0x21	; 33
    6484:	20 81       	ld	r18, Z
    6486:	31 81       	ldd	r19, Z+1	; 0x01
    6488:	42 81       	ldd	r20, Z+2	; 0x02
    648a:	53 81       	ldd	r21, Z+3	; 0x03
    648c:	8f 85       	ldd	r24, Y+15	; 0x0f
    648e:	98 89       	ldd	r25, Y+16	; 0x10
    6490:	a9 89       	ldd	r26, Y+17	; 0x11
    6492:	ba 89       	ldd	r27, Y+18	; 0x12
    6494:	ba 01       	movw	r22, r20
    6496:	a9 01       	movw	r20, r18
    6498:	48 2b       	or	r20, r24
    649a:	59 2b       	or	r21, r25
    649c:	6a 2b       	or	r22, r26
    649e:	7b 2b       	or	r23, r27
    64a0:	2a 85       	ldd	r18, Y+10	; 0x0a
    64a2:	3b 85       	ldd	r19, Y+11	; 0x0b
    64a4:	c8 01       	movw	r24, r16
    64a6:	88 0f       	add	r24, r24
    64a8:	99 1f       	adc	r25, r25
    64aa:	88 0f       	add	r24, r24
    64ac:	99 1f       	adc	r25, r25
    64ae:	82 0f       	add	r24, r18
    64b0:	93 1f       	adc	r25, r19
    64b2:	fc 01       	movw	r30, r24
    64b4:	b1 96       	adiw	r30, 0x21	; 33
    64b6:	40 83       	st	Z, r20
    64b8:	51 83       	std	Z+1, r21	; 0x01
    64ba:	62 83       	std	Z+2, r22	; 0x02
    64bc:	73 83       	std	Z+3, r23	; 0x03
    64be:	58 c0       	rjmp	.+176    	; 0x6570 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    64c0:	8e 85       	ldd	r24, Y+14	; 0x0e
    64c2:	08 2f       	mov	r16, r24
    64c4:	10 e0       	ldi	r17, 0x00	; 0
    64c6:	2a 85       	ldd	r18, Y+10	; 0x0a
    64c8:	3b 85       	ldd	r19, Y+11	; 0x0b
    64ca:	c8 01       	movw	r24, r16
    64cc:	88 0f       	add	r24, r24
    64ce:	99 1f       	adc	r25, r25
    64d0:	88 0f       	add	r24, r24
    64d2:	99 1f       	adc	r25, r25
    64d4:	82 0f       	add	r24, r18
    64d6:	93 1f       	adc	r25, r19
    64d8:	fc 01       	movw	r30, r24
    64da:	b1 96       	adiw	r30, 0x21	; 33
    64dc:	80 81       	ld	r24, Z
    64de:	91 81       	ldd	r25, Z+1	; 0x01
    64e0:	a2 81       	ldd	r26, Z+2	; 0x02
    64e2:	b3 81       	ldd	r27, Z+3	; 0x03
    64e4:	ac 01       	movw	r20, r24
    64e6:	bd 01       	movw	r22, r26
    64e8:	4f 5f       	subi	r20, 0xFF	; 255
    64ea:	5f 4f       	sbci	r21, 0xFF	; 255
    64ec:	6f 4f       	sbci	r22, 0xFF	; 255
    64ee:	7f 4f       	sbci	r23, 0xFF	; 255
    64f0:	2a 85       	ldd	r18, Y+10	; 0x0a
    64f2:	3b 85       	ldd	r19, Y+11	; 0x0b
    64f4:	c8 01       	movw	r24, r16
    64f6:	88 0f       	add	r24, r24
    64f8:	99 1f       	adc	r25, r25
    64fa:	88 0f       	add	r24, r24
    64fc:	99 1f       	adc	r25, r25
    64fe:	82 0f       	add	r24, r18
    6500:	93 1f       	adc	r25, r19
    6502:	fc 01       	movw	r30, r24
    6504:	b1 96       	adiw	r30, 0x21	; 33
    6506:	40 83       	st	Z, r20
    6508:	51 83       	std	Z+1, r21	; 0x01
    650a:	62 83       	std	Z+2, r22	; 0x02
    650c:	73 83       	std	Z+3, r23	; 0x03
    650e:	30 c0       	rjmp	.+96     	; 0x6570 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    6510:	8e 85       	ldd	r24, Y+14	; 0x0e
    6512:	88 2f       	mov	r24, r24
    6514:	90 e0       	ldi	r25, 0x00	; 0
    6516:	2a 85       	ldd	r18, Y+10	; 0x0a
    6518:	3b 85       	ldd	r19, Y+11	; 0x0b
    651a:	88 0f       	add	r24, r24
    651c:	99 1f       	adc	r25, r25
    651e:	88 0f       	add	r24, r24
    6520:	99 1f       	adc	r25, r25
    6522:	82 0f       	add	r24, r18
    6524:	93 1f       	adc	r25, r19
    6526:	fc 01       	movw	r30, r24
    6528:	b1 96       	adiw	r30, 0x21	; 33
    652a:	8f 85       	ldd	r24, Y+15	; 0x0f
    652c:	98 89       	ldd	r25, Y+16	; 0x10
    652e:	a9 89       	ldd	r26, Y+17	; 0x11
    6530:	ba 89       	ldd	r27, Y+18	; 0x12
    6532:	80 83       	st	Z, r24
    6534:	91 83       	std	Z+1, r25	; 0x01
    6536:	a2 83       	std	Z+2, r26	; 0x02
    6538:	b3 83       	std	Z+3, r27	; 0x03
    653a:	1a c0       	rjmp	.+52     	; 0x6570 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    653c:	89 85       	ldd	r24, Y+9	; 0x09
    653e:	82 30       	cpi	r24, 0x02	; 2
    6540:	b1 f0       	breq	.+44     	; 0x656e <xTaskGenericNotifyFromISR+0x1f8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    6542:	8e 85       	ldd	r24, Y+14	; 0x0e
    6544:	88 2f       	mov	r24, r24
    6546:	90 e0       	ldi	r25, 0x00	; 0
    6548:	2a 85       	ldd	r18, Y+10	; 0x0a
    654a:	3b 85       	ldd	r19, Y+11	; 0x0b
    654c:	88 0f       	add	r24, r24
    654e:	99 1f       	adc	r25, r25
    6550:	88 0f       	add	r24, r24
    6552:	99 1f       	adc	r25, r25
    6554:	82 0f       	add	r24, r18
    6556:	93 1f       	adc	r25, r19
    6558:	fc 01       	movw	r30, r24
    655a:	b1 96       	adiw	r30, 0x21	; 33
    655c:	8f 85       	ldd	r24, Y+15	; 0x0f
    655e:	98 89       	ldd	r25, Y+16	; 0x10
    6560:	a9 89       	ldd	r26, Y+17	; 0x11
    6562:	ba 89       	ldd	r27, Y+18	; 0x12
    6564:	80 83       	st	Z, r24
    6566:	91 83       	std	Z+1, r25	; 0x01
    6568:	a2 83       	std	Z+2, r26	; 0x02
    656a:	b3 83       	std	Z+3, r27	; 0x03
    656c:	01 c0       	rjmp	.+2      	; 0x6570 <xTaskGenericNotifyFromISR+0x1fa>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    656e:	18 86       	std	Y+8, r1	; 0x08

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    6570:	89 85       	ldd	r24, Y+9	; 0x09
    6572:	81 30       	cpi	r24, 0x01	; 1
    6574:	09 f0       	breq	.+2      	; 0x6578 <xTaskGenericNotifyFromISR+0x202>
    6576:	ee c0       	rjmp	.+476    	; 0x6754 <xTaskGenericNotifyFromISR+0x3de>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    6578:	80 91 57 07 	lds	r24, 0x0757
    657c:	88 23       	and	r24, r24
    657e:	09 f0       	breq	.+2      	; 0x6582 <xTaskGenericNotifyFromISR+0x20c>
    6580:	a4 c0       	rjmp	.+328    	; 0x66ca <xTaskGenericNotifyFromISR+0x354>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    6582:	ea 85       	ldd	r30, Y+10	; 0x0a
    6584:	fb 85       	ldd	r31, Y+11	; 0x0b
    6586:	82 85       	ldd	r24, Z+10	; 0x0a
    6588:	93 85       	ldd	r25, Z+11	; 0x0b
    658a:	9e 83       	std	Y+6, r25	; 0x06
    658c:	8d 83       	std	Y+5, r24	; 0x05
    658e:	ea 85       	ldd	r30, Y+10	; 0x0a
    6590:	fb 85       	ldd	r31, Y+11	; 0x0b
    6592:	a4 81       	ldd	r26, Z+4	; 0x04
    6594:	b5 81       	ldd	r27, Z+5	; 0x05
    6596:	ea 85       	ldd	r30, Y+10	; 0x0a
    6598:	fb 85       	ldd	r31, Y+11	; 0x0b
    659a:	86 81       	ldd	r24, Z+6	; 0x06
    659c:	97 81       	ldd	r25, Z+7	; 0x07
    659e:	15 96       	adiw	r26, 0x05	; 5
    65a0:	9c 93       	st	X, r25
    65a2:	8e 93       	st	-X, r24
    65a4:	14 97       	sbiw	r26, 0x04	; 4
    65a6:	ea 85       	ldd	r30, Y+10	; 0x0a
    65a8:	fb 85       	ldd	r31, Y+11	; 0x0b
    65aa:	a6 81       	ldd	r26, Z+6	; 0x06
    65ac:	b7 81       	ldd	r27, Z+7	; 0x07
    65ae:	ea 85       	ldd	r30, Y+10	; 0x0a
    65b0:	fb 85       	ldd	r31, Y+11	; 0x0b
    65b2:	84 81       	ldd	r24, Z+4	; 0x04
    65b4:	95 81       	ldd	r25, Z+5	; 0x05
    65b6:	13 96       	adiw	r26, 0x03	; 3
    65b8:	9c 93       	st	X, r25
    65ba:	8e 93       	st	-X, r24
    65bc:	12 97       	sbiw	r26, 0x02	; 2
    65be:	ed 81       	ldd	r30, Y+5	; 0x05
    65c0:	fe 81       	ldd	r31, Y+6	; 0x06
    65c2:	21 81       	ldd	r18, Z+1	; 0x01
    65c4:	32 81       	ldd	r19, Z+2	; 0x02
    65c6:	8a 85       	ldd	r24, Y+10	; 0x0a
    65c8:	9b 85       	ldd	r25, Y+11	; 0x0b
    65ca:	02 96       	adiw	r24, 0x02	; 2
    65cc:	28 17       	cp	r18, r24
    65ce:	39 07       	cpc	r19, r25
    65d0:	41 f4       	brne	.+16     	; 0x65e2 <xTaskGenericNotifyFromISR+0x26c>
    65d2:	ea 85       	ldd	r30, Y+10	; 0x0a
    65d4:	fb 85       	ldd	r31, Y+11	; 0x0b
    65d6:	86 81       	ldd	r24, Z+6	; 0x06
    65d8:	97 81       	ldd	r25, Z+7	; 0x07
    65da:	ed 81       	ldd	r30, Y+5	; 0x05
    65dc:	fe 81       	ldd	r31, Y+6	; 0x06
    65de:	92 83       	std	Z+2, r25	; 0x02
    65e0:	81 83       	std	Z+1, r24	; 0x01
    65e2:	ea 85       	ldd	r30, Y+10	; 0x0a
    65e4:	fb 85       	ldd	r31, Y+11	; 0x0b
    65e6:	13 86       	std	Z+11, r1	; 0x0b
    65e8:	12 86       	std	Z+10, r1	; 0x0a
    65ea:	ed 81       	ldd	r30, Y+5	; 0x05
    65ec:	fe 81       	ldd	r31, Y+6	; 0x06
    65ee:	80 81       	ld	r24, Z
    65f0:	81 50       	subi	r24, 0x01	; 1
    65f2:	ed 81       	ldd	r30, Y+5	; 0x05
    65f4:	fe 81       	ldd	r31, Y+6	; 0x06
    65f6:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    65f8:	ea 85       	ldd	r30, Y+10	; 0x0a
    65fa:	fb 85       	ldd	r31, Y+11	; 0x0b
    65fc:	96 89       	ldd	r25, Z+22	; 0x16
    65fe:	80 91 4c 07 	lds	r24, 0x074C
    6602:	89 17       	cp	r24, r25
    6604:	28 f4       	brcc	.+10     	; 0x6610 <xTaskGenericNotifyFromISR+0x29a>
    6606:	ea 85       	ldd	r30, Y+10	; 0x0a
    6608:	fb 85       	ldd	r31, Y+11	; 0x0b
    660a:	86 89       	ldd	r24, Z+22	; 0x16
    660c:	80 93 4c 07 	sts	0x074C, r24
    6610:	ea 85       	ldd	r30, Y+10	; 0x0a
    6612:	fb 85       	ldd	r31, Y+11	; 0x0b
    6614:	86 89       	ldd	r24, Z+22	; 0x16
    6616:	28 2f       	mov	r18, r24
    6618:	30 e0       	ldi	r19, 0x00	; 0
    661a:	c9 01       	movw	r24, r18
    661c:	88 0f       	add	r24, r24
    661e:	99 1f       	adc	r25, r25
    6620:	88 0f       	add	r24, r24
    6622:	99 1f       	adc	r25, r25
    6624:	88 0f       	add	r24, r24
    6626:	99 1f       	adc	r25, r25
    6628:	82 0f       	add	r24, r18
    662a:	93 1f       	adc	r25, r19
    662c:	fc 01       	movw	r30, r24
    662e:	e8 5a       	subi	r30, 0xA8	; 168
    6630:	f8 4f       	sbci	r31, 0xF8	; 248
    6632:	81 81       	ldd	r24, Z+1	; 0x01
    6634:	92 81       	ldd	r25, Z+2	; 0x02
    6636:	9c 83       	std	Y+4, r25	; 0x04
    6638:	8b 83       	std	Y+3, r24	; 0x03
    663a:	ea 85       	ldd	r30, Y+10	; 0x0a
    663c:	fb 85       	ldd	r31, Y+11	; 0x0b
    663e:	8b 81       	ldd	r24, Y+3	; 0x03
    6640:	9c 81       	ldd	r25, Y+4	; 0x04
    6642:	95 83       	std	Z+5, r25	; 0x05
    6644:	84 83       	std	Z+4, r24	; 0x04
    6646:	eb 81       	ldd	r30, Y+3	; 0x03
    6648:	fc 81       	ldd	r31, Y+4	; 0x04
    664a:	84 81       	ldd	r24, Z+4	; 0x04
    664c:	95 81       	ldd	r25, Z+5	; 0x05
    664e:	ea 85       	ldd	r30, Y+10	; 0x0a
    6650:	fb 85       	ldd	r31, Y+11	; 0x0b
    6652:	97 83       	std	Z+7, r25	; 0x07
    6654:	86 83       	std	Z+6, r24	; 0x06
    6656:	eb 81       	ldd	r30, Y+3	; 0x03
    6658:	fc 81       	ldd	r31, Y+4	; 0x04
    665a:	04 80       	ldd	r0, Z+4	; 0x04
    665c:	f5 81       	ldd	r31, Z+5	; 0x05
    665e:	e0 2d       	mov	r30, r0
    6660:	8a 85       	ldd	r24, Y+10	; 0x0a
    6662:	9b 85       	ldd	r25, Y+11	; 0x0b
    6664:	02 96       	adiw	r24, 0x02	; 2
    6666:	93 83       	std	Z+3, r25	; 0x03
    6668:	82 83       	std	Z+2, r24	; 0x02
    666a:	8a 85       	ldd	r24, Y+10	; 0x0a
    666c:	9b 85       	ldd	r25, Y+11	; 0x0b
    666e:	02 96       	adiw	r24, 0x02	; 2
    6670:	eb 81       	ldd	r30, Y+3	; 0x03
    6672:	fc 81       	ldd	r31, Y+4	; 0x04
    6674:	95 83       	std	Z+5, r25	; 0x05
    6676:	84 83       	std	Z+4, r24	; 0x04
    6678:	ea 85       	ldd	r30, Y+10	; 0x0a
    667a:	fb 85       	ldd	r31, Y+11	; 0x0b
    667c:	86 89       	ldd	r24, Z+22	; 0x16
    667e:	28 2f       	mov	r18, r24
    6680:	30 e0       	ldi	r19, 0x00	; 0
    6682:	c9 01       	movw	r24, r18
    6684:	88 0f       	add	r24, r24
    6686:	99 1f       	adc	r25, r25
    6688:	88 0f       	add	r24, r24
    668a:	99 1f       	adc	r25, r25
    668c:	88 0f       	add	r24, r24
    668e:	99 1f       	adc	r25, r25
    6690:	82 0f       	add	r24, r18
    6692:	93 1f       	adc	r25, r19
    6694:	88 5a       	subi	r24, 0xA8	; 168
    6696:	98 4f       	sbci	r25, 0xF8	; 248
    6698:	ea 85       	ldd	r30, Y+10	; 0x0a
    669a:	fb 85       	ldd	r31, Y+11	; 0x0b
    669c:	93 87       	std	Z+11, r25	; 0x0b
    669e:	82 87       	std	Z+10, r24	; 0x0a
    66a0:	ea 85       	ldd	r30, Y+10	; 0x0a
    66a2:	fb 85       	ldd	r31, Y+11	; 0x0b
    66a4:	86 89       	ldd	r24, Z+22	; 0x16
    66a6:	28 2f       	mov	r18, r24
    66a8:	30 e0       	ldi	r19, 0x00	; 0
    66aa:	c9 01       	movw	r24, r18
    66ac:	88 0f       	add	r24, r24
    66ae:	99 1f       	adc	r25, r25
    66b0:	88 0f       	add	r24, r24
    66b2:	99 1f       	adc	r25, r25
    66b4:	88 0f       	add	r24, r24
    66b6:	99 1f       	adc	r25, r25
    66b8:	82 0f       	add	r24, r18
    66ba:	93 1f       	adc	r25, r19
    66bc:	fc 01       	movw	r30, r24
    66be:	e8 5a       	subi	r30, 0xA8	; 168
    66c0:	f8 4f       	sbci	r31, 0xF8	; 248
    66c2:	80 81       	ld	r24, Z
    66c4:	8f 5f       	subi	r24, 0xFF	; 255
    66c6:	80 83       	st	Z, r24
    66c8:	30 c0       	rjmp	.+96     	; 0x672a <xTaskGenericNotifyFromISR+0x3b4>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    66ca:	80 91 93 07 	lds	r24, 0x0793
    66ce:	90 91 94 07 	lds	r25, 0x0794
    66d2:	9a 83       	std	Y+2, r25	; 0x02
    66d4:	89 83       	std	Y+1, r24	; 0x01
    66d6:	ea 85       	ldd	r30, Y+10	; 0x0a
    66d8:	fb 85       	ldd	r31, Y+11	; 0x0b
    66da:	89 81       	ldd	r24, Y+1	; 0x01
    66dc:	9a 81       	ldd	r25, Y+2	; 0x02
    66de:	97 87       	std	Z+15, r25	; 0x0f
    66e0:	86 87       	std	Z+14, r24	; 0x0e
    66e2:	e9 81       	ldd	r30, Y+1	; 0x01
    66e4:	fa 81       	ldd	r31, Y+2	; 0x02
    66e6:	84 81       	ldd	r24, Z+4	; 0x04
    66e8:	95 81       	ldd	r25, Z+5	; 0x05
    66ea:	ea 85       	ldd	r30, Y+10	; 0x0a
    66ec:	fb 85       	ldd	r31, Y+11	; 0x0b
    66ee:	91 8b       	std	Z+17, r25	; 0x11
    66f0:	80 8b       	std	Z+16, r24	; 0x10
    66f2:	e9 81       	ldd	r30, Y+1	; 0x01
    66f4:	fa 81       	ldd	r31, Y+2	; 0x02
    66f6:	04 80       	ldd	r0, Z+4	; 0x04
    66f8:	f5 81       	ldd	r31, Z+5	; 0x05
    66fa:	e0 2d       	mov	r30, r0
    66fc:	8a 85       	ldd	r24, Y+10	; 0x0a
    66fe:	9b 85       	ldd	r25, Y+11	; 0x0b
    6700:	0c 96       	adiw	r24, 0x0c	; 12
    6702:	93 83       	std	Z+3, r25	; 0x03
    6704:	82 83       	std	Z+2, r24	; 0x02
    6706:	8a 85       	ldd	r24, Y+10	; 0x0a
    6708:	9b 85       	ldd	r25, Y+11	; 0x0b
    670a:	0c 96       	adiw	r24, 0x0c	; 12
    670c:	e9 81       	ldd	r30, Y+1	; 0x01
    670e:	fa 81       	ldd	r31, Y+2	; 0x02
    6710:	95 83       	std	Z+5, r25	; 0x05
    6712:	84 83       	std	Z+4, r24	; 0x04
    6714:	ea 85       	ldd	r30, Y+10	; 0x0a
    6716:	fb 85       	ldd	r31, Y+11	; 0x0b
    6718:	82 e9       	ldi	r24, 0x92	; 146
    671a:	97 e0       	ldi	r25, 0x07	; 7
    671c:	95 8b       	std	Z+21, r25	; 0x15
    671e:	84 8b       	std	Z+20, r24	; 0x14
    6720:	80 91 92 07 	lds	r24, 0x0792
    6724:	8f 5f       	subi	r24, 0xFF	; 255
    6726:	80 93 92 07 	sts	0x0792, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    672a:	ea 85       	ldd	r30, Y+10	; 0x0a
    672c:	fb 85       	ldd	r31, Y+11	; 0x0b
    672e:	96 89       	ldd	r25, Z+22	; 0x16
    6730:	e0 91 46 07 	lds	r30, 0x0746
    6734:	f0 91 47 07 	lds	r31, 0x0747
    6738:	86 89       	ldd	r24, Z+22	; 0x16
    673a:	89 17       	cp	r24, r25
    673c:	58 f4       	brcc	.+22     	; 0x6754 <xTaskGenericNotifyFromISR+0x3de>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    673e:	8e 89       	ldd	r24, Y+22	; 0x16
    6740:	9f 89       	ldd	r25, Y+23	; 0x17
    6742:	00 97       	sbiw	r24, 0x00	; 0
    6744:	21 f0       	breq	.+8      	; 0x674e <xTaskGenericNotifyFromISR+0x3d8>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    6746:	ee 89       	ldd	r30, Y+22	; 0x16
    6748:	ff 89       	ldd	r31, Y+23	; 0x17
    674a:	81 e0       	ldi	r24, 0x01	; 1
    674c:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    674e:	81 e0       	ldi	r24, 0x01	; 1
    6750:	80 93 50 07 	sts	0x0750, r24
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    6754:	88 85       	ldd	r24, Y+8	; 0x08
    }
    6756:	69 96       	adiw	r28, 0x19	; 25
    6758:	0f b6       	in	r0, 0x3f	; 63
    675a:	f8 94       	cli
    675c:	de bf       	out	0x3e, r29	; 62
    675e:	0f be       	out	0x3f, r0	; 63
    6760:	cd bf       	out	0x3d, r28	; 61
    6762:	cf 91       	pop	r28
    6764:	df 91       	pop	r29
    6766:	1f 91       	pop	r17
    6768:	0f 91       	pop	r16
    676a:	ff 90       	pop	r15
    676c:	ef 90       	pop	r14
    676e:	df 90       	pop	r13
    6770:	cf 90       	pop	r12
    6772:	08 95       	ret

00006774 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    6774:	0f 93       	push	r16
    6776:	1f 93       	push	r17
    6778:	df 93       	push	r29
    677a:	cf 93       	push	r28
    677c:	cd b7       	in	r28, 0x3d	; 61
    677e:	de b7       	in	r29, 0x3e	; 62
    6780:	2f 97       	sbiw	r28, 0x0f	; 15
    6782:	0f b6       	in	r0, 0x3f	; 63
    6784:	f8 94       	cli
    6786:	de bf       	out	0x3e, r29	; 62
    6788:	0f be       	out	0x3f, r0	; 63
    678a:	cd bf       	out	0x3d, r28	; 61
    678c:	9c 87       	std	Y+12, r25	; 0x0c
    678e:	8b 87       	std	Y+11, r24	; 0x0b
    6790:	6d 87       	std	Y+13, r22	; 0x0d
    6792:	5f 87       	std	Y+15, r21	; 0x0f
    6794:	4e 87       	std	Y+14, r20	; 0x0e
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    6796:	8b 85       	ldd	r24, Y+11	; 0x0b
    6798:	9c 85       	ldd	r25, Y+12	; 0x0c
    679a:	9a 87       	std	Y+10, r25	; 0x0a
    679c:	89 87       	std	Y+9, r24	; 0x09

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    679e:	1f 82       	std	Y+7, r1	; 0x07
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    67a0:	8d 85       	ldd	r24, Y+13	; 0x0d
    67a2:	28 2f       	mov	r18, r24
    67a4:	30 e0       	ldi	r19, 0x00	; 0
    67a6:	89 85       	ldd	r24, Y+9	; 0x09
    67a8:	9a 85       	ldd	r25, Y+10	; 0x0a
    67aa:	82 0f       	add	r24, r18
    67ac:	93 1f       	adc	r25, r19
    67ae:	fc 01       	movw	r30, r24
    67b0:	b5 96       	adiw	r30, 0x25	; 37
    67b2:	80 81       	ld	r24, Z
    67b4:	88 87       	std	Y+8, r24	; 0x08
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    67b6:	8d 85       	ldd	r24, Y+13	; 0x0d
    67b8:	28 2f       	mov	r18, r24
    67ba:	30 e0       	ldi	r19, 0x00	; 0
    67bc:	89 85       	ldd	r24, Y+9	; 0x09
    67be:	9a 85       	ldd	r25, Y+10	; 0x0a
    67c0:	82 0f       	add	r24, r18
    67c2:	93 1f       	adc	r25, r19
    67c4:	fc 01       	movw	r30, r24
    67c6:	b5 96       	adiw	r30, 0x25	; 37
    67c8:	82 e0       	ldi	r24, 0x02	; 2
    67ca:	80 83       	st	Z, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    67cc:	8d 85       	ldd	r24, Y+13	; 0x0d
    67ce:	08 2f       	mov	r16, r24
    67d0:	10 e0       	ldi	r17, 0x00	; 0
    67d2:	29 85       	ldd	r18, Y+9	; 0x09
    67d4:	3a 85       	ldd	r19, Y+10	; 0x0a
    67d6:	c8 01       	movw	r24, r16
    67d8:	88 0f       	add	r24, r24
    67da:	99 1f       	adc	r25, r25
    67dc:	88 0f       	add	r24, r24
    67de:	99 1f       	adc	r25, r25
    67e0:	82 0f       	add	r24, r18
    67e2:	93 1f       	adc	r25, r19
    67e4:	fc 01       	movw	r30, r24
    67e6:	b1 96       	adiw	r30, 0x21	; 33
    67e8:	80 81       	ld	r24, Z
    67ea:	91 81       	ldd	r25, Z+1	; 0x01
    67ec:	a2 81       	ldd	r26, Z+2	; 0x02
    67ee:	b3 81       	ldd	r27, Z+3	; 0x03
    67f0:	ac 01       	movw	r20, r24
    67f2:	bd 01       	movw	r22, r26
    67f4:	4f 5f       	subi	r20, 0xFF	; 255
    67f6:	5f 4f       	sbci	r21, 0xFF	; 255
    67f8:	6f 4f       	sbci	r22, 0xFF	; 255
    67fa:	7f 4f       	sbci	r23, 0xFF	; 255
    67fc:	29 85       	ldd	r18, Y+9	; 0x09
    67fe:	3a 85       	ldd	r19, Y+10	; 0x0a
    6800:	c8 01       	movw	r24, r16
    6802:	88 0f       	add	r24, r24
    6804:	99 1f       	adc	r25, r25
    6806:	88 0f       	add	r24, r24
    6808:	99 1f       	adc	r25, r25
    680a:	82 0f       	add	r24, r18
    680c:	93 1f       	adc	r25, r19
    680e:	fc 01       	movw	r30, r24
    6810:	b1 96       	adiw	r30, 0x21	; 33
    6812:	40 83       	st	Z, r20
    6814:	51 83       	std	Z+1, r21	; 0x01
    6816:	62 83       	std	Z+2, r22	; 0x02
    6818:	73 83       	std	Z+3, r23	; 0x03

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    681a:	88 85       	ldd	r24, Y+8	; 0x08
    681c:	81 30       	cpi	r24, 0x01	; 1
    681e:	09 f0       	breq	.+2      	; 0x6822 <vTaskGenericNotifyGiveFromISR+0xae>
    6820:	ee c0       	rjmp	.+476    	; 0x69fe <vTaskGenericNotifyGiveFromISR+0x28a>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    6822:	80 91 57 07 	lds	r24, 0x0757
    6826:	88 23       	and	r24, r24
    6828:	09 f0       	breq	.+2      	; 0x682c <vTaskGenericNotifyGiveFromISR+0xb8>
    682a:	a4 c0       	rjmp	.+328    	; 0x6974 <vTaskGenericNotifyGiveFromISR+0x200>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    682c:	e9 85       	ldd	r30, Y+9	; 0x09
    682e:	fa 85       	ldd	r31, Y+10	; 0x0a
    6830:	82 85       	ldd	r24, Z+10	; 0x0a
    6832:	93 85       	ldd	r25, Z+11	; 0x0b
    6834:	9e 83       	std	Y+6, r25	; 0x06
    6836:	8d 83       	std	Y+5, r24	; 0x05
    6838:	e9 85       	ldd	r30, Y+9	; 0x09
    683a:	fa 85       	ldd	r31, Y+10	; 0x0a
    683c:	a4 81       	ldd	r26, Z+4	; 0x04
    683e:	b5 81       	ldd	r27, Z+5	; 0x05
    6840:	e9 85       	ldd	r30, Y+9	; 0x09
    6842:	fa 85       	ldd	r31, Y+10	; 0x0a
    6844:	86 81       	ldd	r24, Z+6	; 0x06
    6846:	97 81       	ldd	r25, Z+7	; 0x07
    6848:	15 96       	adiw	r26, 0x05	; 5
    684a:	9c 93       	st	X, r25
    684c:	8e 93       	st	-X, r24
    684e:	14 97       	sbiw	r26, 0x04	; 4
    6850:	e9 85       	ldd	r30, Y+9	; 0x09
    6852:	fa 85       	ldd	r31, Y+10	; 0x0a
    6854:	a6 81       	ldd	r26, Z+6	; 0x06
    6856:	b7 81       	ldd	r27, Z+7	; 0x07
    6858:	e9 85       	ldd	r30, Y+9	; 0x09
    685a:	fa 85       	ldd	r31, Y+10	; 0x0a
    685c:	84 81       	ldd	r24, Z+4	; 0x04
    685e:	95 81       	ldd	r25, Z+5	; 0x05
    6860:	13 96       	adiw	r26, 0x03	; 3
    6862:	9c 93       	st	X, r25
    6864:	8e 93       	st	-X, r24
    6866:	12 97       	sbiw	r26, 0x02	; 2
    6868:	ed 81       	ldd	r30, Y+5	; 0x05
    686a:	fe 81       	ldd	r31, Y+6	; 0x06
    686c:	21 81       	ldd	r18, Z+1	; 0x01
    686e:	32 81       	ldd	r19, Z+2	; 0x02
    6870:	89 85       	ldd	r24, Y+9	; 0x09
    6872:	9a 85       	ldd	r25, Y+10	; 0x0a
    6874:	02 96       	adiw	r24, 0x02	; 2
    6876:	28 17       	cp	r18, r24
    6878:	39 07       	cpc	r19, r25
    687a:	41 f4       	brne	.+16     	; 0x688c <vTaskGenericNotifyGiveFromISR+0x118>
    687c:	e9 85       	ldd	r30, Y+9	; 0x09
    687e:	fa 85       	ldd	r31, Y+10	; 0x0a
    6880:	86 81       	ldd	r24, Z+6	; 0x06
    6882:	97 81       	ldd	r25, Z+7	; 0x07
    6884:	ed 81       	ldd	r30, Y+5	; 0x05
    6886:	fe 81       	ldd	r31, Y+6	; 0x06
    6888:	92 83       	std	Z+2, r25	; 0x02
    688a:	81 83       	std	Z+1, r24	; 0x01
    688c:	e9 85       	ldd	r30, Y+9	; 0x09
    688e:	fa 85       	ldd	r31, Y+10	; 0x0a
    6890:	13 86       	std	Z+11, r1	; 0x0b
    6892:	12 86       	std	Z+10, r1	; 0x0a
    6894:	ed 81       	ldd	r30, Y+5	; 0x05
    6896:	fe 81       	ldd	r31, Y+6	; 0x06
    6898:	80 81       	ld	r24, Z
    689a:	81 50       	subi	r24, 0x01	; 1
    689c:	ed 81       	ldd	r30, Y+5	; 0x05
    689e:	fe 81       	ldd	r31, Y+6	; 0x06
    68a0:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    68a2:	e9 85       	ldd	r30, Y+9	; 0x09
    68a4:	fa 85       	ldd	r31, Y+10	; 0x0a
    68a6:	96 89       	ldd	r25, Z+22	; 0x16
    68a8:	80 91 4c 07 	lds	r24, 0x074C
    68ac:	89 17       	cp	r24, r25
    68ae:	28 f4       	brcc	.+10     	; 0x68ba <vTaskGenericNotifyGiveFromISR+0x146>
    68b0:	e9 85       	ldd	r30, Y+9	; 0x09
    68b2:	fa 85       	ldd	r31, Y+10	; 0x0a
    68b4:	86 89       	ldd	r24, Z+22	; 0x16
    68b6:	80 93 4c 07 	sts	0x074C, r24
    68ba:	e9 85       	ldd	r30, Y+9	; 0x09
    68bc:	fa 85       	ldd	r31, Y+10	; 0x0a
    68be:	86 89       	ldd	r24, Z+22	; 0x16
    68c0:	28 2f       	mov	r18, r24
    68c2:	30 e0       	ldi	r19, 0x00	; 0
    68c4:	c9 01       	movw	r24, r18
    68c6:	88 0f       	add	r24, r24
    68c8:	99 1f       	adc	r25, r25
    68ca:	88 0f       	add	r24, r24
    68cc:	99 1f       	adc	r25, r25
    68ce:	88 0f       	add	r24, r24
    68d0:	99 1f       	adc	r25, r25
    68d2:	82 0f       	add	r24, r18
    68d4:	93 1f       	adc	r25, r19
    68d6:	fc 01       	movw	r30, r24
    68d8:	e8 5a       	subi	r30, 0xA8	; 168
    68da:	f8 4f       	sbci	r31, 0xF8	; 248
    68dc:	81 81       	ldd	r24, Z+1	; 0x01
    68de:	92 81       	ldd	r25, Z+2	; 0x02
    68e0:	9c 83       	std	Y+4, r25	; 0x04
    68e2:	8b 83       	std	Y+3, r24	; 0x03
    68e4:	e9 85       	ldd	r30, Y+9	; 0x09
    68e6:	fa 85       	ldd	r31, Y+10	; 0x0a
    68e8:	8b 81       	ldd	r24, Y+3	; 0x03
    68ea:	9c 81       	ldd	r25, Y+4	; 0x04
    68ec:	95 83       	std	Z+5, r25	; 0x05
    68ee:	84 83       	std	Z+4, r24	; 0x04
    68f0:	eb 81       	ldd	r30, Y+3	; 0x03
    68f2:	fc 81       	ldd	r31, Y+4	; 0x04
    68f4:	84 81       	ldd	r24, Z+4	; 0x04
    68f6:	95 81       	ldd	r25, Z+5	; 0x05
    68f8:	e9 85       	ldd	r30, Y+9	; 0x09
    68fa:	fa 85       	ldd	r31, Y+10	; 0x0a
    68fc:	97 83       	std	Z+7, r25	; 0x07
    68fe:	86 83       	std	Z+6, r24	; 0x06
    6900:	eb 81       	ldd	r30, Y+3	; 0x03
    6902:	fc 81       	ldd	r31, Y+4	; 0x04
    6904:	04 80       	ldd	r0, Z+4	; 0x04
    6906:	f5 81       	ldd	r31, Z+5	; 0x05
    6908:	e0 2d       	mov	r30, r0
    690a:	89 85       	ldd	r24, Y+9	; 0x09
    690c:	9a 85       	ldd	r25, Y+10	; 0x0a
    690e:	02 96       	adiw	r24, 0x02	; 2
    6910:	93 83       	std	Z+3, r25	; 0x03
    6912:	82 83       	std	Z+2, r24	; 0x02
    6914:	89 85       	ldd	r24, Y+9	; 0x09
    6916:	9a 85       	ldd	r25, Y+10	; 0x0a
    6918:	02 96       	adiw	r24, 0x02	; 2
    691a:	eb 81       	ldd	r30, Y+3	; 0x03
    691c:	fc 81       	ldd	r31, Y+4	; 0x04
    691e:	95 83       	std	Z+5, r25	; 0x05
    6920:	84 83       	std	Z+4, r24	; 0x04
    6922:	e9 85       	ldd	r30, Y+9	; 0x09
    6924:	fa 85       	ldd	r31, Y+10	; 0x0a
    6926:	86 89       	ldd	r24, Z+22	; 0x16
    6928:	28 2f       	mov	r18, r24
    692a:	30 e0       	ldi	r19, 0x00	; 0
    692c:	c9 01       	movw	r24, r18
    692e:	88 0f       	add	r24, r24
    6930:	99 1f       	adc	r25, r25
    6932:	88 0f       	add	r24, r24
    6934:	99 1f       	adc	r25, r25
    6936:	88 0f       	add	r24, r24
    6938:	99 1f       	adc	r25, r25
    693a:	82 0f       	add	r24, r18
    693c:	93 1f       	adc	r25, r19
    693e:	88 5a       	subi	r24, 0xA8	; 168
    6940:	98 4f       	sbci	r25, 0xF8	; 248
    6942:	e9 85       	ldd	r30, Y+9	; 0x09
    6944:	fa 85       	ldd	r31, Y+10	; 0x0a
    6946:	93 87       	std	Z+11, r25	; 0x0b
    6948:	82 87       	std	Z+10, r24	; 0x0a
    694a:	e9 85       	ldd	r30, Y+9	; 0x09
    694c:	fa 85       	ldd	r31, Y+10	; 0x0a
    694e:	86 89       	ldd	r24, Z+22	; 0x16
    6950:	28 2f       	mov	r18, r24
    6952:	30 e0       	ldi	r19, 0x00	; 0
    6954:	c9 01       	movw	r24, r18
    6956:	88 0f       	add	r24, r24
    6958:	99 1f       	adc	r25, r25
    695a:	88 0f       	add	r24, r24
    695c:	99 1f       	adc	r25, r25
    695e:	88 0f       	add	r24, r24
    6960:	99 1f       	adc	r25, r25
    6962:	82 0f       	add	r24, r18
    6964:	93 1f       	adc	r25, r19
    6966:	fc 01       	movw	r30, r24
    6968:	e8 5a       	subi	r30, 0xA8	; 168
    696a:	f8 4f       	sbci	r31, 0xF8	; 248
    696c:	80 81       	ld	r24, Z
    696e:	8f 5f       	subi	r24, 0xFF	; 255
    6970:	80 83       	st	Z, r24
    6972:	30 c0       	rjmp	.+96     	; 0x69d4 <vTaskGenericNotifyGiveFromISR+0x260>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    6974:	80 91 93 07 	lds	r24, 0x0793
    6978:	90 91 94 07 	lds	r25, 0x0794
    697c:	9a 83       	std	Y+2, r25	; 0x02
    697e:	89 83       	std	Y+1, r24	; 0x01
    6980:	e9 85       	ldd	r30, Y+9	; 0x09
    6982:	fa 85       	ldd	r31, Y+10	; 0x0a
    6984:	89 81       	ldd	r24, Y+1	; 0x01
    6986:	9a 81       	ldd	r25, Y+2	; 0x02
    6988:	97 87       	std	Z+15, r25	; 0x0f
    698a:	86 87       	std	Z+14, r24	; 0x0e
    698c:	e9 81       	ldd	r30, Y+1	; 0x01
    698e:	fa 81       	ldd	r31, Y+2	; 0x02
    6990:	84 81       	ldd	r24, Z+4	; 0x04
    6992:	95 81       	ldd	r25, Z+5	; 0x05
    6994:	e9 85       	ldd	r30, Y+9	; 0x09
    6996:	fa 85       	ldd	r31, Y+10	; 0x0a
    6998:	91 8b       	std	Z+17, r25	; 0x11
    699a:	80 8b       	std	Z+16, r24	; 0x10
    699c:	e9 81       	ldd	r30, Y+1	; 0x01
    699e:	fa 81       	ldd	r31, Y+2	; 0x02
    69a0:	04 80       	ldd	r0, Z+4	; 0x04
    69a2:	f5 81       	ldd	r31, Z+5	; 0x05
    69a4:	e0 2d       	mov	r30, r0
    69a6:	89 85       	ldd	r24, Y+9	; 0x09
    69a8:	9a 85       	ldd	r25, Y+10	; 0x0a
    69aa:	0c 96       	adiw	r24, 0x0c	; 12
    69ac:	93 83       	std	Z+3, r25	; 0x03
    69ae:	82 83       	std	Z+2, r24	; 0x02
    69b0:	89 85       	ldd	r24, Y+9	; 0x09
    69b2:	9a 85       	ldd	r25, Y+10	; 0x0a
    69b4:	0c 96       	adiw	r24, 0x0c	; 12
    69b6:	e9 81       	ldd	r30, Y+1	; 0x01
    69b8:	fa 81       	ldd	r31, Y+2	; 0x02
    69ba:	95 83       	std	Z+5, r25	; 0x05
    69bc:	84 83       	std	Z+4, r24	; 0x04
    69be:	e9 85       	ldd	r30, Y+9	; 0x09
    69c0:	fa 85       	ldd	r31, Y+10	; 0x0a
    69c2:	82 e9       	ldi	r24, 0x92	; 146
    69c4:	97 e0       	ldi	r25, 0x07	; 7
    69c6:	95 8b       	std	Z+21, r25	; 0x15
    69c8:	84 8b       	std	Z+20, r24	; 0x14
    69ca:	80 91 92 07 	lds	r24, 0x0792
    69ce:	8f 5f       	subi	r24, 0xFF	; 255
    69d0:	80 93 92 07 	sts	0x0792, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    69d4:	e9 85       	ldd	r30, Y+9	; 0x09
    69d6:	fa 85       	ldd	r31, Y+10	; 0x0a
    69d8:	96 89       	ldd	r25, Z+22	; 0x16
    69da:	e0 91 46 07 	lds	r30, 0x0746
    69de:	f0 91 47 07 	lds	r31, 0x0747
    69e2:	86 89       	ldd	r24, Z+22	; 0x16
    69e4:	89 17       	cp	r24, r25
    69e6:	58 f4       	brcc	.+22     	; 0x69fe <vTaskGenericNotifyGiveFromISR+0x28a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    69e8:	8e 85       	ldd	r24, Y+14	; 0x0e
    69ea:	9f 85       	ldd	r25, Y+15	; 0x0f
    69ec:	00 97       	sbiw	r24, 0x00	; 0
    69ee:	21 f0       	breq	.+8      	; 0x69f8 <vTaskGenericNotifyGiveFromISR+0x284>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    69f0:	ee 85       	ldd	r30, Y+14	; 0x0e
    69f2:	ff 85       	ldd	r31, Y+15	; 0x0f
    69f4:	81 e0       	ldi	r24, 0x01	; 1
    69f6:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    69f8:	81 e0       	ldi	r24, 0x01	; 1
    69fa:	80 93 50 07 	sts	0x0750, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    69fe:	2f 96       	adiw	r28, 0x0f	; 15
    6a00:	0f b6       	in	r0, 0x3f	; 63
    6a02:	f8 94       	cli
    6a04:	de bf       	out	0x3e, r29	; 62
    6a06:	0f be       	out	0x3f, r0	; 63
    6a08:	cd bf       	out	0x3d, r28	; 61
    6a0a:	cf 91       	pop	r28
    6a0c:	df 91       	pop	r29
    6a0e:	1f 91       	pop	r17
    6a10:	0f 91       	pop	r16
    6a12:	08 95       	ret

00006a14 <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    6a14:	df 93       	push	r29
    6a16:	cf 93       	push	r28
    6a18:	cd b7       	in	r28, 0x3d	; 61
    6a1a:	de b7       	in	r29, 0x3e	; 62
    6a1c:	28 97       	sbiw	r28, 0x08	; 8
    6a1e:	0f b6       	in	r0, 0x3f	; 63
    6a20:	f8 94       	cli
    6a22:	de bf       	out	0x3e, r29	; 62
    6a24:	0f be       	out	0x3f, r0	; 63
    6a26:	cd bf       	out	0x3d, r28	; 61
    6a28:	9d 83       	std	Y+5, r25	; 0x05
    6a2a:	8c 83       	std	Y+4, r24	; 0x04
    6a2c:	6e 83       	std	Y+6, r22	; 0x06

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    6a2e:	8c 81       	ldd	r24, Y+4	; 0x04
    6a30:	9d 81       	ldd	r25, Y+5	; 0x05
    6a32:	00 97       	sbiw	r24, 0x00	; 0
    6a34:	39 f4       	brne	.+14     	; 0x6a44 <xTaskGenericNotifyStateClear+0x30>
    6a36:	80 91 46 07 	lds	r24, 0x0746
    6a3a:	90 91 47 07 	lds	r25, 0x0747
    6a3e:	98 87       	std	Y+8, r25	; 0x08
    6a40:	8f 83       	std	Y+7, r24	; 0x07
    6a42:	04 c0       	rjmp	.+8      	; 0x6a4c <xTaskGenericNotifyStateClear+0x38>
    6a44:	8c 81       	ldd	r24, Y+4	; 0x04
    6a46:	9d 81       	ldd	r25, Y+5	; 0x05
    6a48:	98 87       	std	Y+8, r25	; 0x08
    6a4a:	8f 83       	std	Y+7, r24	; 0x07
    6a4c:	8f 81       	ldd	r24, Y+7	; 0x07
    6a4e:	98 85       	ldd	r25, Y+8	; 0x08
    6a50:	9b 83       	std	Y+3, r25	; 0x03
    6a52:	8a 83       	std	Y+2, r24	; 0x02

        taskENTER_CRITICAL();
    6a54:	0f b6       	in	r0, 0x3f	; 63
    6a56:	f8 94       	cli
    6a58:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    6a5a:	8e 81       	ldd	r24, Y+6	; 0x06
    6a5c:	28 2f       	mov	r18, r24
    6a5e:	30 e0       	ldi	r19, 0x00	; 0
    6a60:	8a 81       	ldd	r24, Y+2	; 0x02
    6a62:	9b 81       	ldd	r25, Y+3	; 0x03
    6a64:	82 0f       	add	r24, r18
    6a66:	93 1f       	adc	r25, r19
    6a68:	fc 01       	movw	r30, r24
    6a6a:	b5 96       	adiw	r30, 0x25	; 37
    6a6c:	80 81       	ld	r24, Z
    6a6e:	82 30       	cpi	r24, 0x02	; 2
    6a70:	69 f4       	brne	.+26     	; 0x6a8c <xTaskGenericNotifyStateClear+0x78>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    6a72:	8e 81       	ldd	r24, Y+6	; 0x06
    6a74:	28 2f       	mov	r18, r24
    6a76:	30 e0       	ldi	r19, 0x00	; 0
    6a78:	8a 81       	ldd	r24, Y+2	; 0x02
    6a7a:	9b 81       	ldd	r25, Y+3	; 0x03
    6a7c:	82 0f       	add	r24, r18
    6a7e:	93 1f       	adc	r25, r19
    6a80:	fc 01       	movw	r30, r24
    6a82:	b5 96       	adiw	r30, 0x25	; 37
    6a84:	10 82       	st	Z, r1
                xReturn = pdPASS;
    6a86:	81 e0       	ldi	r24, 0x01	; 1
    6a88:	89 83       	std	Y+1, r24	; 0x01
    6a8a:	01 c0       	rjmp	.+2      	; 0x6a8e <xTaskGenericNotifyStateClear+0x7a>
            }
            else
            {
                xReturn = pdFAIL;
    6a8c:	19 82       	std	Y+1, r1	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    6a8e:	0f 90       	pop	r0
    6a90:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    6a92:	89 81       	ldd	r24, Y+1	; 0x01
    }
    6a94:	28 96       	adiw	r28, 0x08	; 8
    6a96:	0f b6       	in	r0, 0x3f	; 63
    6a98:	f8 94       	cli
    6a9a:	de bf       	out	0x3e, r29	; 62
    6a9c:	0f be       	out	0x3f, r0	; 63
    6a9e:	cd bf       	out	0x3d, r28	; 61
    6aa0:	cf 91       	pop	r28
    6aa2:	df 91       	pop	r29
    6aa4:	08 95       	ret

00006aa6 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    6aa6:	0f 93       	push	r16
    6aa8:	1f 93       	push	r17
    6aaa:	df 93       	push	r29
    6aac:	cf 93       	push	r28
    6aae:	cd b7       	in	r28, 0x3d	; 61
    6ab0:	de b7       	in	r29, 0x3e	; 62
    6ab2:	2f 97       	sbiw	r28, 0x0f	; 15
    6ab4:	0f b6       	in	r0, 0x3f	; 63
    6ab6:	f8 94       	cli
    6ab8:	de bf       	out	0x3e, r29	; 62
    6aba:	0f be       	out	0x3f, r0	; 63
    6abc:	cd bf       	out	0x3d, r28	; 61
    6abe:	98 87       	std	Y+8, r25	; 0x08
    6ac0:	8f 83       	std	Y+7, r24	; 0x07
    6ac2:	69 87       	std	Y+9, r22	; 0x09
    6ac4:	2a 87       	std	Y+10, r18	; 0x0a
    6ac6:	3b 87       	std	Y+11, r19	; 0x0b
    6ac8:	4c 87       	std	Y+12, r20	; 0x0c
    6aca:	5d 87       	std	Y+13, r21	; 0x0d
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    6acc:	8f 81       	ldd	r24, Y+7	; 0x07
    6ace:	98 85       	ldd	r25, Y+8	; 0x08
    6ad0:	00 97       	sbiw	r24, 0x00	; 0
    6ad2:	39 f4       	brne	.+14     	; 0x6ae2 <ulTaskGenericNotifyValueClear+0x3c>
    6ad4:	80 91 46 07 	lds	r24, 0x0746
    6ad8:	90 91 47 07 	lds	r25, 0x0747
    6adc:	9f 87       	std	Y+15, r25	; 0x0f
    6ade:	8e 87       	std	Y+14, r24	; 0x0e
    6ae0:	04 c0       	rjmp	.+8      	; 0x6aea <ulTaskGenericNotifyValueClear+0x44>
    6ae2:	8f 81       	ldd	r24, Y+7	; 0x07
    6ae4:	98 85       	ldd	r25, Y+8	; 0x08
    6ae6:	9f 87       	std	Y+15, r25	; 0x0f
    6ae8:	8e 87       	std	Y+14, r24	; 0x0e
    6aea:	8e 85       	ldd	r24, Y+14	; 0x0e
    6aec:	9f 85       	ldd	r25, Y+15	; 0x0f
    6aee:	9e 83       	std	Y+6, r25	; 0x06
    6af0:	8d 83       	std	Y+5, r24	; 0x05

        taskENTER_CRITICAL();
    6af2:	0f b6       	in	r0, 0x3f	; 63
    6af4:	f8 94       	cli
    6af6:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    6af8:	89 85       	ldd	r24, Y+9	; 0x09
    6afa:	88 2f       	mov	r24, r24
    6afc:	90 e0       	ldi	r25, 0x00	; 0
    6afe:	2d 81       	ldd	r18, Y+5	; 0x05
    6b00:	3e 81       	ldd	r19, Y+6	; 0x06
    6b02:	88 0f       	add	r24, r24
    6b04:	99 1f       	adc	r25, r25
    6b06:	88 0f       	add	r24, r24
    6b08:	99 1f       	adc	r25, r25
    6b0a:	82 0f       	add	r24, r18
    6b0c:	93 1f       	adc	r25, r19
    6b0e:	fc 01       	movw	r30, r24
    6b10:	b1 96       	adiw	r30, 0x21	; 33
    6b12:	80 81       	ld	r24, Z
    6b14:	91 81       	ldd	r25, Z+1	; 0x01
    6b16:	a2 81       	ldd	r26, Z+2	; 0x02
    6b18:	b3 81       	ldd	r27, Z+3	; 0x03
    6b1a:	89 83       	std	Y+1, r24	; 0x01
    6b1c:	9a 83       	std	Y+2, r25	; 0x02
    6b1e:	ab 83       	std	Y+3, r26	; 0x03
    6b20:	bc 83       	std	Y+4, r27	; 0x04
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    6b22:	89 85       	ldd	r24, Y+9	; 0x09
    6b24:	08 2f       	mov	r16, r24
    6b26:	10 e0       	ldi	r17, 0x00	; 0
    6b28:	89 85       	ldd	r24, Y+9	; 0x09
    6b2a:	88 2f       	mov	r24, r24
    6b2c:	90 e0       	ldi	r25, 0x00	; 0
    6b2e:	2d 81       	ldd	r18, Y+5	; 0x05
    6b30:	3e 81       	ldd	r19, Y+6	; 0x06
    6b32:	88 0f       	add	r24, r24
    6b34:	99 1f       	adc	r25, r25
    6b36:	88 0f       	add	r24, r24
    6b38:	99 1f       	adc	r25, r25
    6b3a:	82 0f       	add	r24, r18
    6b3c:	93 1f       	adc	r25, r19
    6b3e:	fc 01       	movw	r30, r24
    6b40:	b1 96       	adiw	r30, 0x21	; 33
    6b42:	20 81       	ld	r18, Z
    6b44:	31 81       	ldd	r19, Z+1	; 0x01
    6b46:	42 81       	ldd	r20, Z+2	; 0x02
    6b48:	53 81       	ldd	r21, Z+3	; 0x03
    6b4a:	8a 85       	ldd	r24, Y+10	; 0x0a
    6b4c:	9b 85       	ldd	r25, Y+11	; 0x0b
    6b4e:	ac 85       	ldd	r26, Y+12	; 0x0c
    6b50:	bd 85       	ldd	r27, Y+13	; 0x0d
    6b52:	80 95       	com	r24
    6b54:	90 95       	com	r25
    6b56:	a0 95       	com	r26
    6b58:	b0 95       	com	r27
    6b5a:	ba 01       	movw	r22, r20
    6b5c:	a9 01       	movw	r20, r18
    6b5e:	48 23       	and	r20, r24
    6b60:	59 23       	and	r21, r25
    6b62:	6a 23       	and	r22, r26
    6b64:	7b 23       	and	r23, r27
    6b66:	2d 81       	ldd	r18, Y+5	; 0x05
    6b68:	3e 81       	ldd	r19, Y+6	; 0x06
    6b6a:	c8 01       	movw	r24, r16
    6b6c:	88 0f       	add	r24, r24
    6b6e:	99 1f       	adc	r25, r25
    6b70:	88 0f       	add	r24, r24
    6b72:	99 1f       	adc	r25, r25
    6b74:	82 0f       	add	r24, r18
    6b76:	93 1f       	adc	r25, r19
    6b78:	fc 01       	movw	r30, r24
    6b7a:	b1 96       	adiw	r30, 0x21	; 33
    6b7c:	40 83       	st	Z, r20
    6b7e:	51 83       	std	Z+1, r21	; 0x01
    6b80:	62 83       	std	Z+2, r22	; 0x02
    6b82:	73 83       	std	Z+3, r23	; 0x03
        }
        taskEXIT_CRITICAL();
    6b84:	0f 90       	pop	r0
    6b86:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    6b88:	89 81       	ldd	r24, Y+1	; 0x01
    6b8a:	9a 81       	ldd	r25, Y+2	; 0x02
    6b8c:	ab 81       	ldd	r26, Y+3	; 0x03
    6b8e:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    6b90:	bc 01       	movw	r22, r24
    6b92:	cd 01       	movw	r24, r26
    6b94:	2f 96       	adiw	r28, 0x0f	; 15
    6b96:	0f b6       	in	r0, 0x3f	; 63
    6b98:	f8 94       	cli
    6b9a:	de bf       	out	0x3e, r29	; 62
    6b9c:	0f be       	out	0x3f, r0	; 63
    6b9e:	cd bf       	out	0x3d, r28	; 61
    6ba0:	cf 91       	pop	r28
    6ba2:	df 91       	pop	r29
    6ba4:	1f 91       	pop	r17
    6ba6:	0f 91       	pop	r16
    6ba8:	08 95       	ret

00006baa <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    6baa:	df 93       	push	r29
    6bac:	cf 93       	push	r28
    6bae:	cd b7       	in	r28, 0x3d	; 61
    6bb0:	de b7       	in	r29, 0x3e	; 62
    6bb2:	27 97       	sbiw	r28, 0x07	; 7
    6bb4:	0f b6       	in	r0, 0x3f	; 63
    6bb6:	f8 94       	cli
    6bb8:	de bf       	out	0x3e, r29	; 62
    6bba:	0f be       	out	0x3f, r0	; 63
    6bbc:	cd bf       	out	0x3d, r28	; 61
    6bbe:	9e 83       	std	Y+6, r25	; 0x06
    6bc0:	8d 83       	std	Y+5, r24	; 0x05
    6bc2:	6f 83       	std	Y+7, r22	; 0x07
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    6bc4:	80 91 4a 07 	lds	r24, 0x074A
    6bc8:	90 91 4b 07 	lds	r25, 0x074B
    6bcc:	9a 83       	std	Y+2, r25	; 0x02
    6bce:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    6bd0:	80 91 46 07 	lds	r24, 0x0746
    6bd4:	90 91 47 07 	lds	r25, 0x0747
    6bd8:	02 96       	adiw	r24, 0x02	; 2
    6bda:	0e 94 a9 18 	call	0x3152	; 0x3152 <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the kernel
             * will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
    6bde:	29 81       	ldd	r18, Y+1	; 0x01
    6be0:	3a 81       	ldd	r19, Y+2	; 0x02
    6be2:	8d 81       	ldd	r24, Y+5	; 0x05
    6be4:	9e 81       	ldd	r25, Y+6	; 0x06
    6be6:	82 0f       	add	r24, r18
    6be8:	93 1f       	adc	r25, r19
    6bea:	9c 83       	std	Y+4, r25	; 0x04
    6bec:	8b 83       	std	Y+3, r24	; 0x03

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    6bee:	e0 91 46 07 	lds	r30, 0x0746
    6bf2:	f0 91 47 07 	lds	r31, 0x0747
    6bf6:	8b 81       	ldd	r24, Y+3	; 0x03
    6bf8:	9c 81       	ldd	r25, Y+4	; 0x04
    6bfa:	93 83       	std	Z+3, r25	; 0x03
    6bfc:	82 83       	std	Z+2, r24	; 0x02

            if( xTimeToWake < xConstTickCount )
    6bfe:	2b 81       	ldd	r18, Y+3	; 0x03
    6c00:	3c 81       	ldd	r19, Y+4	; 0x04
    6c02:	89 81       	ldd	r24, Y+1	; 0x01
    6c04:	9a 81       	ldd	r25, Y+2	; 0x02
    6c06:	28 17       	cp	r18, r24
    6c08:	39 07       	cpc	r19, r25
    6c0a:	70 f4       	brcc	.+28     	; 0x6c28 <prvAddCurrentTaskToDelayedList+0x7e>
            {
                /* Wake time has overflowed.  Place this item in the overflow list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    6c0c:	80 91 90 07 	lds	r24, 0x0790
    6c10:	90 91 91 07 	lds	r25, 0x0791
    6c14:	20 91 46 07 	lds	r18, 0x0746
    6c18:	30 91 47 07 	lds	r19, 0x0747
    6c1c:	2e 5f       	subi	r18, 0xFE	; 254
    6c1e:	3f 4f       	sbci	r19, 0xFF	; 255
    6c20:	b9 01       	movw	r22, r18
    6c22:	0e 94 3d 18 	call	0x307a	; 0x307a <vListInsert>
    6c26:	1e c0       	rjmp	.+60     	; 0x6c64 <prvAddCurrentTaskToDelayedList+0xba>
            }
            else
            {
                /* The wake time has not overflowed, so the current block list is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    6c28:	40 91 8e 07 	lds	r20, 0x078E
    6c2c:	50 91 8f 07 	lds	r21, 0x078F
    6c30:	80 91 46 07 	lds	r24, 0x0746
    6c34:	90 91 47 07 	lds	r25, 0x0747
    6c38:	9c 01       	movw	r18, r24
    6c3a:	2e 5f       	subi	r18, 0xFE	; 254
    6c3c:	3f 4f       	sbci	r19, 0xFF	; 255
    6c3e:	ca 01       	movw	r24, r20
    6c40:	b9 01       	movw	r22, r18
    6c42:	0e 94 3d 18 	call	0x307a	; 0x307a <vListInsert>

                /* If the task entering the blocked state was placed at the head of the
                 * list of blocked tasks then xNextTaskUnblockTime needs to be updated
                 * too. */
                if( xTimeToWake < xNextTaskUnblockTime )
    6c46:	20 91 53 07 	lds	r18, 0x0753
    6c4a:	30 91 54 07 	lds	r19, 0x0754
    6c4e:	8b 81       	ldd	r24, Y+3	; 0x03
    6c50:	9c 81       	ldd	r25, Y+4	; 0x04
    6c52:	82 17       	cp	r24, r18
    6c54:	93 07       	cpc	r25, r19
    6c56:	30 f4       	brcc	.+12     	; 0x6c64 <prvAddCurrentTaskToDelayedList+0xba>
                {
                    xNextTaskUnblockTime = xTimeToWake;
    6c58:	8b 81       	ldd	r24, Y+3	; 0x03
    6c5a:	9c 81       	ldd	r25, Y+4	; 0x04
    6c5c:	90 93 54 07 	sts	0x0754, r25
    6c60:	80 93 53 07 	sts	0x0753, r24

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
    6c64:	27 96       	adiw	r28, 0x07	; 7
    6c66:	0f b6       	in	r0, 0x3f	; 63
    6c68:	f8 94       	cli
    6c6a:	de bf       	out	0x3e, r29	; 62
    6c6c:	0f be       	out	0x3f, r0	; 63
    6c6e:	cd bf       	out	0x3d, r28	; 61
    6c70:	cf 91       	pop	r28
    6c72:	df 91       	pop	r29
    6c74:	08 95       	ret

00006c76 <xTimerCreateTimerTask>:
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

    BaseType_t xTimerCreateTimerTask( void )
    {
    6c76:	ef 92       	push	r14
    6c78:	ff 92       	push	r15
    6c7a:	0f 93       	push	r16
    6c7c:	df 93       	push	r29
    6c7e:	cf 93       	push	r28
    6c80:	0f 92       	push	r0
    6c82:	cd b7       	in	r28, 0x3d	; 61
    6c84:	de b7       	in	r29, 0x3e	; 62
        BaseType_t xReturn = pdFAIL;
    6c86:	19 82       	std	Y+1, r1	; 0x01

        /* This function is called when the scheduler is started if
         * configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
         * timer service task has been created/initialised.  If timers have already
         * been created then the initialisation will already have been performed. */
        prvCheckForValidListAndQueue();
    6c88:	0e 94 fa 3a 	call	0x75f4	; 0x75f4 <prvCheckForValidListAndQueue>

        if( xTimerQueue != NULL )
    6c8c:	80 91 a4 07 	lds	r24, 0x07A4
    6c90:	90 91 a5 07 	lds	r25, 0x07A5
    6c94:	00 97       	sbiw	r24, 0x00	; 0
    6c96:	81 f0       	breq	.+32     	; 0x6cb8 <xTimerCreateTimerTask+0x42>
                        xReturn = pdPASS;
                    }
                }
            #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
                {
                    xReturn = xTaskCreate( prvTimerTask,
    6c98:	8c e8       	ldi	r24, 0x8C	; 140
    6c9a:	98 e3       	ldi	r25, 0x38	; 56
    6c9c:	28 e7       	ldi	r18, 0x78	; 120
    6c9e:	30 e0       	ldi	r19, 0x00	; 0
    6ca0:	e6 ea       	ldi	r30, 0xA6	; 166
    6ca2:	f7 e0       	ldi	r31, 0x07	; 7
    6ca4:	b9 01       	movw	r22, r18
    6ca6:	45 e5       	ldi	r20, 0x55	; 85
    6ca8:	50 e0       	ldi	r21, 0x00	; 0
    6caa:	20 e0       	ldi	r18, 0x00	; 0
    6cac:	30 e0       	ldi	r19, 0x00	; 0
    6cae:	03 e0       	ldi	r16, 0x03	; 3
    6cb0:	7f 01       	movw	r14, r30
    6cb2:	0e 94 4b 22 	call	0x4496	; 0x4496 <xTaskCreate>
    6cb6:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }

        configASSERT( xReturn );
        return xReturn;
    6cb8:	89 81       	ldd	r24, Y+1	; 0x01
    }
    6cba:	0f 90       	pop	r0
    6cbc:	cf 91       	pop	r28
    6cbe:	df 91       	pop	r29
    6cc0:	0f 91       	pop	r16
    6cc2:	ff 90       	pop	r15
    6cc4:	ef 90       	pop	r14
    6cc6:	08 95       	ret

00006cc8 <xTimerCreate>:
        TimerHandle_t xTimerCreate( const char * const pcTimerName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                                    const TickType_t xTimerPeriodInTicks,
                                    const UBaseType_t uxAutoReload,
                                    void * const pvTimerID,
                                    TimerCallbackFunction_t pxCallbackFunction )
        {
    6cc8:	ef 92       	push	r14
    6cca:	ff 92       	push	r15
    6ccc:	0f 93       	push	r16
    6cce:	1f 93       	push	r17
    6cd0:	df 93       	push	r29
    6cd2:	cf 93       	push	r28
    6cd4:	cd b7       	in	r28, 0x3d	; 61
    6cd6:	de b7       	in	r29, 0x3e	; 62
    6cd8:	2b 97       	sbiw	r28, 0x0b	; 11
    6cda:	0f b6       	in	r0, 0x3f	; 63
    6cdc:	f8 94       	cli
    6cde:	de bf       	out	0x3e, r29	; 62
    6ce0:	0f be       	out	0x3f, r0	; 63
    6ce2:	cd bf       	out	0x3d, r28	; 61
    6ce4:	9c 83       	std	Y+4, r25	; 0x04
    6ce6:	8b 83       	std	Y+3, r24	; 0x03
    6ce8:	7e 83       	std	Y+6, r23	; 0x06
    6cea:	6d 83       	std	Y+5, r22	; 0x05
    6cec:	4f 83       	std	Y+7, r20	; 0x07
    6cee:	39 87       	std	Y+9, r19	; 0x09
    6cf0:	28 87       	std	Y+8, r18	; 0x08
    6cf2:	1b 87       	std	Y+11, r17	; 0x0b
    6cf4:	0a 87       	std	Y+10, r16	; 0x0a
            Timer_t * pxNewTimer;

            pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
    6cf6:	83 e1       	ldi	r24, 0x13	; 19
    6cf8:	90 e0       	ldi	r25, 0x00	; 0
    6cfa:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <pvPortMalloc>
    6cfe:	9a 83       	std	Y+2, r25	; 0x02
    6d00:	89 83       	std	Y+1, r24	; 0x01

            if( pxNewTimer != NULL )
    6d02:	89 81       	ldd	r24, Y+1	; 0x01
    6d04:	9a 81       	ldd	r25, Y+2	; 0x02
    6d06:	00 97       	sbiw	r24, 0x00	; 0
    6d08:	99 f0       	breq	.+38     	; 0x6d30 <xTimerCreate+0x68>
            {
                /* Status is thus far zero as the timer is not created statically
                 * and has not been started.  The auto-reload bit may get set in
                 * prvInitialiseNewTimer. */
                pxNewTimer->ucStatus = 0x00;
    6d0a:	e9 81       	ldd	r30, Y+1	; 0x01
    6d0c:	fa 81       	ldd	r31, Y+2	; 0x02
    6d0e:	12 8a       	std	Z+18, r1	; 0x12
                prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
    6d10:	8b 81       	ldd	r24, Y+3	; 0x03
    6d12:	9c 81       	ldd	r25, Y+4	; 0x04
    6d14:	2d 81       	ldd	r18, Y+5	; 0x05
    6d16:	3e 81       	ldd	r19, Y+6	; 0x06
    6d18:	e8 85       	ldd	r30, Y+8	; 0x08
    6d1a:	f9 85       	ldd	r31, Y+9	; 0x09
    6d1c:	aa 85       	ldd	r26, Y+10	; 0x0a
    6d1e:	bb 85       	ldd	r27, Y+11	; 0x0b
    6d20:	e9 80       	ldd	r14, Y+1	; 0x01
    6d22:	fa 80       	ldd	r15, Y+2	; 0x02
    6d24:	b9 01       	movw	r22, r18
    6d26:	4f 81       	ldd	r20, Y+7	; 0x07
    6d28:	9f 01       	movw	r18, r30
    6d2a:	8d 01       	movw	r16, r26
    6d2c:	0e 94 a7 36 	call	0x6d4e	; 0x6d4e <prvInitialiseNewTimer>
            }

            return pxNewTimer;
    6d30:	89 81       	ldd	r24, Y+1	; 0x01
    6d32:	9a 81       	ldd	r25, Y+2	; 0x02
        }
    6d34:	2b 96       	adiw	r28, 0x0b	; 11
    6d36:	0f b6       	in	r0, 0x3f	; 63
    6d38:	f8 94       	cli
    6d3a:	de bf       	out	0x3e, r29	; 62
    6d3c:	0f be       	out	0x3f, r0	; 63
    6d3e:	cd bf       	out	0x3d, r28	; 61
    6d40:	cf 91       	pop	r28
    6d42:	df 91       	pop	r29
    6d44:	1f 91       	pop	r17
    6d46:	0f 91       	pop	r16
    6d48:	ff 90       	pop	r15
    6d4a:	ef 90       	pop	r14
    6d4c:	08 95       	ret

00006d4e <prvInitialiseNewTimer>:
                                       const TickType_t xTimerPeriodInTicks,
                                       const UBaseType_t uxAutoReload,
                                       void * const pvTimerID,
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer )
    {
    6d4e:	ef 92       	push	r14
    6d50:	ff 92       	push	r15
    6d52:	0f 93       	push	r16
    6d54:	1f 93       	push	r17
    6d56:	df 93       	push	r29
    6d58:	cf 93       	push	r28
    6d5a:	cd b7       	in	r28, 0x3d	; 61
    6d5c:	de b7       	in	r29, 0x3e	; 62
    6d5e:	2b 97       	sbiw	r28, 0x0b	; 11
    6d60:	0f b6       	in	r0, 0x3f	; 63
    6d62:	f8 94       	cli
    6d64:	de bf       	out	0x3e, r29	; 62
    6d66:	0f be       	out	0x3f, r0	; 63
    6d68:	cd bf       	out	0x3d, r28	; 61
    6d6a:	9a 83       	std	Y+2, r25	; 0x02
    6d6c:	89 83       	std	Y+1, r24	; 0x01
    6d6e:	7c 83       	std	Y+4, r23	; 0x04
    6d70:	6b 83       	std	Y+3, r22	; 0x03
    6d72:	4d 83       	std	Y+5, r20	; 0x05
    6d74:	3f 83       	std	Y+7, r19	; 0x07
    6d76:	2e 83       	std	Y+6, r18	; 0x06
    6d78:	19 87       	std	Y+9, r17	; 0x09
    6d7a:	08 87       	std	Y+8, r16	; 0x08
    6d7c:	fb 86       	std	Y+11, r15	; 0x0b
    6d7e:	ea 86       	std	Y+10, r14	; 0x0a
        /* 0 is not a valid value for xTimerPeriodInTicks. */
        configASSERT( ( xTimerPeriodInTicks > 0 ) );

        /* Ensure the infrastructure used by the timer service task has been
         * created/initialised. */
        prvCheckForValidListAndQueue();
    6d80:	0e 94 fa 3a 	call	0x75f4	; 0x75f4 <prvCheckForValidListAndQueue>

        /* Initialise the timer structure members using the function
         * parameters. */
        pxNewTimer->pcTimerName = pcTimerName;
    6d84:	ea 85       	ldd	r30, Y+10	; 0x0a
    6d86:	fb 85       	ldd	r31, Y+11	; 0x0b
    6d88:	89 81       	ldd	r24, Y+1	; 0x01
    6d8a:	9a 81       	ldd	r25, Y+2	; 0x02
    6d8c:	91 83       	std	Z+1, r25	; 0x01
    6d8e:	80 83       	st	Z, r24
        pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    6d90:	ea 85       	ldd	r30, Y+10	; 0x0a
    6d92:	fb 85       	ldd	r31, Y+11	; 0x0b
    6d94:	8b 81       	ldd	r24, Y+3	; 0x03
    6d96:	9c 81       	ldd	r25, Y+4	; 0x04
    6d98:	95 87       	std	Z+13, r25	; 0x0d
    6d9a:	84 87       	std	Z+12, r24	; 0x0c
        pxNewTimer->pvTimerID = pvTimerID;
    6d9c:	ea 85       	ldd	r30, Y+10	; 0x0a
    6d9e:	fb 85       	ldd	r31, Y+11	; 0x0b
    6da0:	8e 81       	ldd	r24, Y+6	; 0x06
    6da2:	9f 81       	ldd	r25, Y+7	; 0x07
    6da4:	97 87       	std	Z+15, r25	; 0x0f
    6da6:	86 87       	std	Z+14, r24	; 0x0e
        pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    6da8:	ea 85       	ldd	r30, Y+10	; 0x0a
    6daa:	fb 85       	ldd	r31, Y+11	; 0x0b
    6dac:	88 85       	ldd	r24, Y+8	; 0x08
    6dae:	99 85       	ldd	r25, Y+9	; 0x09
    6db0:	91 8b       	std	Z+17, r25	; 0x11
    6db2:	80 8b       	std	Z+16, r24	; 0x10
        vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    6db4:	8a 85       	ldd	r24, Y+10	; 0x0a
    6db6:	9b 85       	ldd	r25, Y+11	; 0x0b
    6db8:	02 96       	adiw	r24, 0x02	; 2
    6dba:	0e 94 e9 17 	call	0x2fd2	; 0x2fd2 <vListInitialiseItem>

        if( uxAutoReload != pdFALSE )
    6dbe:	8d 81       	ldd	r24, Y+5	; 0x05
    6dc0:	88 23       	and	r24, r24
    6dc2:	39 f0       	breq	.+14     	; 0x6dd2 <prvInitialiseNewTimer+0x84>
        {
            pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    6dc4:	ea 85       	ldd	r30, Y+10	; 0x0a
    6dc6:	fb 85       	ldd	r31, Y+11	; 0x0b
    6dc8:	82 89       	ldd	r24, Z+18	; 0x12
    6dca:	84 60       	ori	r24, 0x04	; 4
    6dcc:	ea 85       	ldd	r30, Y+10	; 0x0a
    6dce:	fb 85       	ldd	r31, Y+11	; 0x0b
    6dd0:	82 8b       	std	Z+18, r24	; 0x12
        }

        traceTIMER_CREATE( pxNewTimer );
    }
    6dd2:	2b 96       	adiw	r28, 0x0b	; 11
    6dd4:	0f b6       	in	r0, 0x3f	; 63
    6dd6:	f8 94       	cli
    6dd8:	de bf       	out	0x3e, r29	; 62
    6dda:	0f be       	out	0x3f, r0	; 63
    6ddc:	cd bf       	out	0x3d, r28	; 61
    6dde:	cf 91       	pop	r28
    6de0:	df 91       	pop	r29
    6de2:	1f 91       	pop	r17
    6de4:	0f 91       	pop	r16
    6de6:	ff 90       	pop	r15
    6de8:	ef 90       	pop	r14
    6dea:	08 95       	ret

00006dec <xTimerGenericCommand>:
    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer,
                                     const BaseType_t xCommandID,
                                     const TickType_t xOptionalValue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const TickType_t xTicksToWait )
    {
    6dec:	0f 93       	push	r16
    6dee:	1f 93       	push	r17
    6df0:	df 93       	push	r29
    6df2:	cf 93       	push	r28
    6df4:	cd b7       	in	r28, 0x3d	; 61
    6df6:	de b7       	in	r29, 0x3e	; 62
    6df8:	2f 97       	sbiw	r28, 0x0f	; 15
    6dfa:	0f b6       	in	r0, 0x3f	; 63
    6dfc:	f8 94       	cli
    6dfe:	de bf       	out	0x3e, r29	; 62
    6e00:	0f be       	out	0x3f, r0	; 63
    6e02:	cd bf       	out	0x3d, r28	; 61
    6e04:	98 87       	std	Y+8, r25	; 0x08
    6e06:	8f 83       	std	Y+7, r24	; 0x07
    6e08:	69 87       	std	Y+9, r22	; 0x09
    6e0a:	5b 87       	std	Y+11, r21	; 0x0b
    6e0c:	4a 87       	std	Y+10, r20	; 0x0a
    6e0e:	3d 87       	std	Y+13, r19	; 0x0d
    6e10:	2c 87       	std	Y+12, r18	; 0x0c
    6e12:	1f 87       	std	Y+15, r17	; 0x0f
    6e14:	0e 87       	std	Y+14, r16	; 0x0e
        BaseType_t xReturn = pdFAIL;
    6e16:	19 82       	std	Y+1, r1	; 0x01

        configASSERT( xTimer );

        /* Send a message to the timer service task to perform a particular action
         * on a particular timer definition. */
        if( xTimerQueue != NULL )
    6e18:	80 91 a4 07 	lds	r24, 0x07A4
    6e1c:	90 91 a5 07 	lds	r25, 0x07A5
    6e20:	00 97       	sbiw	r24, 0x00	; 0
    6e22:	e9 f1       	breq	.+122    	; 0x6e9e <xTimerGenericCommand+0xb2>
        {
            /* Send a command to the timer service task to start the xTimer timer. */
            xMessage.xMessageID = xCommandID;
    6e24:	89 85       	ldd	r24, Y+9	; 0x09
    6e26:	8a 83       	std	Y+2, r24	; 0x02
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    6e28:	8a 85       	ldd	r24, Y+10	; 0x0a
    6e2a:	9b 85       	ldd	r25, Y+11	; 0x0b
    6e2c:	9c 83       	std	Y+4, r25	; 0x04
    6e2e:	8b 83       	std	Y+3, r24	; 0x03
            xMessage.u.xTimerParameters.pxTimer = xTimer;
    6e30:	8f 81       	ldd	r24, Y+7	; 0x07
    6e32:	98 85       	ldd	r25, Y+8	; 0x08
    6e34:	9e 83       	std	Y+6, r25	; 0x06
    6e36:	8d 83       	std	Y+5, r24	; 0x05

            if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    6e38:	89 85       	ldd	r24, Y+9	; 0x09
    6e3a:	86 30       	cpi	r24, 0x06	; 6
    6e3c:	14 f5       	brge	.+68     	; 0x6e82 <xTimerGenericCommand+0x96>
            {
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    6e3e:	0e 94 10 2e 	call	0x5c20	; 0x5c20 <xTaskGetSchedulerState>
    6e42:	82 30       	cpi	r24, 0x02	; 2
    6e44:	79 f4       	brne	.+30     	; 0x6e64 <xTimerGenericCommand+0x78>
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    6e46:	80 91 a4 07 	lds	r24, 0x07A4
    6e4a:	90 91 a5 07 	lds	r25, 0x07A5
    6e4e:	9e 01       	movw	r18, r28
    6e50:	2e 5f       	subi	r18, 0xFE	; 254
    6e52:	3f 4f       	sbci	r19, 0xFF	; 255
    6e54:	4e 85       	ldd	r20, Y+14	; 0x0e
    6e56:	5f 85       	ldd	r21, Y+15	; 0x0f
    6e58:	b9 01       	movw	r22, r18
    6e5a:	20 e0       	ldi	r18, 0x00	; 0
    6e5c:	0e 94 4f 1a 	call	0x349e	; 0x349e <xQueueGenericSend>
    6e60:	89 83       	std	Y+1, r24	; 0x01
    6e62:	1d c0       	rjmp	.+58     	; 0x6e9e <xTimerGenericCommand+0xb2>
                }
                else
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    6e64:	80 91 a4 07 	lds	r24, 0x07A4
    6e68:	90 91 a5 07 	lds	r25, 0x07A5
    6e6c:	9e 01       	movw	r18, r28
    6e6e:	2e 5f       	subi	r18, 0xFE	; 254
    6e70:	3f 4f       	sbci	r19, 0xFF	; 255
    6e72:	b9 01       	movw	r22, r18
    6e74:	40 e0       	ldi	r20, 0x00	; 0
    6e76:	50 e0       	ldi	r21, 0x00	; 0
    6e78:	20 e0       	ldi	r18, 0x00	; 0
    6e7a:	0e 94 4f 1a 	call	0x349e	; 0x349e <xQueueGenericSend>
    6e7e:	89 83       	std	Y+1, r24	; 0x01
    6e80:	0e c0       	rjmp	.+28     	; 0x6e9e <xTimerGenericCommand+0xb2>
                }
            }
            else
            {
                xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    6e82:	80 91 a4 07 	lds	r24, 0x07A4
    6e86:	90 91 a5 07 	lds	r25, 0x07A5
    6e8a:	9e 01       	movw	r18, r28
    6e8c:	2e 5f       	subi	r18, 0xFE	; 254
    6e8e:	3f 4f       	sbci	r19, 0xFF	; 255
    6e90:	4c 85       	ldd	r20, Y+12	; 0x0c
    6e92:	5d 85       	ldd	r21, Y+13	; 0x0d
    6e94:	b9 01       	movw	r22, r18
    6e96:	20 e0       	ldi	r18, 0x00	; 0
    6e98:	0e 94 fb 1a 	call	0x35f6	; 0x35f6 <xQueueGenericSendFromISR>
    6e9c:	89 83       	std	Y+1, r24	; 0x01
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    6e9e:	89 81       	ldd	r24, Y+1	; 0x01
    }
    6ea0:	2f 96       	adiw	r28, 0x0f	; 15
    6ea2:	0f b6       	in	r0, 0x3f	; 63
    6ea4:	f8 94       	cli
    6ea6:	de bf       	out	0x3e, r29	; 62
    6ea8:	0f be       	out	0x3f, r0	; 63
    6eaa:	cd bf       	out	0x3d, r28	; 61
    6eac:	cf 91       	pop	r28
    6eae:	df 91       	pop	r29
    6eb0:	1f 91       	pop	r17
    6eb2:	0f 91       	pop	r16
    6eb4:	08 95       	ret

00006eb6 <xTimerGetTimerDaemonTaskHandle>:
/*-----------------------------------------------------------*/

    TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
    {
    6eb6:	df 93       	push	r29
    6eb8:	cf 93       	push	r28
    6eba:	cd b7       	in	r28, 0x3d	; 61
    6ebc:	de b7       	in	r29, 0x3e	; 62
        /* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
         * started, then xTimerTaskHandle will be NULL. */
        configASSERT( ( xTimerTaskHandle != NULL ) );
        return xTimerTaskHandle;
    6ebe:	80 91 a6 07 	lds	r24, 0x07A6
    6ec2:	90 91 a7 07 	lds	r25, 0x07A7
    }
    6ec6:	cf 91       	pop	r28
    6ec8:	df 91       	pop	r29
    6eca:	08 95       	ret

00006ecc <xTimerGetPeriod>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
    {
    6ecc:	df 93       	push	r29
    6ece:	cf 93       	push	r28
    6ed0:	00 d0       	rcall	.+0      	; 0x6ed2 <xTimerGetPeriod+0x6>
    6ed2:	00 d0       	rcall	.+0      	; 0x6ed4 <xTimerGetPeriod+0x8>
    6ed4:	cd b7       	in	r28, 0x3d	; 61
    6ed6:	de b7       	in	r29, 0x3e	; 62
    6ed8:	9c 83       	std	Y+4, r25	; 0x04
    6eda:	8b 83       	std	Y+3, r24	; 0x03
        Timer_t * pxTimer = xTimer;
    6edc:	8b 81       	ldd	r24, Y+3	; 0x03
    6ede:	9c 81       	ldd	r25, Y+4	; 0x04
    6ee0:	9a 83       	std	Y+2, r25	; 0x02
    6ee2:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        return pxTimer->xTimerPeriodInTicks;
    6ee4:	e9 81       	ldd	r30, Y+1	; 0x01
    6ee6:	fa 81       	ldd	r31, Y+2	; 0x02
    6ee8:	84 85       	ldd	r24, Z+12	; 0x0c
    6eea:	95 85       	ldd	r25, Z+13	; 0x0d
    }
    6eec:	0f 90       	pop	r0
    6eee:	0f 90       	pop	r0
    6ef0:	0f 90       	pop	r0
    6ef2:	0f 90       	pop	r0
    6ef4:	cf 91       	pop	r28
    6ef6:	df 91       	pop	r29
    6ef8:	08 95       	ret

00006efa <vTimerSetReloadMode>:
/*-----------------------------------------------------------*/

    void vTimerSetReloadMode( TimerHandle_t xTimer,
                              const UBaseType_t uxAutoReload )
    {
    6efa:	df 93       	push	r29
    6efc:	cf 93       	push	r28
    6efe:	00 d0       	rcall	.+0      	; 0x6f00 <vTimerSetReloadMode+0x6>
    6f00:	00 d0       	rcall	.+0      	; 0x6f02 <vTimerSetReloadMode+0x8>
    6f02:	0f 92       	push	r0
    6f04:	cd b7       	in	r28, 0x3d	; 61
    6f06:	de b7       	in	r29, 0x3e	; 62
    6f08:	9c 83       	std	Y+4, r25	; 0x04
    6f0a:	8b 83       	std	Y+3, r24	; 0x03
    6f0c:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * pxTimer = xTimer;
    6f0e:	8b 81       	ldd	r24, Y+3	; 0x03
    6f10:	9c 81       	ldd	r25, Y+4	; 0x04
    6f12:	9a 83       	std	Y+2, r25	; 0x02
    6f14:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        taskENTER_CRITICAL();
    6f16:	0f b6       	in	r0, 0x3f	; 63
    6f18:	f8 94       	cli
    6f1a:	0f 92       	push	r0
        {
            if( uxAutoReload != pdFALSE )
    6f1c:	8d 81       	ldd	r24, Y+5	; 0x05
    6f1e:	88 23       	and	r24, r24
    6f20:	41 f0       	breq	.+16     	; 0x6f32 <vTimerSetReloadMode+0x38>
            {
                pxTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    6f22:	e9 81       	ldd	r30, Y+1	; 0x01
    6f24:	fa 81       	ldd	r31, Y+2	; 0x02
    6f26:	82 89       	ldd	r24, Z+18	; 0x12
    6f28:	84 60       	ori	r24, 0x04	; 4
    6f2a:	e9 81       	ldd	r30, Y+1	; 0x01
    6f2c:	fa 81       	ldd	r31, Y+2	; 0x02
    6f2e:	82 8b       	std	Z+18, r24	; 0x12
    6f30:	07 c0       	rjmp	.+14     	; 0x6f40 <vTimerSetReloadMode+0x46>
            }
            else
            {
                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_AUTORELOAD );
    6f32:	e9 81       	ldd	r30, Y+1	; 0x01
    6f34:	fa 81       	ldd	r31, Y+2	; 0x02
    6f36:	82 89       	ldd	r24, Z+18	; 0x12
    6f38:	8b 7f       	andi	r24, 0xFB	; 251
    6f3a:	e9 81       	ldd	r30, Y+1	; 0x01
    6f3c:	fa 81       	ldd	r31, Y+2	; 0x02
    6f3e:	82 8b       	std	Z+18, r24	; 0x12
            }
        }
        taskEXIT_CRITICAL();
    6f40:	0f 90       	pop	r0
    6f42:	0f be       	out	0x3f, r0	; 63
    }
    6f44:	0f 90       	pop	r0
    6f46:	0f 90       	pop	r0
    6f48:	0f 90       	pop	r0
    6f4a:	0f 90       	pop	r0
    6f4c:	0f 90       	pop	r0
    6f4e:	cf 91       	pop	r28
    6f50:	df 91       	pop	r29
    6f52:	08 95       	ret

00006f54 <uxTimerGetReloadMode>:
/*-----------------------------------------------------------*/

    UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer )
    {
    6f54:	df 93       	push	r29
    6f56:	cf 93       	push	r28
    6f58:	00 d0       	rcall	.+0      	; 0x6f5a <uxTimerGetReloadMode+0x6>
    6f5a:	00 d0       	rcall	.+0      	; 0x6f5c <uxTimerGetReloadMode+0x8>
    6f5c:	0f 92       	push	r0
    6f5e:	cd b7       	in	r28, 0x3d	; 61
    6f60:	de b7       	in	r29, 0x3e	; 62
    6f62:	9d 83       	std	Y+5, r25	; 0x05
    6f64:	8c 83       	std	Y+4, r24	; 0x04
        Timer_t * pxTimer = xTimer;
    6f66:	8c 81       	ldd	r24, Y+4	; 0x04
    6f68:	9d 81       	ldd	r25, Y+5	; 0x05
    6f6a:	9b 83       	std	Y+3, r25	; 0x03
    6f6c:	8a 83       	std	Y+2, r24	; 0x02
        UBaseType_t uxReturn;

        configASSERT( xTimer );
        taskENTER_CRITICAL();
    6f6e:	0f b6       	in	r0, 0x3f	; 63
    6f70:	f8 94       	cli
    6f72:	0f 92       	push	r0
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0 )
    6f74:	ea 81       	ldd	r30, Y+2	; 0x02
    6f76:	fb 81       	ldd	r31, Y+3	; 0x03
    6f78:	82 89       	ldd	r24, Z+18	; 0x12
    6f7a:	88 2f       	mov	r24, r24
    6f7c:	90 e0       	ldi	r25, 0x00	; 0
    6f7e:	84 70       	andi	r24, 0x04	; 4
    6f80:	90 70       	andi	r25, 0x00	; 0
    6f82:	00 97       	sbiw	r24, 0x00	; 0
    6f84:	11 f4       	brne	.+4      	; 0x6f8a <uxTimerGetReloadMode+0x36>
            {
                /* Not an auto-reload timer. */
                uxReturn = ( UBaseType_t ) pdFALSE;
    6f86:	19 82       	std	Y+1, r1	; 0x01
    6f88:	02 c0       	rjmp	.+4      	; 0x6f8e <uxTimerGetReloadMode+0x3a>
            }
            else
            {
                /* Is an auto-reload timer. */
                uxReturn = ( UBaseType_t ) pdTRUE;
    6f8a:	81 e0       	ldi	r24, 0x01	; 1
    6f8c:	89 83       	std	Y+1, r24	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    6f8e:	0f 90       	pop	r0
    6f90:	0f be       	out	0x3f, r0	; 63

        return uxReturn;
    6f92:	89 81       	ldd	r24, Y+1	; 0x01
    }
    6f94:	0f 90       	pop	r0
    6f96:	0f 90       	pop	r0
    6f98:	0f 90       	pop	r0
    6f9a:	0f 90       	pop	r0
    6f9c:	0f 90       	pop	r0
    6f9e:	cf 91       	pop	r28
    6fa0:	df 91       	pop	r29
    6fa2:	08 95       	ret

00006fa4 <xTimerGetExpiryTime>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
    {
    6fa4:	df 93       	push	r29
    6fa6:	cf 93       	push	r28
    6fa8:	00 d0       	rcall	.+0      	; 0x6faa <xTimerGetExpiryTime+0x6>
    6faa:	00 d0       	rcall	.+0      	; 0x6fac <xTimerGetExpiryTime+0x8>
    6fac:	00 d0       	rcall	.+0      	; 0x6fae <xTimerGetExpiryTime+0xa>
    6fae:	cd b7       	in	r28, 0x3d	; 61
    6fb0:	de b7       	in	r29, 0x3e	; 62
    6fb2:	9e 83       	std	Y+6, r25	; 0x06
    6fb4:	8d 83       	std	Y+5, r24	; 0x05
        Timer_t * pxTimer = xTimer;
    6fb6:	8d 81       	ldd	r24, Y+5	; 0x05
    6fb8:	9e 81       	ldd	r25, Y+6	; 0x06
    6fba:	9c 83       	std	Y+4, r25	; 0x04
    6fbc:	8b 83       	std	Y+3, r24	; 0x03
        TickType_t xReturn;

        configASSERT( xTimer );
        xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
    6fbe:	eb 81       	ldd	r30, Y+3	; 0x03
    6fc0:	fc 81       	ldd	r31, Y+4	; 0x04
    6fc2:	82 81       	ldd	r24, Z+2	; 0x02
    6fc4:	93 81       	ldd	r25, Z+3	; 0x03
    6fc6:	9a 83       	std	Y+2, r25	; 0x02
    6fc8:	89 83       	std	Y+1, r24	; 0x01
        return xReturn;
    6fca:	89 81       	ldd	r24, Y+1	; 0x01
    6fcc:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    6fce:	26 96       	adiw	r28, 0x06	; 6
    6fd0:	0f b6       	in	r0, 0x3f	; 63
    6fd2:	f8 94       	cli
    6fd4:	de bf       	out	0x3e, r29	; 62
    6fd6:	0f be       	out	0x3f, r0	; 63
    6fd8:	cd bf       	out	0x3d, r28	; 61
    6fda:	cf 91       	pop	r28
    6fdc:	df 91       	pop	r29
    6fde:	08 95       	ret

00006fe0 <pcTimerGetName>:
/*-----------------------------------------------------------*/

    const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    {
    6fe0:	df 93       	push	r29
    6fe2:	cf 93       	push	r28
    6fe4:	00 d0       	rcall	.+0      	; 0x6fe6 <pcTimerGetName+0x6>
    6fe6:	00 d0       	rcall	.+0      	; 0x6fe8 <pcTimerGetName+0x8>
    6fe8:	cd b7       	in	r28, 0x3d	; 61
    6fea:	de b7       	in	r29, 0x3e	; 62
    6fec:	9c 83       	std	Y+4, r25	; 0x04
    6fee:	8b 83       	std	Y+3, r24	; 0x03
        Timer_t * pxTimer = xTimer;
    6ff0:	8b 81       	ldd	r24, Y+3	; 0x03
    6ff2:	9c 81       	ldd	r25, Y+4	; 0x04
    6ff4:	9a 83       	std	Y+2, r25	; 0x02
    6ff6:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        return pxTimer->pcTimerName;
    6ff8:	e9 81       	ldd	r30, Y+1	; 0x01
    6ffa:	fa 81       	ldd	r31, Y+2	; 0x02
    6ffc:	80 81       	ld	r24, Z
    6ffe:	91 81       	ldd	r25, Z+1	; 0x01
    }
    7000:	0f 90       	pop	r0
    7002:	0f 90       	pop	r0
    7004:	0f 90       	pop	r0
    7006:	0f 90       	pop	r0
    7008:	cf 91       	pop	r28
    700a:	df 91       	pop	r29
    700c:	08 95       	ret

0000700e <prvReloadTimer>:
/*-----------------------------------------------------------*/

    static void prvReloadTimer( Timer_t * const pxTimer,
                                TickType_t xExpiredTime,
                                const TickType_t xTimeNow )
    {
    700e:	df 93       	push	r29
    7010:	cf 93       	push	r28
    7012:	00 d0       	rcall	.+0      	; 0x7014 <prvReloadTimer+0x6>
    7014:	00 d0       	rcall	.+0      	; 0x7016 <prvReloadTimer+0x8>
    7016:	00 d0       	rcall	.+0      	; 0x7018 <prvReloadTimer+0xa>
    7018:	cd b7       	in	r28, 0x3d	; 61
    701a:	de b7       	in	r29, 0x3e	; 62
    701c:	9a 83       	std	Y+2, r25	; 0x02
    701e:	89 83       	std	Y+1, r24	; 0x01
    7020:	7c 83       	std	Y+4, r23	; 0x04
    7022:	6b 83       	std	Y+3, r22	; 0x03
    7024:	5e 83       	std	Y+6, r21	; 0x06
    7026:	4d 83       	std	Y+5, r20	; 0x05
    7028:	12 c0       	rjmp	.+36     	; 0x704e <prvReloadTimer+0x40>
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
        {
            /* Advance the expiry time. */
            xExpiredTime += pxTimer->xTimerPeriodInTicks;
    702a:	e9 81       	ldd	r30, Y+1	; 0x01
    702c:	fa 81       	ldd	r31, Y+2	; 0x02
    702e:	24 85       	ldd	r18, Z+12	; 0x0c
    7030:	35 85       	ldd	r19, Z+13	; 0x0d
    7032:	8b 81       	ldd	r24, Y+3	; 0x03
    7034:	9c 81       	ldd	r25, Y+4	; 0x04
    7036:	82 0f       	add	r24, r18
    7038:	93 1f       	adc	r25, r19
    703a:	9c 83       	std	Y+4, r25	; 0x04
    703c:	8b 83       	std	Y+3, r24	; 0x03

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    703e:	e9 81       	ldd	r30, Y+1	; 0x01
    7040:	fa 81       	ldd	r31, Y+2	; 0x02
    7042:	00 88       	ldd	r0, Z+16	; 0x10
    7044:	f1 89       	ldd	r31, Z+17	; 0x11
    7046:	e0 2d       	mov	r30, r0
    7048:	89 81       	ldd	r24, Y+1	; 0x01
    704a:	9a 81       	ldd	r25, Y+2	; 0x02
    704c:	09 95       	icall
                                const TickType_t xTimeNow )
    {
        /* Insert the timer into the appropriate list for the next expiry time.
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
    704e:	e9 81       	ldd	r30, Y+1	; 0x01
    7050:	fa 81       	ldd	r31, Y+2	; 0x02
    7052:	24 85       	ldd	r18, Z+12	; 0x0c
    7054:	35 85       	ldd	r19, Z+13	; 0x0d
    7056:	8b 81       	ldd	r24, Y+3	; 0x03
    7058:	9c 81       	ldd	r25, Y+4	; 0x04
    705a:	a9 01       	movw	r20, r18
    705c:	48 0f       	add	r20, r24
    705e:	59 1f       	adc	r21, r25
    7060:	89 81       	ldd	r24, Y+1	; 0x01
    7062:	9a 81       	ldd	r25, Y+2	; 0x02
    7064:	2d 81       	ldd	r18, Y+5	; 0x05
    7066:	3e 81       	ldd	r19, Y+6	; 0x06
    7068:	eb 81       	ldd	r30, Y+3	; 0x03
    706a:	fc 81       	ldd	r31, Y+4	; 0x04
    706c:	ba 01       	movw	r22, r20
    706e:	a9 01       	movw	r20, r18
    7070:	9f 01       	movw	r18, r30
    7072:	0e 94 5d 39 	call	0x72ba	; 0x72ba <prvInsertTimerInActiveList>
    7076:	88 23       	and	r24, r24
    7078:	c1 f6       	brne	.-80     	; 0x702a <prvReloadTimer+0x1c>

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
        }
    }
    707a:	26 96       	adiw	r28, 0x06	; 6
    707c:	0f b6       	in	r0, 0x3f	; 63
    707e:	f8 94       	cli
    7080:	de bf       	out	0x3e, r29	; 62
    7082:	0f be       	out	0x3f, r0	; 63
    7084:	cd bf       	out	0x3d, r28	; 61
    7086:	cf 91       	pop	r28
    7088:	df 91       	pop	r29
    708a:	08 95       	ret

0000708c <prvProcessExpiredTimer>:
/*-----------------------------------------------------------*/

    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,
                                        const TickType_t xTimeNow )
    {
    708c:	df 93       	push	r29
    708e:	cf 93       	push	r28
    7090:	00 d0       	rcall	.+0      	; 0x7092 <prvProcessExpiredTimer+0x6>
    7092:	00 d0       	rcall	.+0      	; 0x7094 <prvProcessExpiredTimer+0x8>
    7094:	00 d0       	rcall	.+0      	; 0x7096 <prvProcessExpiredTimer+0xa>
    7096:	cd b7       	in	r28, 0x3d	; 61
    7098:	de b7       	in	r29, 0x3e	; 62
    709a:	9c 83       	std	Y+4, r25	; 0x04
    709c:	8b 83       	std	Y+3, r24	; 0x03
    709e:	7e 83       	std	Y+6, r23	; 0x06
    70a0:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    70a2:	e0 91 bc 07 	lds	r30, 0x07BC
    70a6:	f0 91 bd 07 	lds	r31, 0x07BD
    70aa:	05 80       	ldd	r0, Z+5	; 0x05
    70ac:	f6 81       	ldd	r31, Z+6	; 0x06
    70ae:	e0 2d       	mov	r30, r0
    70b0:	86 81       	ldd	r24, Z+6	; 0x06
    70b2:	97 81       	ldd	r25, Z+7	; 0x07
    70b4:	9a 83       	std	Y+2, r25	; 0x02
    70b6:	89 83       	std	Y+1, r24	; 0x01

        /* Remove the timer from the list of active timers.  A check has already
         * been performed to ensure the list is not empty. */

        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    70b8:	89 81       	ldd	r24, Y+1	; 0x01
    70ba:	9a 81       	ldd	r25, Y+2	; 0x02
    70bc:	02 96       	adiw	r24, 0x02	; 2
    70be:	0e 94 a9 18 	call	0x3152	; 0x3152 <uxListRemove>

        /* If the timer is an auto-reload timer then calculate the next
         * expiry time and re-insert the timer in the list of active timers. */
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    70c2:	e9 81       	ldd	r30, Y+1	; 0x01
    70c4:	fa 81       	ldd	r31, Y+2	; 0x02
    70c6:	82 89       	ldd	r24, Z+18	; 0x12
    70c8:	88 2f       	mov	r24, r24
    70ca:	90 e0       	ldi	r25, 0x00	; 0
    70cc:	84 70       	andi	r24, 0x04	; 4
    70ce:	90 70       	andi	r25, 0x00	; 0
    70d0:	00 97       	sbiw	r24, 0x00	; 0
    70d2:	51 f0       	breq	.+20     	; 0x70e8 <prvProcessExpiredTimer+0x5c>
        {
            prvReloadTimer( pxTimer, xNextExpireTime, xTimeNow );
    70d4:	89 81       	ldd	r24, Y+1	; 0x01
    70d6:	9a 81       	ldd	r25, Y+2	; 0x02
    70d8:	2b 81       	ldd	r18, Y+3	; 0x03
    70da:	3c 81       	ldd	r19, Y+4	; 0x04
    70dc:	4d 81       	ldd	r20, Y+5	; 0x05
    70de:	5e 81       	ldd	r21, Y+6	; 0x06
    70e0:	b9 01       	movw	r22, r18
    70e2:	0e 94 07 38 	call	0x700e	; 0x700e <prvReloadTimer>
    70e6:	07 c0       	rjmp	.+14     	; 0x70f6 <prvProcessExpiredTimer+0x6a>
        }
        else
        {
            pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    70e8:	e9 81       	ldd	r30, Y+1	; 0x01
    70ea:	fa 81       	ldd	r31, Y+2	; 0x02
    70ec:	82 89       	ldd	r24, Z+18	; 0x12
    70ee:	8e 7f       	andi	r24, 0xFE	; 254
    70f0:	e9 81       	ldd	r30, Y+1	; 0x01
    70f2:	fa 81       	ldd	r31, Y+2	; 0x02
    70f4:	82 8b       	std	Z+18, r24	; 0x12
        }

        /* Call the timer callback. */
        traceTIMER_EXPIRED( pxTimer );
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    70f6:	e9 81       	ldd	r30, Y+1	; 0x01
    70f8:	fa 81       	ldd	r31, Y+2	; 0x02
    70fa:	00 88       	ldd	r0, Z+16	; 0x10
    70fc:	f1 89       	ldd	r31, Z+17	; 0x11
    70fe:	e0 2d       	mov	r30, r0
    7100:	89 81       	ldd	r24, Y+1	; 0x01
    7102:	9a 81       	ldd	r25, Y+2	; 0x02
    7104:	09 95       	icall
    }
    7106:	26 96       	adiw	r28, 0x06	; 6
    7108:	0f b6       	in	r0, 0x3f	; 63
    710a:	f8 94       	cli
    710c:	de bf       	out	0x3e, r29	; 62
    710e:	0f be       	out	0x3f, r0	; 63
    7110:	cd bf       	out	0x3d, r28	; 61
    7112:	cf 91       	pop	r28
    7114:	df 91       	pop	r29
    7116:	08 95       	ret

00007118 <prvTimerTask>:
/*-----------------------------------------------------------*/

    static portTASK_FUNCTION( prvTimerTask, pvParameters )
    {
    7118:	df 93       	push	r29
    711a:	cf 93       	push	r28
    711c:	00 d0       	rcall	.+0      	; 0x711e <prvTimerTask+0x6>
    711e:	00 d0       	rcall	.+0      	; 0x7120 <prvTimerTask+0x8>
    7120:	0f 92       	push	r0
    7122:	cd b7       	in	r28, 0x3d	; 61
    7124:	de b7       	in	r29, 0x3e	; 62
    7126:	9d 83       	std	Y+5, r25	; 0x05
    7128:	8c 83       	std	Y+4, r24	; 0x04

        for( ; ; )
        {
            /* Query the timers list to see if it contains any timers, and if so,
             * obtain the time at which the next timer will expire. */
            xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    712a:	ce 01       	movw	r24, r28
    712c:	03 96       	adiw	r24, 0x03	; 3
    712e:	0e 94 fb 38 	call	0x71f6	; 0x71f6 <prvGetNextExpireTime>
    7132:	9a 83       	std	Y+2, r25	; 0x02
    7134:	89 83       	std	Y+1, r24	; 0x01

            /* If a timer has expired, process it.  Otherwise, block this task
             * until either a timer does expire, or a command is received. */
            prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    7136:	2b 81       	ldd	r18, Y+3	; 0x03
    7138:	89 81       	ldd	r24, Y+1	; 0x01
    713a:	9a 81       	ldd	r25, Y+2	; 0x02
    713c:	62 2f       	mov	r22, r18
    713e:	0e 94 a4 38 	call	0x7148	; 0x7148 <prvProcessTimerOrBlockTask>

            /* Empty the command queue. */
            prvProcessReceivedCommands();
    7142:	0e 94 c5 39 	call	0x738a	; 0x738a <prvProcessReceivedCommands>
    7146:	f1 cf       	rjmp	.-30     	; 0x712a <prvTimerTask+0x12>

00007148 <prvProcessTimerOrBlockTask>:
    }
/*-----------------------------------------------------------*/

    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime,
                                            BaseType_t xListWasEmpty )
    {
    7148:	df 93       	push	r29
    714a:	cf 93       	push	r28
    714c:	00 d0       	rcall	.+0      	; 0x714e <prvProcessTimerOrBlockTask+0x6>
    714e:	00 d0       	rcall	.+0      	; 0x7150 <prvProcessTimerOrBlockTask+0x8>
    7150:	00 d0       	rcall	.+0      	; 0x7152 <prvProcessTimerOrBlockTask+0xa>
    7152:	cd b7       	in	r28, 0x3d	; 61
    7154:	de b7       	in	r29, 0x3e	; 62
    7156:	9d 83       	std	Y+5, r25	; 0x05
    7158:	8c 83       	std	Y+4, r24	; 0x04
    715a:	6e 83       	std	Y+6, r22	; 0x06
        TickType_t xTimeNow;
        BaseType_t xTimerListsWereSwitched;

        vTaskSuspendAll();
    715c:	0e 94 9c 25 	call	0x4b38	; 0x4b38 <vTaskSuspendAll>
            /* Obtain the time now to make an assessment as to whether the timer
             * has expired or not.  If obtaining the time causes the lists to switch
             * then don't process this timer as any timers that remained in the list
             * when the lists were switched will have been processed within the
             * prvSampleTimeNow() function. */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    7160:	ce 01       	movw	r24, r28
    7162:	03 96       	adiw	r24, 0x03	; 3
    7164:	0e 94 2f 39 	call	0x725e	; 0x725e <prvSampleTimeNow>
    7168:	9a 83       	std	Y+2, r25	; 0x02
    716a:	89 83       	std	Y+1, r24	; 0x01

            if( xTimerListsWereSwitched == pdFALSE )
    716c:	8b 81       	ldd	r24, Y+3	; 0x03
    716e:	88 23       	and	r24, r24
    7170:	b9 f5       	brne	.+110    	; 0x71e0 <prvProcessTimerOrBlockTask+0x98>
            {
                /* The tick count has not overflowed, has the timer expired? */
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    7172:	8e 81       	ldd	r24, Y+6	; 0x06
    7174:	88 23       	and	r24, r24
    7176:	89 f4       	brne	.+34     	; 0x719a <prvProcessTimerOrBlockTask+0x52>
    7178:	2c 81       	ldd	r18, Y+4	; 0x04
    717a:	3d 81       	ldd	r19, Y+5	; 0x05
    717c:	89 81       	ldd	r24, Y+1	; 0x01
    717e:	9a 81       	ldd	r25, Y+2	; 0x02
    7180:	82 17       	cp	r24, r18
    7182:	93 07       	cpc	r25, r19
    7184:	50 f0       	brcs	.+20     	; 0x719a <prvProcessTimerOrBlockTask+0x52>
                {
                    ( void ) xTaskResumeAll();
    7186:	0e 94 a8 25 	call	0x4b50	; 0x4b50 <xTaskResumeAll>
                    prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    718a:	8c 81       	ldd	r24, Y+4	; 0x04
    718c:	9d 81       	ldd	r25, Y+5	; 0x05
    718e:	29 81       	ldd	r18, Y+1	; 0x01
    7190:	3a 81       	ldd	r19, Y+2	; 0x02
    7192:	b9 01       	movw	r22, r18
    7194:	0e 94 46 38 	call	0x708c	; 0x708c <prvProcessExpiredTimer>
    7198:	25 c0       	rjmp	.+74     	; 0x71e4 <prvProcessTimerOrBlockTask+0x9c>
                     * time has not been reached yet.  This task should therefore
                     * block to wait for the next expire time or a command to be
                     * received - whichever comes first.  The following line cannot
                     * be reached unless xNextExpireTime > xTimeNow, except in the
                     * case when the current timer list is empty. */
                    if( xListWasEmpty != pdFALSE )
    719a:	8e 81       	ldd	r24, Y+6	; 0x06
    719c:	88 23       	and	r24, r24
    719e:	51 f0       	breq	.+20     	; 0x71b4 <prvProcessTimerOrBlockTask+0x6c>
                    {
                        /* The current timer list is empty - is the overflow list
                         * also empty? */
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    71a0:	e0 91 be 07 	lds	r30, 0x07BE
    71a4:	f0 91 bf 07 	lds	r31, 0x07BF
    71a8:	80 81       	ld	r24, Z
    71aa:	1e 82       	std	Y+6, r1	; 0x06
    71ac:	88 23       	and	r24, r24
    71ae:	11 f4       	brne	.+4      	; 0x71b4 <prvProcessTimerOrBlockTask+0x6c>
    71b0:	81 e0       	ldi	r24, 0x01	; 1
    71b2:	8e 83       	std	Y+6, r24	; 0x06
                    }

                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    71b4:	40 91 a4 07 	lds	r20, 0x07A4
    71b8:	50 91 a5 07 	lds	r21, 0x07A5
    71bc:	2c 81       	ldd	r18, Y+4	; 0x04
    71be:	3d 81       	ldd	r19, Y+5	; 0x05
    71c0:	89 81       	ldd	r24, Y+1	; 0x01
    71c2:	9a 81       	ldd	r25, Y+2	; 0x02
    71c4:	28 1b       	sub	r18, r24
    71c6:	39 0b       	sbc	r19, r25
    71c8:	ca 01       	movw	r24, r20
    71ca:	b9 01       	movw	r22, r18
    71cc:	4e 81       	ldd	r20, Y+6	; 0x06
    71ce:	0e 94 08 22 	call	0x4410	; 0x4410 <vQueueWaitForMessageRestricted>

                    if( xTaskResumeAll() == pdFALSE )
    71d2:	0e 94 a8 25 	call	0x4b50	; 0x4b50 <xTaskResumeAll>
    71d6:	88 23       	and	r24, r24
    71d8:	29 f4       	brne	.+10     	; 0x71e4 <prvProcessTimerOrBlockTask+0x9c>
                    {
                        /* Yield to wait for either a command to arrive, or the
                         * block time to expire.  If a command arrived between the
                         * critical section being exited and this yield then the yield
                         * will not cause the task to block. */
                        portYIELD_WITHIN_API();
    71da:	0e 94 86 10 	call	0x210c	; 0x210c <vPortYield>
    71de:	02 c0       	rjmp	.+4      	; 0x71e4 <prvProcessTimerOrBlockTask+0x9c>
                    }
                }
            }
            else
            {
                ( void ) xTaskResumeAll();
    71e0:	0e 94 a8 25 	call	0x4b50	; 0x4b50 <xTaskResumeAll>
            }
        }
    }
    71e4:	26 96       	adiw	r28, 0x06	; 6
    71e6:	0f b6       	in	r0, 0x3f	; 63
    71e8:	f8 94       	cli
    71ea:	de bf       	out	0x3e, r29	; 62
    71ec:	0f be       	out	0x3f, r0	; 63
    71ee:	cd bf       	out	0x3d, r28	; 61
    71f0:	cf 91       	pop	r28
    71f2:	df 91       	pop	r29
    71f4:	08 95       	ret

000071f6 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

    static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
    {
    71f6:	df 93       	push	r29
    71f8:	cf 93       	push	r28
    71fa:	00 d0       	rcall	.+0      	; 0x71fc <prvGetNextExpireTime+0x6>
    71fc:	00 d0       	rcall	.+0      	; 0x71fe <prvGetNextExpireTime+0x8>
    71fe:	0f 92       	push	r0
    7200:	cd b7       	in	r28, 0x3d	; 61
    7202:	de b7       	in	r29, 0x3e	; 62
    7204:	9c 83       	std	Y+4, r25	; 0x04
    7206:	8b 83       	std	Y+3, r24	; 0x03
         * the timer with the nearest expiry time will expire.  If there are no
         * active timers then just set the next expire time to 0.  That will cause
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  */
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    7208:	e0 91 bc 07 	lds	r30, 0x07BC
    720c:	f0 91 bd 07 	lds	r31, 0x07BD
    7210:	80 81       	ld	r24, Z
    7212:	1d 82       	std	Y+5, r1	; 0x05
    7214:	88 23       	and	r24, r24
    7216:	11 f4       	brne	.+4      	; 0x721c <prvGetNextExpireTime+0x26>
    7218:	81 e0       	ldi	r24, 0x01	; 1
    721a:	8d 83       	std	Y+5, r24	; 0x05
    721c:	eb 81       	ldd	r30, Y+3	; 0x03
    721e:	fc 81       	ldd	r31, Y+4	; 0x04
    7220:	8d 81       	ldd	r24, Y+5	; 0x05
    7222:	80 83       	st	Z, r24

        if( *pxListWasEmpty == pdFALSE )
    7224:	eb 81       	ldd	r30, Y+3	; 0x03
    7226:	fc 81       	ldd	r31, Y+4	; 0x04
    7228:	80 81       	ld	r24, Z
    722a:	88 23       	and	r24, r24
    722c:	61 f4       	brne	.+24     	; 0x7246 <prvGetNextExpireTime+0x50>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    722e:	e0 91 bc 07 	lds	r30, 0x07BC
    7232:	f0 91 bd 07 	lds	r31, 0x07BD
    7236:	05 80       	ldd	r0, Z+5	; 0x05
    7238:	f6 81       	ldd	r31, Z+6	; 0x06
    723a:	e0 2d       	mov	r30, r0
    723c:	80 81       	ld	r24, Z
    723e:	91 81       	ldd	r25, Z+1	; 0x01
    7240:	9a 83       	std	Y+2, r25	; 0x02
    7242:	89 83       	std	Y+1, r24	; 0x01
    7244:	02 c0       	rjmp	.+4      	; 0x724a <prvGetNextExpireTime+0x54>
        }
        else
        {
            /* Ensure the task unblocks when the tick count rolls over. */
            xNextExpireTime = ( TickType_t ) 0U;
    7246:	1a 82       	std	Y+2, r1	; 0x02
    7248:	19 82       	std	Y+1, r1	; 0x01
        }

        return xNextExpireTime;
    724a:	89 81       	ldd	r24, Y+1	; 0x01
    724c:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    724e:	0f 90       	pop	r0
    7250:	0f 90       	pop	r0
    7252:	0f 90       	pop	r0
    7254:	0f 90       	pop	r0
    7256:	0f 90       	pop	r0
    7258:	cf 91       	pop	r28
    725a:	df 91       	pop	r29
    725c:	08 95       	ret

0000725e <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    {
    725e:	df 93       	push	r29
    7260:	cf 93       	push	r28
    7262:	00 d0       	rcall	.+0      	; 0x7264 <prvSampleTimeNow+0x6>
    7264:	00 d0       	rcall	.+0      	; 0x7266 <prvSampleTimeNow+0x8>
    7266:	cd b7       	in	r28, 0x3d	; 61
    7268:	de b7       	in	r29, 0x3e	; 62
    726a:	9c 83       	std	Y+4, r25	; 0x04
    726c:	8b 83       	std	Y+3, r24	; 0x03
        TickType_t xTimeNow;
        PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

        xTimeNow = xTaskGetTickCount();
    726e:	0e 94 f8 26 	call	0x4df0	; 0x4df0 <xTaskGetTickCount>
    7272:	9a 83       	std	Y+2, r25	; 0x02
    7274:	89 83       	std	Y+1, r24	; 0x01

        if( xTimeNow < xLastTime )
    7276:	20 91 a8 07 	lds	r18, 0x07A8
    727a:	30 91 a9 07 	lds	r19, 0x07A9
    727e:	89 81       	ldd	r24, Y+1	; 0x01
    7280:	9a 81       	ldd	r25, Y+2	; 0x02
    7282:	82 17       	cp	r24, r18
    7284:	93 07       	cpc	r25, r19
    7286:	38 f4       	brcc	.+14     	; 0x7296 <prvSampleTimeNow+0x38>
        {
            prvSwitchTimerLists();
    7288:	0e 94 c0 3a 	call	0x7580	; 0x7580 <prvSwitchTimerLists>
            *pxTimerListsWereSwitched = pdTRUE;
    728c:	eb 81       	ldd	r30, Y+3	; 0x03
    728e:	fc 81       	ldd	r31, Y+4	; 0x04
    7290:	81 e0       	ldi	r24, 0x01	; 1
    7292:	80 83       	st	Z, r24
    7294:	03 c0       	rjmp	.+6      	; 0x729c <prvSampleTimeNow+0x3e>
        }
        else
        {
            *pxTimerListsWereSwitched = pdFALSE;
    7296:	eb 81       	ldd	r30, Y+3	; 0x03
    7298:	fc 81       	ldd	r31, Y+4	; 0x04
    729a:	10 82       	st	Z, r1
        }

        xLastTime = xTimeNow;
    729c:	89 81       	ldd	r24, Y+1	; 0x01
    729e:	9a 81       	ldd	r25, Y+2	; 0x02
    72a0:	90 93 a9 07 	sts	0x07A9, r25
    72a4:	80 93 a8 07 	sts	0x07A8, r24

        return xTimeNow;
    72a8:	89 81       	ldd	r24, Y+1	; 0x01
    72aa:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    72ac:	0f 90       	pop	r0
    72ae:	0f 90       	pop	r0
    72b0:	0f 90       	pop	r0
    72b2:	0f 90       	pop	r0
    72b4:	cf 91       	pop	r28
    72b6:	df 91       	pop	r29
    72b8:	08 95       	ret

000072ba <prvInsertTimerInActiveList>:

    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
    72ba:	df 93       	push	r29
    72bc:	cf 93       	push	r28
    72be:	cd b7       	in	r28, 0x3d	; 61
    72c0:	de b7       	in	r29, 0x3e	; 62
    72c2:	29 97       	sbiw	r28, 0x09	; 9
    72c4:	0f b6       	in	r0, 0x3f	; 63
    72c6:	f8 94       	cli
    72c8:	de bf       	out	0x3e, r29	; 62
    72ca:	0f be       	out	0x3f, r0	; 63
    72cc:	cd bf       	out	0x3d, r28	; 61
    72ce:	9b 83       	std	Y+3, r25	; 0x03
    72d0:	8a 83       	std	Y+2, r24	; 0x02
    72d2:	7d 83       	std	Y+5, r23	; 0x05
    72d4:	6c 83       	std	Y+4, r22	; 0x04
    72d6:	5f 83       	std	Y+7, r21	; 0x07
    72d8:	4e 83       	std	Y+6, r20	; 0x06
    72da:	39 87       	std	Y+9, r19	; 0x09
    72dc:	28 87       	std	Y+8, r18	; 0x08
        BaseType_t xProcessTimerNow = pdFALSE;
    72de:	19 82       	std	Y+1, r1	; 0x01

        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    72e0:	ea 81       	ldd	r30, Y+2	; 0x02
    72e2:	fb 81       	ldd	r31, Y+3	; 0x03
    72e4:	8c 81       	ldd	r24, Y+4	; 0x04
    72e6:	9d 81       	ldd	r25, Y+5	; 0x05
    72e8:	93 83       	std	Z+3, r25	; 0x03
    72ea:	82 83       	std	Z+2, r24	; 0x02
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    72ec:	ea 81       	ldd	r30, Y+2	; 0x02
    72ee:	fb 81       	ldd	r31, Y+3	; 0x03
    72f0:	8a 81       	ldd	r24, Y+2	; 0x02
    72f2:	9b 81       	ldd	r25, Y+3	; 0x03
    72f4:	91 87       	std	Z+9, r25	; 0x09
    72f6:	80 87       	std	Z+8, r24	; 0x08

        if( xNextExpiryTime <= xTimeNow )
    72f8:	2c 81       	ldd	r18, Y+4	; 0x04
    72fa:	3d 81       	ldd	r19, Y+5	; 0x05
    72fc:	8e 81       	ldd	r24, Y+6	; 0x06
    72fe:	9f 81       	ldd	r25, Y+7	; 0x07
    7300:	82 17       	cp	r24, r18
    7302:	93 07       	cpc	r25, r19
    7304:	e0 f0       	brcs	.+56     	; 0x733e <prvInsertTimerInActiveList+0x84>
        {
            /* Has the expiry time elapsed between the command to start/reset a
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    7306:	2e 81       	ldd	r18, Y+6	; 0x06
    7308:	3f 81       	ldd	r19, Y+7	; 0x07
    730a:	88 85       	ldd	r24, Y+8	; 0x08
    730c:	99 85       	ldd	r25, Y+9	; 0x09
    730e:	28 1b       	sub	r18, r24
    7310:	39 0b       	sbc	r19, r25
    7312:	ea 81       	ldd	r30, Y+2	; 0x02
    7314:	fb 81       	ldd	r31, Y+3	; 0x03
    7316:	84 85       	ldd	r24, Z+12	; 0x0c
    7318:	95 85       	ldd	r25, Z+13	; 0x0d
    731a:	28 17       	cp	r18, r24
    731c:	39 07       	cpc	r19, r25
    731e:	18 f0       	brcs	.+6      	; 0x7326 <prvInsertTimerInActiveList+0x6c>
            {
                /* The time between a command being issued and the command being
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
    7320:	81 e0       	ldi	r24, 0x01	; 1
    7322:	89 83       	std	Y+1, r24	; 0x01
    7324:	28 c0       	rjmp	.+80     	; 0x7376 <prvInsertTimerInActiveList+0xbc>
            }
            else
            {
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    7326:	80 91 be 07 	lds	r24, 0x07BE
    732a:	90 91 bf 07 	lds	r25, 0x07BF
    732e:	2a 81       	ldd	r18, Y+2	; 0x02
    7330:	3b 81       	ldd	r19, Y+3	; 0x03
    7332:	2e 5f       	subi	r18, 0xFE	; 254
    7334:	3f 4f       	sbci	r19, 0xFF	; 255
    7336:	b9 01       	movw	r22, r18
    7338:	0e 94 3d 18 	call	0x307a	; 0x307a <vListInsert>
    733c:	1c c0       	rjmp	.+56     	; 0x7376 <prvInsertTimerInActiveList+0xbc>
            }
        }
        else
        {
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    733e:	2e 81       	ldd	r18, Y+6	; 0x06
    7340:	3f 81       	ldd	r19, Y+7	; 0x07
    7342:	88 85       	ldd	r24, Y+8	; 0x08
    7344:	99 85       	ldd	r25, Y+9	; 0x09
    7346:	28 17       	cp	r18, r24
    7348:	39 07       	cpc	r19, r25
    734a:	50 f4       	brcc	.+20     	; 0x7360 <prvInsertTimerInActiveList+0xa6>
    734c:	2c 81       	ldd	r18, Y+4	; 0x04
    734e:	3d 81       	ldd	r19, Y+5	; 0x05
    7350:	88 85       	ldd	r24, Y+8	; 0x08
    7352:	99 85       	ldd	r25, Y+9	; 0x09
    7354:	28 17       	cp	r18, r24
    7356:	39 07       	cpc	r19, r25
    7358:	18 f0       	brcs	.+6      	; 0x7360 <prvInsertTimerInActiveList+0xa6>
            {
                /* If, since the command was issued, the tick count has overflowed
                 * but the expiry time has not, then the timer must have already passed
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
    735a:	81 e0       	ldi	r24, 0x01	; 1
    735c:	89 83       	std	Y+1, r24	; 0x01
    735e:	0b c0       	rjmp	.+22     	; 0x7376 <prvInsertTimerInActiveList+0xbc>
            }
            else
            {
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    7360:	80 91 bc 07 	lds	r24, 0x07BC
    7364:	90 91 bd 07 	lds	r25, 0x07BD
    7368:	2a 81       	ldd	r18, Y+2	; 0x02
    736a:	3b 81       	ldd	r19, Y+3	; 0x03
    736c:	2e 5f       	subi	r18, 0xFE	; 254
    736e:	3f 4f       	sbci	r19, 0xFF	; 255
    7370:	b9 01       	movw	r22, r18
    7372:	0e 94 3d 18 	call	0x307a	; 0x307a <vListInsert>
            }
        }

        return xProcessTimerNow;
    7376:	89 81       	ldd	r24, Y+1	; 0x01
    }
    7378:	29 96       	adiw	r28, 0x09	; 9
    737a:	0f b6       	in	r0, 0x3f	; 63
    737c:	f8 94       	cli
    737e:	de bf       	out	0x3e, r29	; 62
    7380:	0f be       	out	0x3f, r0	; 63
    7382:	cd bf       	out	0x3d, r28	; 61
    7384:	cf 91       	pop	r28
    7386:	df 91       	pop	r29
    7388:	08 95       	ret

0000738a <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

    static void prvProcessReceivedCommands( void )
    {
    738a:	df 93       	push	r29
    738c:	cf 93       	push	r28
    738e:	cd b7       	in	r28, 0x3d	; 61
    7390:	de b7       	in	r29, 0x3e	; 62
    7392:	2c 97       	sbiw	r28, 0x0c	; 12
    7394:	0f b6       	in	r0, 0x3f	; 63
    7396:	f8 94       	cli
    7398:	de bf       	out	0x3e, r29	; 62
    739a:	0f be       	out	0x3f, r0	; 63
    739c:	cd bf       	out	0x3d, r28	; 61
    739e:	d8 c0       	rjmp	.+432    	; 0x7550 <prvProcessReceivedCommands+0x1c6>
                }
            #endif /* INCLUDE_xTimerPendFunctionCall */

            /* Commands that are positive are timer commands rather than pended
             * function calls. */
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    73a0:	8d 81       	ldd	r24, Y+5	; 0x05
    73a2:	88 23       	and	r24, r24
    73a4:	0c f4       	brge	.+2      	; 0x73a8 <prvProcessReceivedCommands+0x1e>
    73a6:	d4 c0       	rjmp	.+424    	; 0x7550 <prvProcessReceivedCommands+0x1c6>
            {
                /* The messages uses the xTimerParameters member to work on a
                 * software timer. */
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
    73a8:	88 85       	ldd	r24, Y+8	; 0x08
    73aa:	99 85       	ldd	r25, Y+9	; 0x09
    73ac:	9c 83       	std	Y+4, r25	; 0x04
    73ae:	8b 83       	std	Y+3, r24	; 0x03

                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    73b0:	eb 81       	ldd	r30, Y+3	; 0x03
    73b2:	fc 81       	ldd	r31, Y+4	; 0x04
    73b4:	82 85       	ldd	r24, Z+10	; 0x0a
    73b6:	93 85       	ldd	r25, Z+11	; 0x0b
    73b8:	00 97       	sbiw	r24, 0x00	; 0
    73ba:	29 f0       	breq	.+10     	; 0x73c6 <prvProcessReceivedCommands+0x3c>
                {
                    /* The timer is in a list, remove it. */
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    73bc:	8b 81       	ldd	r24, Y+3	; 0x03
    73be:	9c 81       	ldd	r25, Y+4	; 0x04
    73c0:	02 96       	adiw	r24, 0x02	; 2
    73c2:	0e 94 a9 18 	call	0x3152	; 0x3152 <uxListRemove>
                 *  it must be present in the function call.  prvSampleTimeNow() must be
                 *  called after the message is received from xTimerQueue so there is no
                 *  possibility of a higher priority task adding a message to the message
                 *  queue with a time that is ahead of the timer daemon task (because it
                 *  pre-empted the timer daemon task after the xTimeNow value was set). */
                xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    73c6:	ce 01       	movw	r24, r28
    73c8:	0a 96       	adiw	r24, 0x0a	; 10
    73ca:	0e 94 2f 39 	call	0x725e	; 0x725e <prvSampleTimeNow>
    73ce:	9a 83       	std	Y+2, r25	; 0x02
    73d0:	89 83       	std	Y+1, r24	; 0x01

                switch( xMessage.xMessageID )
    73d2:	8d 81       	ldd	r24, Y+5	; 0x05
    73d4:	28 2f       	mov	r18, r24
    73d6:	33 27       	eor	r19, r19
    73d8:	27 fd       	sbrc	r18, 7
    73da:	30 95       	com	r19
    73dc:	3c 87       	std	Y+12, r19	; 0x0c
    73de:	2b 87       	std	Y+11, r18	; 0x0b
    73e0:	8b 85       	ldd	r24, Y+11	; 0x0b
    73e2:	9c 85       	ldd	r25, Y+12	; 0x0c
    73e4:	85 30       	cpi	r24, 0x05	; 5
    73e6:	91 05       	cpc	r25, r1
    73e8:	09 f4       	brne	.+2      	; 0x73ec <prvProcessReceivedCommands+0x62>
    73ea:	9d c0       	rjmp	.+314    	; 0x7526 <prvProcessReceivedCommands+0x19c>
    73ec:	2b 85       	ldd	r18, Y+11	; 0x0b
    73ee:	3c 85       	ldd	r19, Y+12	; 0x0c
    73f0:	26 30       	cpi	r18, 0x06	; 6
    73f2:	31 05       	cpc	r19, r1
    73f4:	9c f4       	brge	.+38     	; 0x741c <prvProcessReceivedCommands+0x92>
    73f6:	8b 85       	ldd	r24, Y+11	; 0x0b
    73f8:	9c 85       	ldd	r25, Y+12	; 0x0c
    73fa:	83 30       	cpi	r24, 0x03	; 3
    73fc:	91 05       	cpc	r25, r1
    73fe:	09 f4       	brne	.+2      	; 0x7402 <prvProcessReceivedCommands+0x78>
    7400:	68 c0       	rjmp	.+208    	; 0x74d2 <prvProcessReceivedCommands+0x148>
    7402:	2b 85       	ldd	r18, Y+11	; 0x0b
    7404:	3c 85       	ldd	r19, Y+12	; 0x0c
    7406:	24 30       	cpi	r18, 0x04	; 4
    7408:	31 05       	cpc	r19, r1
    740a:	0c f0       	brlt	.+2      	; 0x740e <prvProcessReceivedCommands+0x84>
    740c:	6a c0       	rjmp	.+212    	; 0x74e2 <prvProcessReceivedCommands+0x158>
    740e:	8b 85       	ldd	r24, Y+11	; 0x0b
    7410:	9c 85       	ldd	r25, Y+12	; 0x0c
    7412:	81 30       	cpi	r24, 0x01	; 1
    7414:	91 05       	cpc	r25, r1
    7416:	0c f4       	brge	.+2      	; 0x741a <prvProcessReceivedCommands+0x90>
    7418:	9b c0       	rjmp	.+310    	; 0x7550 <prvProcessReceivedCommands+0x1c6>
    741a:	12 c0       	rjmp	.+36     	; 0x7440 <prvProcessReceivedCommands+0xb6>
    741c:	2b 85       	ldd	r18, Y+11	; 0x0b
    741e:	3c 85       	ldd	r19, Y+12	; 0x0c
    7420:	28 30       	cpi	r18, 0x08	; 8
    7422:	31 05       	cpc	r19, r1
    7424:	09 f4       	brne	.+2      	; 0x7428 <prvProcessReceivedCommands+0x9e>
    7426:	55 c0       	rjmp	.+170    	; 0x74d2 <prvProcessReceivedCommands+0x148>
    7428:	8b 85       	ldd	r24, Y+11	; 0x0b
    742a:	9c 85       	ldd	r25, Y+12	; 0x0c
    742c:	88 30       	cpi	r24, 0x08	; 8
    742e:	91 05       	cpc	r25, r1
    7430:	3c f0       	brlt	.+14     	; 0x7440 <prvProcessReceivedCommands+0xb6>
    7432:	2b 85       	ldd	r18, Y+11	; 0x0b
    7434:	3c 85       	ldd	r19, Y+12	; 0x0c
    7436:	29 30       	cpi	r18, 0x09	; 9
    7438:	31 05       	cpc	r19, r1
    743a:	09 f4       	brne	.+2      	; 0x743e <prvProcessReceivedCommands+0xb4>
    743c:	52 c0       	rjmp	.+164    	; 0x74e2 <prvProcessReceivedCommands+0x158>
    743e:	88 c0       	rjmp	.+272    	; 0x7550 <prvProcessReceivedCommands+0x1c6>
                    case tmrCOMMAND_START:
                    case tmrCOMMAND_START_FROM_ISR:
                    case tmrCOMMAND_RESET:
                    case tmrCOMMAND_RESET_FROM_ISR:
                        /* Start or restart a timer. */
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    7440:	eb 81       	ldd	r30, Y+3	; 0x03
    7442:	fc 81       	ldd	r31, Y+4	; 0x04
    7444:	82 89       	ldd	r24, Z+18	; 0x12
    7446:	81 60       	ori	r24, 0x01	; 1
    7448:	eb 81       	ldd	r30, Y+3	; 0x03
    744a:	fc 81       	ldd	r31, Y+4	; 0x04
    744c:	82 8b       	std	Z+18, r24	; 0x12

                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    744e:	2e 81       	ldd	r18, Y+6	; 0x06
    7450:	3f 81       	ldd	r19, Y+7	; 0x07
    7452:	eb 81       	ldd	r30, Y+3	; 0x03
    7454:	fc 81       	ldd	r31, Y+4	; 0x04
    7456:	84 85       	ldd	r24, Z+12	; 0x0c
    7458:	95 85       	ldd	r25, Z+13	; 0x0d
    745a:	a9 01       	movw	r20, r18
    745c:	48 0f       	add	r20, r24
    745e:	59 1f       	adc	r21, r25
    7460:	ee 81       	ldd	r30, Y+6	; 0x06
    7462:	ff 81       	ldd	r31, Y+7	; 0x07
    7464:	8b 81       	ldd	r24, Y+3	; 0x03
    7466:	9c 81       	ldd	r25, Y+4	; 0x04
    7468:	29 81       	ldd	r18, Y+1	; 0x01
    746a:	3a 81       	ldd	r19, Y+2	; 0x02
    746c:	ba 01       	movw	r22, r20
    746e:	a9 01       	movw	r20, r18
    7470:	9f 01       	movw	r18, r30
    7472:	0e 94 5d 39 	call	0x72ba	; 0x72ba <prvInsertTimerInActiveList>
    7476:	88 23       	and	r24, r24
    7478:	09 f4       	brne	.+2      	; 0x747c <prvProcessReceivedCommands+0xf2>
    747a:	6a c0       	rjmp	.+212    	; 0x7550 <prvProcessReceivedCommands+0x1c6>
                        {
                            /* The timer expired before it was added to the active
                             * timer list.  Process it now. */
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    747c:	eb 81       	ldd	r30, Y+3	; 0x03
    747e:	fc 81       	ldd	r31, Y+4	; 0x04
    7480:	82 89       	ldd	r24, Z+18	; 0x12
    7482:	88 2f       	mov	r24, r24
    7484:	90 e0       	ldi	r25, 0x00	; 0
    7486:	84 70       	andi	r24, 0x04	; 4
    7488:	90 70       	andi	r25, 0x00	; 0
    748a:	00 97       	sbiw	r24, 0x00	; 0
    748c:	91 f0       	breq	.+36     	; 0x74b2 <prvProcessReceivedCommands+0x128>
                            {
                                prvReloadTimer( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow );
    748e:	2e 81       	ldd	r18, Y+6	; 0x06
    7490:	3f 81       	ldd	r19, Y+7	; 0x07
    7492:	eb 81       	ldd	r30, Y+3	; 0x03
    7494:	fc 81       	ldd	r31, Y+4	; 0x04
    7496:	84 85       	ldd	r24, Z+12	; 0x0c
    7498:	95 85       	ldd	r25, Z+13	; 0x0d
    749a:	a9 01       	movw	r20, r18
    749c:	48 0f       	add	r20, r24
    749e:	59 1f       	adc	r21, r25
    74a0:	8b 81       	ldd	r24, Y+3	; 0x03
    74a2:	9c 81       	ldd	r25, Y+4	; 0x04
    74a4:	29 81       	ldd	r18, Y+1	; 0x01
    74a6:	3a 81       	ldd	r19, Y+2	; 0x02
    74a8:	ba 01       	movw	r22, r20
    74aa:	a9 01       	movw	r20, r18
    74ac:	0e 94 07 38 	call	0x700e	; 0x700e <prvReloadTimer>
    74b0:	07 c0       	rjmp	.+14     	; 0x74c0 <prvProcessReceivedCommands+0x136>
                            }
                            else
                            {
                                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    74b2:	eb 81       	ldd	r30, Y+3	; 0x03
    74b4:	fc 81       	ldd	r31, Y+4	; 0x04
    74b6:	82 89       	ldd	r24, Z+18	; 0x12
    74b8:	8e 7f       	andi	r24, 0xFE	; 254
    74ba:	eb 81       	ldd	r30, Y+3	; 0x03
    74bc:	fc 81       	ldd	r31, Y+4	; 0x04
    74be:	82 8b       	std	Z+18, r24	; 0x12
                            }

                            /* Call the timer callback. */
                            traceTIMER_EXPIRED( pxTimer );
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    74c0:	eb 81       	ldd	r30, Y+3	; 0x03
    74c2:	fc 81       	ldd	r31, Y+4	; 0x04
    74c4:	00 88       	ldd	r0, Z+16	; 0x10
    74c6:	f1 89       	ldd	r31, Z+17	; 0x11
    74c8:	e0 2d       	mov	r30, r0
    74ca:	8b 81       	ldd	r24, Y+3	; 0x03
    74cc:	9c 81       	ldd	r25, Y+4	; 0x04
    74ce:	09 95       	icall
    74d0:	3f c0       	rjmp	.+126    	; 0x7550 <prvProcessReceivedCommands+0x1c6>
                        break;

                    case tmrCOMMAND_STOP:
                    case tmrCOMMAND_STOP_FROM_ISR:
                        /* The timer has already been removed from the active list. */
                        pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    74d2:	eb 81       	ldd	r30, Y+3	; 0x03
    74d4:	fc 81       	ldd	r31, Y+4	; 0x04
    74d6:	82 89       	ldd	r24, Z+18	; 0x12
    74d8:	8e 7f       	andi	r24, 0xFE	; 254
    74da:	eb 81       	ldd	r30, Y+3	; 0x03
    74dc:	fc 81       	ldd	r31, Y+4	; 0x04
    74de:	82 8b       	std	Z+18, r24	; 0x12
    74e0:	37 c0       	rjmp	.+110    	; 0x7550 <prvProcessReceivedCommands+0x1c6>
                        break;

                    case tmrCOMMAND_CHANGE_PERIOD:
                    case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR:
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    74e2:	eb 81       	ldd	r30, Y+3	; 0x03
    74e4:	fc 81       	ldd	r31, Y+4	; 0x04
    74e6:	82 89       	ldd	r24, Z+18	; 0x12
    74e8:	81 60       	ori	r24, 0x01	; 1
    74ea:	eb 81       	ldd	r30, Y+3	; 0x03
    74ec:	fc 81       	ldd	r31, Y+4	; 0x04
    74ee:	82 8b       	std	Z+18, r24	; 0x12
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    74f0:	8e 81       	ldd	r24, Y+6	; 0x06
    74f2:	9f 81       	ldd	r25, Y+7	; 0x07
    74f4:	eb 81       	ldd	r30, Y+3	; 0x03
    74f6:	fc 81       	ldd	r31, Y+4	; 0x04
    74f8:	95 87       	std	Z+13, r25	; 0x0d
    74fa:	84 87       	std	Z+12, r24	; 0x0c
                         * be longer or shorter than the old one.  The command time is
                         * therefore set to the current time, and as the period cannot
                         * be zero the next expiry time can only be in the future,
                         * meaning (unlike for the xTimerStart() case above) there is
                         * no fail case that needs to be handled here. */
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    74fc:	eb 81       	ldd	r30, Y+3	; 0x03
    74fe:	fc 81       	ldd	r31, Y+4	; 0x04
    7500:	24 85       	ldd	r18, Z+12	; 0x0c
    7502:	35 85       	ldd	r19, Z+13	; 0x0d
    7504:	89 81       	ldd	r24, Y+1	; 0x01
    7506:	9a 81       	ldd	r25, Y+2	; 0x02
    7508:	a9 01       	movw	r20, r18
    750a:	48 0f       	add	r20, r24
    750c:	59 1f       	adc	r21, r25
    750e:	8b 81       	ldd	r24, Y+3	; 0x03
    7510:	9c 81       	ldd	r25, Y+4	; 0x04
    7512:	29 81       	ldd	r18, Y+1	; 0x01
    7514:	3a 81       	ldd	r19, Y+2	; 0x02
    7516:	e9 81       	ldd	r30, Y+1	; 0x01
    7518:	fa 81       	ldd	r31, Y+2	; 0x02
    751a:	ba 01       	movw	r22, r20
    751c:	a9 01       	movw	r20, r18
    751e:	9f 01       	movw	r18, r30
    7520:	0e 94 5d 39 	call	0x72ba	; 0x72ba <prvInsertTimerInActiveList>
    7524:	15 c0       	rjmp	.+42     	; 0x7550 <prvProcessReceivedCommands+0x1c6>
                        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                            {
                                /* The timer has already been removed from the active list,
                                 * just free up the memory if the memory was dynamically
                                 * allocated. */
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    7526:	eb 81       	ldd	r30, Y+3	; 0x03
    7528:	fc 81       	ldd	r31, Y+4	; 0x04
    752a:	82 89       	ldd	r24, Z+18	; 0x12
    752c:	88 2f       	mov	r24, r24
    752e:	90 e0       	ldi	r25, 0x00	; 0
    7530:	82 70       	andi	r24, 0x02	; 2
    7532:	90 70       	andi	r25, 0x00	; 0
    7534:	00 97       	sbiw	r24, 0x00	; 0
    7536:	29 f4       	brne	.+10     	; 0x7542 <prvProcessReceivedCommands+0x1b8>
                                {
                                    vPortFree( pxTimer );
    7538:	8b 81       	ldd	r24, Y+3	; 0x03
    753a:	9c 81       	ldd	r25, Y+4	; 0x04
    753c:	0e 94 a1 0e 	call	0x1d42	; 0x1d42 <vPortFree>
    7540:	07 c0       	rjmp	.+14     	; 0x7550 <prvProcessReceivedCommands+0x1c6>
                                }
                                else
                                {
                                    pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    7542:	eb 81       	ldd	r30, Y+3	; 0x03
    7544:	fc 81       	ldd	r31, Y+4	; 0x04
    7546:	82 89       	ldd	r24, Z+18	; 0x12
    7548:	8e 7f       	andi	r24, 0xFE	; 254
    754a:	eb 81       	ldd	r30, Y+3	; 0x03
    754c:	fc 81       	ldd	r31, Y+4	; 0x04
    754e:	82 8b       	std	Z+18, r24	; 0x12
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    7550:	80 91 a4 07 	lds	r24, 0x07A4
    7554:	90 91 a5 07 	lds	r25, 0x07A5
    7558:	9e 01       	movw	r18, r28
    755a:	2b 5f       	subi	r18, 0xFB	; 251
    755c:	3f 4f       	sbci	r19, 0xFF	; 255
    755e:	b9 01       	movw	r22, r18
    7560:	40 e0       	ldi	r20, 0x00	; 0
    7562:	50 e0       	ldi	r21, 0x00	; 0
    7564:	0e 94 a8 1b 	call	0x3750	; 0x3750 <xQueueReceive>
    7568:	88 23       	and	r24, r24
    756a:	09 f0       	breq	.+2      	; 0x756e <prvProcessReceivedCommands+0x1e4>
    756c:	19 cf       	rjmp	.-462    	; 0x73a0 <prvProcessReceivedCommands+0x16>
                        /* Don't expect to get here. */
                        break;
                }
            }
        }
    }
    756e:	2c 96       	adiw	r28, 0x0c	; 12
    7570:	0f b6       	in	r0, 0x3f	; 63
    7572:	f8 94       	cli
    7574:	de bf       	out	0x3e, r29	; 62
    7576:	0f be       	out	0x3f, r0	; 63
    7578:	cd bf       	out	0x3d, r28	; 61
    757a:	cf 91       	pop	r28
    757c:	df 91       	pop	r29
    757e:	08 95       	ret

00007580 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

    static void prvSwitchTimerLists( void )
    {
    7580:	df 93       	push	r29
    7582:	cf 93       	push	r28
    7584:	00 d0       	rcall	.+0      	; 0x7586 <prvSwitchTimerLists+0x6>
    7586:	00 d0       	rcall	.+0      	; 0x7588 <prvSwitchTimerLists+0x8>
    7588:	cd b7       	in	r28, 0x3d	; 61
    758a:	de b7       	in	r29, 0x3e	; 62
    758c:	11 c0       	rjmp	.+34     	; 0x75b0 <prvSwitchTimerLists+0x30>
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    758e:	e0 91 bc 07 	lds	r30, 0x07BC
    7592:	f0 91 bd 07 	lds	r31, 0x07BD
    7596:	05 80       	ldd	r0, Z+5	; 0x05
    7598:	f6 81       	ldd	r31, Z+6	; 0x06
    759a:	e0 2d       	mov	r30, r0
    759c:	80 81       	ld	r24, Z
    759e:	91 81       	ldd	r25, Z+1	; 0x01
    75a0:	9c 83       	std	Y+4, r25	; 0x04
    75a2:	8b 83       	std	Y+3, r24	; 0x03

            /* Process the expired timer.  For auto-reload timers, be careful to
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
    75a4:	8b 81       	ldd	r24, Y+3	; 0x03
    75a6:	9c 81       	ldd	r25, Y+4	; 0x04
    75a8:	6f ef       	ldi	r22, 0xFF	; 255
    75aa:	7f ef       	ldi	r23, 0xFF	; 255
    75ac:	0e 94 46 38 	call	0x708c	; 0x708c <prvProcessExpiredTimer>

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    75b0:	e0 91 bc 07 	lds	r30, 0x07BC
    75b4:	f0 91 bd 07 	lds	r31, 0x07BD
    75b8:	80 81       	ld	r24, Z
    75ba:	88 23       	and	r24, r24
    75bc:	41 f7       	brne	.-48     	; 0x758e <prvSwitchTimerLists+0xe>
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
        }

        pxTemp = pxCurrentTimerList;
    75be:	80 91 bc 07 	lds	r24, 0x07BC
    75c2:	90 91 bd 07 	lds	r25, 0x07BD
    75c6:	9a 83       	std	Y+2, r25	; 0x02
    75c8:	89 83       	std	Y+1, r24	; 0x01
        pxCurrentTimerList = pxOverflowTimerList;
    75ca:	80 91 be 07 	lds	r24, 0x07BE
    75ce:	90 91 bf 07 	lds	r25, 0x07BF
    75d2:	90 93 bd 07 	sts	0x07BD, r25
    75d6:	80 93 bc 07 	sts	0x07BC, r24
        pxOverflowTimerList = pxTemp;
    75da:	89 81       	ldd	r24, Y+1	; 0x01
    75dc:	9a 81       	ldd	r25, Y+2	; 0x02
    75de:	90 93 bf 07 	sts	0x07BF, r25
    75e2:	80 93 be 07 	sts	0x07BE, r24
    }
    75e6:	0f 90       	pop	r0
    75e8:	0f 90       	pop	r0
    75ea:	0f 90       	pop	r0
    75ec:	0f 90       	pop	r0
    75ee:	cf 91       	pop	r28
    75f0:	df 91       	pop	r29
    75f2:	08 95       	ret

000075f4 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

    static void prvCheckForValidListAndQueue( void )
    {
    75f4:	df 93       	push	r29
    75f6:	cf 93       	push	r28
    75f8:	cd b7       	in	r28, 0x3d	; 61
    75fa:	de b7       	in	r29, 0x3e	; 62
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
    75fc:	0f b6       	in	r0, 0x3f	; 63
    75fe:	f8 94       	cli
    7600:	0f 92       	push	r0
        {
            if( xTimerQueue == NULL )
    7602:	80 91 a4 07 	lds	r24, 0x07A4
    7606:	90 91 a5 07 	lds	r25, 0x07A5
    760a:	00 97       	sbiw	r24, 0x00	; 0
    760c:	e9 f4       	brne	.+58     	; 0x7648 <prvCheckForValidListAndQueue+0x54>
            {
                vListInitialise( &xActiveTimerList1 );
    760e:	8a ea       	ldi	r24, 0xAA	; 170
    7610:	97 e0       	ldi	r25, 0x07	; 7
    7612:	0e 94 bf 17 	call	0x2f7e	; 0x2f7e <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
    7616:	83 eb       	ldi	r24, 0xB3	; 179
    7618:	97 e0       	ldi	r25, 0x07	; 7
    761a:	0e 94 bf 17 	call	0x2f7e	; 0x2f7e <vListInitialise>
                pxCurrentTimerList = &xActiveTimerList1;
    761e:	8a ea       	ldi	r24, 0xAA	; 170
    7620:	97 e0       	ldi	r25, 0x07	; 7
    7622:	90 93 bd 07 	sts	0x07BD, r25
    7626:	80 93 bc 07 	sts	0x07BC, r24
                pxOverflowTimerList = &xActiveTimerList2;
    762a:	83 eb       	ldi	r24, 0xB3	; 179
    762c:	97 e0       	ldi	r25, 0x07	; 7
    762e:	90 93 bf 07 	sts	0x07BF, r25
    7632:	80 93 be 07 	sts	0x07BE, r24

                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
                    }
                #else
                    {
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    7636:	8a e0       	ldi	r24, 0x0A	; 10
    7638:	65 e0       	ldi	r22, 0x05	; 5
    763a:	40 e0       	ldi	r20, 0x00	; 0
    763c:	0e 94 a0 19 	call	0x3340	; 0x3340 <xQueueGenericCreate>
    7640:	90 93 a5 07 	sts	0x07A5, r25
    7644:	80 93 a4 07 	sts	0x07A4, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    7648:	0f 90       	pop	r0
    764a:	0f be       	out	0x3f, r0	; 63
    }
    764c:	cf 91       	pop	r28
    764e:	df 91       	pop	r29
    7650:	08 95       	ret

00007652 <xTimerIsTimerActive>:
/*-----------------------------------------------------------*/

    BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
    {
    7652:	df 93       	push	r29
    7654:	cf 93       	push	r28
    7656:	00 d0       	rcall	.+0      	; 0x7658 <xTimerIsTimerActive+0x6>
    7658:	00 d0       	rcall	.+0      	; 0x765a <xTimerIsTimerActive+0x8>
    765a:	0f 92       	push	r0
    765c:	cd b7       	in	r28, 0x3d	; 61
    765e:	de b7       	in	r29, 0x3e	; 62
    7660:	9d 83       	std	Y+5, r25	; 0x05
    7662:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;
        Timer_t * pxTimer = xTimer;
    7664:	8c 81       	ldd	r24, Y+4	; 0x04
    7666:	9d 81       	ldd	r25, Y+5	; 0x05
    7668:	9a 83       	std	Y+2, r25	; 0x02
    766a:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );

        /* Is the timer in the list of active timers? */
        taskENTER_CRITICAL();
    766c:	0f b6       	in	r0, 0x3f	; 63
    766e:	f8 94       	cli
    7670:	0f 92       	push	r0
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0 )
    7672:	e9 81       	ldd	r30, Y+1	; 0x01
    7674:	fa 81       	ldd	r31, Y+2	; 0x02
    7676:	82 89       	ldd	r24, Z+18	; 0x12
    7678:	88 2f       	mov	r24, r24
    767a:	90 e0       	ldi	r25, 0x00	; 0
    767c:	81 70       	andi	r24, 0x01	; 1
    767e:	90 70       	andi	r25, 0x00	; 0
    7680:	00 97       	sbiw	r24, 0x00	; 0
    7682:	11 f4       	brne	.+4      	; 0x7688 <xTimerIsTimerActive+0x36>
            {
                xReturn = pdFALSE;
    7684:	1b 82       	std	Y+3, r1	; 0x03
    7686:	02 c0       	rjmp	.+4      	; 0x768c <xTimerIsTimerActive+0x3a>
            }
            else
            {
                xReturn = pdTRUE;
    7688:	81 e0       	ldi	r24, 0x01	; 1
    768a:	8b 83       	std	Y+3, r24	; 0x03
            }
        }
        taskEXIT_CRITICAL();
    768c:	0f 90       	pop	r0
    768e:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    7690:	8b 81       	ldd	r24, Y+3	; 0x03
    } /*lint !e818 Can't be pointer to const due to the typedef. */
    7692:	0f 90       	pop	r0
    7694:	0f 90       	pop	r0
    7696:	0f 90       	pop	r0
    7698:	0f 90       	pop	r0
    769a:	0f 90       	pop	r0
    769c:	cf 91       	pop	r28
    769e:	df 91       	pop	r29
    76a0:	08 95       	ret

000076a2 <pvTimerGetTimerID>:
/*-----------------------------------------------------------*/

    void * pvTimerGetTimerID( const TimerHandle_t xTimer )
    {
    76a2:	df 93       	push	r29
    76a4:	cf 93       	push	r28
    76a6:	00 d0       	rcall	.+0      	; 0x76a8 <pvTimerGetTimerID+0x6>
    76a8:	00 d0       	rcall	.+0      	; 0x76aa <pvTimerGetTimerID+0x8>
    76aa:	00 d0       	rcall	.+0      	; 0x76ac <pvTimerGetTimerID+0xa>
    76ac:	cd b7       	in	r28, 0x3d	; 61
    76ae:	de b7       	in	r29, 0x3e	; 62
    76b0:	9e 83       	std	Y+6, r25	; 0x06
    76b2:	8d 83       	std	Y+5, r24	; 0x05
        Timer_t * const pxTimer = xTimer;
    76b4:	8d 81       	ldd	r24, Y+5	; 0x05
    76b6:	9e 81       	ldd	r25, Y+6	; 0x06
    76b8:	9c 83       	std	Y+4, r25	; 0x04
    76ba:	8b 83       	std	Y+3, r24	; 0x03
        void * pvReturn;

        configASSERT( xTimer );

        taskENTER_CRITICAL();
    76bc:	0f b6       	in	r0, 0x3f	; 63
    76be:	f8 94       	cli
    76c0:	0f 92       	push	r0
        {
            pvReturn = pxTimer->pvTimerID;
    76c2:	eb 81       	ldd	r30, Y+3	; 0x03
    76c4:	fc 81       	ldd	r31, Y+4	; 0x04
    76c6:	86 85       	ldd	r24, Z+14	; 0x0e
    76c8:	97 85       	ldd	r25, Z+15	; 0x0f
    76ca:	9a 83       	std	Y+2, r25	; 0x02
    76cc:	89 83       	std	Y+1, r24	; 0x01
        }
        taskEXIT_CRITICAL();
    76ce:	0f 90       	pop	r0
    76d0:	0f be       	out	0x3f, r0	; 63

        return pvReturn;
    76d2:	89 81       	ldd	r24, Y+1	; 0x01
    76d4:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    76d6:	26 96       	adiw	r28, 0x06	; 6
    76d8:	0f b6       	in	r0, 0x3f	; 63
    76da:	f8 94       	cli
    76dc:	de bf       	out	0x3e, r29	; 62
    76de:	0f be       	out	0x3f, r0	; 63
    76e0:	cd bf       	out	0x3d, r28	; 61
    76e2:	cf 91       	pop	r28
    76e4:	df 91       	pop	r29
    76e6:	08 95       	ret

000076e8 <vTimerSetTimerID>:
/*-----------------------------------------------------------*/

    void vTimerSetTimerID( TimerHandle_t xTimer,
                           void * pvNewID )
    {
    76e8:	df 93       	push	r29
    76ea:	cf 93       	push	r28
    76ec:	00 d0       	rcall	.+0      	; 0x76ee <vTimerSetTimerID+0x6>
    76ee:	00 d0       	rcall	.+0      	; 0x76f0 <vTimerSetTimerID+0x8>
    76f0:	00 d0       	rcall	.+0      	; 0x76f2 <vTimerSetTimerID+0xa>
    76f2:	cd b7       	in	r28, 0x3d	; 61
    76f4:	de b7       	in	r29, 0x3e	; 62
    76f6:	9c 83       	std	Y+4, r25	; 0x04
    76f8:	8b 83       	std	Y+3, r24	; 0x03
    76fa:	7e 83       	std	Y+6, r23	; 0x06
    76fc:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * const pxTimer = xTimer;
    76fe:	8b 81       	ldd	r24, Y+3	; 0x03
    7700:	9c 81       	ldd	r25, Y+4	; 0x04
    7702:	9a 83       	std	Y+2, r25	; 0x02
    7704:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );

        taskENTER_CRITICAL();
    7706:	0f b6       	in	r0, 0x3f	; 63
    7708:	f8 94       	cli
    770a:	0f 92       	push	r0
        {
            pxTimer->pvTimerID = pvNewID;
    770c:	e9 81       	ldd	r30, Y+1	; 0x01
    770e:	fa 81       	ldd	r31, Y+2	; 0x02
    7710:	8d 81       	ldd	r24, Y+5	; 0x05
    7712:	9e 81       	ldd	r25, Y+6	; 0x06
    7714:	97 87       	std	Z+15, r25	; 0x0f
    7716:	86 87       	std	Z+14, r24	; 0x0e
        }
        taskEXIT_CRITICAL();
    7718:	0f 90       	pop	r0
    771a:	0f be       	out	0x3f, r0	; 63
    }
    771c:	26 96       	adiw	r28, 0x06	; 6
    771e:	0f b6       	in	r0, 0x3f	; 63
    7720:	f8 94       	cli
    7722:	de bf       	out	0x3e, r29	; 62
    7724:	0f be       	out	0x3f, r0	; 63
    7726:	cd bf       	out	0x3d, r28	; 61
    7728:	cf 91       	pop	r28
    772a:	df 91       	pop	r29
    772c:	08 95       	ret

0000772e <__udivmodhi4>:
    772e:	aa 1b       	sub	r26, r26
    7730:	bb 1b       	sub	r27, r27
    7732:	51 e1       	ldi	r21, 0x11	; 17
    7734:	07 c0       	rjmp	.+14     	; 0x7744 <__udivmodhi4_ep>

00007736 <__udivmodhi4_loop>:
    7736:	aa 1f       	adc	r26, r26
    7738:	bb 1f       	adc	r27, r27
    773a:	a6 17       	cp	r26, r22
    773c:	b7 07       	cpc	r27, r23
    773e:	10 f0       	brcs	.+4      	; 0x7744 <__udivmodhi4_ep>
    7740:	a6 1b       	sub	r26, r22
    7742:	b7 0b       	sbc	r27, r23

00007744 <__udivmodhi4_ep>:
    7744:	88 1f       	adc	r24, r24
    7746:	99 1f       	adc	r25, r25
    7748:	5a 95       	dec	r21
    774a:	a9 f7       	brne	.-22     	; 0x7736 <__udivmodhi4_loop>
    774c:	80 95       	com	r24
    774e:	90 95       	com	r25
    7750:	bc 01       	movw	r22, r24
    7752:	cd 01       	movw	r24, r26
    7754:	08 95       	ret

00007756 <__prologue_saves__>:
    7756:	2f 92       	push	r2
    7758:	3f 92       	push	r3
    775a:	4f 92       	push	r4
    775c:	5f 92       	push	r5
    775e:	6f 92       	push	r6
    7760:	7f 92       	push	r7
    7762:	8f 92       	push	r8
    7764:	9f 92       	push	r9
    7766:	af 92       	push	r10
    7768:	bf 92       	push	r11
    776a:	cf 92       	push	r12
    776c:	df 92       	push	r13
    776e:	ef 92       	push	r14
    7770:	ff 92       	push	r15
    7772:	0f 93       	push	r16
    7774:	1f 93       	push	r17
    7776:	cf 93       	push	r28
    7778:	df 93       	push	r29
    777a:	cd b7       	in	r28, 0x3d	; 61
    777c:	de b7       	in	r29, 0x3e	; 62
    777e:	ca 1b       	sub	r28, r26
    7780:	db 0b       	sbc	r29, r27
    7782:	0f b6       	in	r0, 0x3f	; 63
    7784:	f8 94       	cli
    7786:	de bf       	out	0x3e, r29	; 62
    7788:	0f be       	out	0x3f, r0	; 63
    778a:	cd bf       	out	0x3d, r28	; 61
    778c:	09 94       	ijmp

0000778e <__epilogue_restores__>:
    778e:	2a 88       	ldd	r2, Y+18	; 0x12
    7790:	39 88       	ldd	r3, Y+17	; 0x11
    7792:	48 88       	ldd	r4, Y+16	; 0x10
    7794:	5f 84       	ldd	r5, Y+15	; 0x0f
    7796:	6e 84       	ldd	r6, Y+14	; 0x0e
    7798:	7d 84       	ldd	r7, Y+13	; 0x0d
    779a:	8c 84       	ldd	r8, Y+12	; 0x0c
    779c:	9b 84       	ldd	r9, Y+11	; 0x0b
    779e:	aa 84       	ldd	r10, Y+10	; 0x0a
    77a0:	b9 84       	ldd	r11, Y+9	; 0x09
    77a2:	c8 84       	ldd	r12, Y+8	; 0x08
    77a4:	df 80       	ldd	r13, Y+7	; 0x07
    77a6:	ee 80       	ldd	r14, Y+6	; 0x06
    77a8:	fd 80       	ldd	r15, Y+5	; 0x05
    77aa:	0c 81       	ldd	r16, Y+4	; 0x04
    77ac:	1b 81       	ldd	r17, Y+3	; 0x03
    77ae:	aa 81       	ldd	r26, Y+2	; 0x02
    77b0:	b9 81       	ldd	r27, Y+1	; 0x01
    77b2:	ce 0f       	add	r28, r30
    77b4:	d1 1d       	adc	r29, r1
    77b6:	0f b6       	in	r0, 0x3f	; 63
    77b8:	f8 94       	cli
    77ba:	de bf       	out	0x3e, r29	; 62
    77bc:	0f be       	out	0x3f, r0	; 63
    77be:	cd bf       	out	0x3d, r28	; 61
    77c0:	ed 01       	movw	r28, r26
    77c2:	08 95       	ret

000077c4 <memcpy>:
    77c4:	fb 01       	movw	r30, r22
    77c6:	dc 01       	movw	r26, r24
    77c8:	02 c0       	rjmp	.+4      	; 0x77ce <memcpy+0xa>
    77ca:	01 90       	ld	r0, Z+
    77cc:	0d 92       	st	X+, r0
    77ce:	41 50       	subi	r20, 0x01	; 1
    77d0:	50 40       	sbci	r21, 0x00	; 0
    77d2:	d8 f7       	brcc	.-10     	; 0x77ca <memcpy+0x6>
    77d4:	08 95       	ret

000077d6 <memset>:
    77d6:	dc 01       	movw	r26, r24
    77d8:	01 c0       	rjmp	.+2      	; 0x77dc <memset+0x6>
    77da:	6d 93       	st	X+, r22
    77dc:	41 50       	subi	r20, 0x01	; 1
    77de:	50 40       	sbci	r21, 0x00	; 0
    77e0:	e0 f7       	brcc	.-8      	; 0x77da <memset+0x4>
    77e2:	08 95       	ret

000077e4 <_exit>:
    77e4:	f8 94       	cli

000077e6 <__stop_program>:
    77e6:	ff cf       	rjmp	.-2      	; 0x77e6 <__stop_program>
